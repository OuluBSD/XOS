	.TITLE	opout - Opcode output routines for GECKO86

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

	.PROC	80386
	.INCLUD	XOSINC:/xmac/xos.par
	.INCLUD	XOSINC:/xmac/xostrm.par
	.INCLUD	XOSINC:/xmac/xosrun.par
	.INCLUD	gecko.par

	CODE

;Define values for the rgopsz byte

SZ_OPR=!0t		;Use size of operand for register size
SZ_8  =!2t		;8 bit register
SZ_16 =!4t		;16 bit register
SZ_32 =!6t		;32 bit register

;Subroutine to output value as instruction
;	CALL	outopc
;	C:clr = Normal
;	C:set = Error

outopc::MOVL	EBX, opnaddr#		;Get first byte
	MOVL	opxaddr#, EBX
	CALL	getmbyte#
	JC	hvaerr
	MOVB	value#, AL		;Save first byte
	MOVB	adrsz16, #0		;Alway have a 32-bit segment!
	MOVB	oprsz16, #0
	MOVB	rgopsz, #SZ_OPR
	MOVB	reppfx, #0		;No repeat prefix yet
	MOVB	segpfx, #0		;No segment prefix yet
	MOVB	opnsiz#, #0		;Clear length of instruction
outop2:	MOVB	oofetch, #0		;Indicate no additional bytes yet
	MOVL	ESI, #doptbl#		;Point to start of opcode display
	MOVL	ECX, #DOPTSIZ#		;  table
2$:	MOVB	AL, value#		;Get byte we are searching for
	XORB	AL, opo_byt0[ESI]	;Combine with table value
	ANDB	AL, opo_msk0[ESI]	;Mask out don't care bits
	JNE	outonx			;No match
	CMPB	opo_msk1[ESI], #0	;Do we care about the next byte?
	JE	10$			;No - we have a full match
	CMPB	oofetch, #1		;Yes - have we fetched it yet?
	JAE	6$			;Yes
	INCW	BX			;No - bump address
	INCB	oofetch
	CALL	getmbyte#		;Get next byte
	JC	hvaerr
	MOVB	value#+1, AL		;Save second byte
6$:	MOVB	AL, value#+1		;Get byte we are searching for
	XORB	AL, opo_byt1[ESI]	;Combine with table value
	ANDB	AL, opo_msk1[ESI]	;Mask out don`t care bits
	JNE	outonx			;No match - continue
	CMPB	opo_msk2[ESI], #0	;Do we care about the next byte?
	JE	10$			;No - we have a full match
	CMPB	oofetch, #2		;Yes - have we fetched it yet?
	JAE	8$			;Yes
	INCL	EBX			;No - bump address
	INCB	oofetch
	CALL	getmbyte#		;Get next byte
	JC	hvaerr
	MOVB	value+2, AL		;Save second byte
8$:	MOVB	AL, value#+2		;Get byte we are searching for
	XORB	AL, opo_byt2[ESI]	;Combine with table value
	ANDB	AL, opo_msk2[ESI]	;Mask out don't care bits
	JE	10$			;If have a full match
outonx:	ADDL	ESI, #opo_ENSZ		;Not this one - bump pointer
	LOOP	ECX, 2$			;Continue if more to check
badopc:	MOVB	validi#, #0		;Indicate not valid instruction
	MOVL	EBX, #bdomsg		;Bad opcode
	CALL	outstr#
	MOVB	AL, value#		;Display the opcode byte
	CALL	outby0#			;And return	
	MOVB	opnsiz#, #1		;Treat it as 1 byte long
	CLC
	RET

;Here with full match

10$:	JMPIL	opo_disp[ESI]		;Dispatch to output routine

;Here with memory access error

hvaerr::MOVL	EBX, #adrmsg#
	CALL	outstr#
	STC
	RET
.PAGE
;Here for one byte instruction without operand

donebyt::
	MOVB	AL, #1			;This is a 1 byte item
	JMP	opsout

;Here for two byte instruction without operand

dtwobyt::
	MOVB	AL, #2			;This is a two byte item
	JMP	opsout

;Here for three byte instruction without operand

dthrbyt::
	MOVB	AL, #3			;This is a three byte item
opsout:	ADDB	opnsiz, AL
	MOVL	EBX, opo_name32[ESI]	;Get address of string (assume 32 bit)
	TESTB	oprsz16, #1		;Right?
	JE	2$			;Yes
	MOVL	EBX, opo_name16[ESI]	;No - its 16 bit
2$:	CALL	oopstr			;Output the string
	JMP	outtab#			;Display tab and return

;Here for instruction with single 32-bit register operand specified in 2nd
;  byte of instruction

donefreg::
	MOVB	AL, #1			;Display the opcode
	CALL	opsout
	MOVB	AL, value#+1		;Get register
	JMP	dspreg32		;Display it and return

;Here for instruction with single operand

doneopr::
	MOVB	AL, #2			;Assume this is a 2 byte instruction
	CALL	opsout			;Output opcode
	MOVL	EAX, opxaddr		;Store address of possible offset
	ADDL	EAX, #2
	MOVL	opofset, EAX
	CALL	getoo1			;Get mode byte
	JC	hvaerr
.PAGE
;Subroutine to display operand
;	CALL	doprnd
;	C:clr = Normal
;	C:set = Memory error, message already displayed

doprnd:	MOVB	AL, value+1		;Get mode byte
	ANDB	AL, #0C7h		;Remove opcode extension or register
					;  bits
	TESTB	adrsz16, #1		;Is this a 16 bit address mode?
	JE	10$			;No - go handle 32 bit case
	CMPB	AL, #6			;Yes - direct memory address?
	JE	d1opmem			;Yes - go handle that case
	MOVZBL	EBX, AL			;Dispatch on the mod bits
	SHRL	EBX, #4
	JMPIL	d1opdsp16[EBX]

;Dispatch table for mod bits for operand

	.MOD	4
d1opdsp16:
	.LONG	d1op0d16		;00xxxxxx - No displacement value
	.LONG	d1op8d			;01xxxxxx - 8 bit displacement value
	.LONG	d1op16d16		;10xxxxxx - 16 bit displacement value
	.LONG	d1opreg			;11xxxxxx - Register

;Here for 32 bit address modes

10$:	CMPB	AL, #5			;Yes - direct memory address?
	JE	d1opmem			;Yes - go handle that case
	MOVZBL	EBX, AL			;Dispatch on the mod bits
	CMPB	AL, #0x04		;Is there an sib byte?
	JE	12$
	CMPB	AL, #0x44
	JE	12$
	CMPB	AL, #0x84
	JNE	18$			;No
12$:	PUSHL	EBX			;Yes - get it
	MOVL	EBX, opxaddr		;Get sib byte
	INCL	EBX
	INCL	EBX
	CALL	getmbyte#
	MOVB	value+2, AL
	INCB	opnsiz			;Adjust item size
	INCL	opofset			;Adjust address of offset value
	POPL	EBX
	ANDB	AL, #7
	CMPB	AL, #5			;Is this the d32+(scaled index) mode?
	JNE	18$			;No
	TESTB	BL, #0xC0		;Maybe
	JE	d1op32d32		;Yes
18$:	SHRL	EBX, #4			;Dispatch on the mod bits
	JMPIL	d1opdsp32[EBX]

;Dispatch table for mod bits for operand

	.MOD	4
d1opdsp32:
	.LONG	d1op0d32		;00xxxxxx - No displacement value
	.LONG	d1op8d			;01xxxxxx - 8 bit displacement value
	.LONG	d1op32d32		;10xxxxxx - 32 bit displacement value
	.LONG	d1opreg			;11xxxxxx - Register
.PAGE
;Here for 16 bit memory address operand

d1opmem:MOVZBL	EAX, segpfx		;Remember segment prefix
	PUSHL	EAX
	CALL	dsegspc			;Display segment specification
	MOVL	EBX, opofset		;Get address of memory offset
	TESTB	adrsz16, #1		;16 bit address?
	JE	2$			;No
	ADDB	opnsiz, #2		;Yes - adjust item size
	ADDL	opofset, #2
	CALL	getmword#		;Get word from memory
	JMP	4$

2$:	ADDB	opnsiz, #4		;Adjust item size
	ADDL	opofset, #4
	CALL	getmlong#		;Get long from memory
4$:	JC	10$			;If error
	MOVL	EDI, EBX
	SUBL	EDI, opxaddr#
	MOVL	value[EDI], EAX
	MOVL	EDX, uregDS#
	POPL	EBX			;Get segment prefix value
	TESTL	EBX, EBX		;Did we have one?
	JE	6$			;No
	MOVL	EDX, uregES#-2[EBX*2]	;Yes - get right segment prefix value
6$:	CALL	outaddr#		;Display value of the word as
	CLC				;  address in the data segment
	RET

10$:	POPL	EAX
	JMP	hvaerr
.PAGE
;Here for operand with 8 bit displacement value (16 or 32 bit modes)
;  This is displayed as disp.B[R1] or disp.B[R1+R2] (for 16 bit modes) or
;  as disp.B[R1], disp.B[R1+R2], disp.B[R2*n], or disp.B[R1+R2*n] (32 bit
;  modes)

d1op8d::CALL	dsegspc			;Display segment specification
	INCB	opnsiz			;Adjust item size
	MOVL	EBX, opofset		;Get 8 bit offset
	CALL	getmbyte#
	JC	hvaerr
	INCL	opofset
	MOVL	EDI, EBX
	SUBL	EDI, opxaddr
	MOVB	value[EDI], AL
	MOVXBL	EAX, AL
	CALL	outby0#			;Display value of the byte
	MOVB	AL, #'.'
	CALL	outchr#
	MOVB	AL, #'B'
	CALL	outchr#
	TESTB	adrsz16, #1		;16 bit address mode?
	JNE	d1op0d16		;Yes - display 16 bit register part
	JMP	d1op0d32		;No - display 32 bit register part

;Here for operand with 16 bit displacement value (16 bit mode)
;  This is displayed as disp[R1] or disp[R1+R2]

d1op16d16:
	CALL	dsegspc			;Display segment specification
	ADDB	opnsiz, #2		;Adjust item size
	MOVL	EBX, opofset		;Get 16 bit offset
	CALL	getmword#
	JC	hvaerr
	ADDL	opofset, #2
	MOVL	EDI, EBX
	SUBL	EDI, opxaddr#
	CWD
	MOVL	value#[EDI], EAX
	CALL	outwordna#		;Display value of word

;Here for operand with no displacement value (16 bit mode)
;  This is displayed as [R1] or [R1+R2]

d1op0d16:
	CALL	dsegspc			;Display segment specification
	MOVZBL	EBX, value+1		;Get the r/m bits
	ANDB	BL, #7
	LEAL	EBX, d1indx16[EBX*8]	;Get address of string
	JMP	outstr			;And go output it
.PAGE
;Here for register operand (16 and 32 bit modes)

d1opreg:MOVZBL	EBX, rgopsz		;Get way we should display this
	JMPIL	opregdsp[EBX*2]		;And go do it

opregdsp:
	.LONG	dspreg		;SZ_OPR = 0 - Display as size of operand
	.LONG	dspreg8		;SZ_8   = 2 - Display as 8 bit register
	.LONG	dspreg16	;SZ_16  = 4 - Display as 16 bit register
	.LONG	dspreg32	;SZ_32  = 6 - Display as 32 bit register

;Subroutine to display opeand reigster (8, 16, or 32 bit)
;	c(AL) = Register bits

dspreg:	TESTB	value, #1		;Is this a byte register?
	JE	dspreg8		;Yes
dspregwl:
	TESTB	oprsz16, #1		;16 bit operand?
	JNE	dspreg16		;Yes
dspreg32:
	ANDL	EAX, #7			;Only 3 bits
	LEAL	EBX, r16bit[EAX*2]
	MOVB	AL, #'E'		;No - 32 bit - start with E
	CALL	outchr#
	JMP	8$

;Here if have 8 bit register

dspreg8:ANDL	EAX, #7			;Only 3 bits
	LEAL	EBX, r8bit[EAX*2]
	JMP	8$

;Here if have 16 bit register

dspreg16:
	ANDL	EAX, #7
	LEAL	EBX, r16bit[EAX*2]
	JMP	8$

;Subroutine to display segment register operand
;	c(AL) = Register bits
;	CALL	dspseg

dspseg:	ANDL	EAX, #7
	LEAL	EBX, rsegmt[EAX*2]
8$:	MOVB	AL, [EBX]		;Get first character
	CALL	outchr#			;Output it
	MOVB	AL, 1[EBX]		;Get second character
	JMP	outchr#			;Output it and return
.PAGE
;Here for operand with 32 bit displacement value (32 bit mode)
;  This is displayed as disp[R1], disp[R1+R2], disp[R2*n], or disp[R1+R2*n]

d1op32d32:
	CALL	dsegspc			;Display segment specification
	ADDB	opnsiz#, #4		;Adjust item size
	MOVL	EBX, opofset		;Get 32 bit offset
	CALL	getmlong#
	JC	hvaerr
	ADDL	opofset, #4
	MOVL	EDI, EBX
	SUBL	EDI, opxaddr#
	MOVL	value#[EDI], EAX
	CALL	outvalna#		;Display value of long

;Here for operand with no displacement value (32 bit mode)
;  This is displayed as [R1], [R1+R2], [R2*n], or [R1+R2*n]

d1op0d32:
	CALL	dsegspc			;Display segment specification
	MOVZBL	EBX, value#+1		;Get the r/m bits
	ANDB	BL, #7
	CMPB	BL, #4			;Is the sib byte present?
	JE	havesib			;Yes
	LEAL	EBX, d1indx32[EBX*8]	;No - get address of string
	JMP	outstr#			;And go output it

;Here if have an sib byte

havesib:MOVB	AL, #'['		;Start out with left bracket
	CALL	outchr#
	MOVW	AX, value#+1		;Get rm and sib bytes
	ANDW	AX, #07C0h		;Have base register?
	CMPW	AX, #0500h
	JE	6$			;No
	MOVB	AL, AH			;Yes - display it
	CALL	dspreg32
	MOVB	AL, value#+2		;Do we have an index register?
	ANDB	AL, #38h
	CMPB	AL, #20h
	JE	10$			;No
	MOVB	AL, #'+'		;Yes - output plus
	CALL	outchr
6$:	MOVB	AL, value#+2		;Get index value
	SHRB	AL, #3
	ANDB	AL, #7
	CMPB	AL, #4			;Do we have one?
	JE	10$			;No
	CALL	dspreg32		;Yes - display it
10$:	MOVZBL	EAX, value#+2		;Get scale factor value times 4
	SHRB	AL, #4
	ANDB	AL, #0Ch
	LEAL	EBX, scltbl[EAX]
	JMP	outstr#
.PAGE
;Table which gives 16 bit index register string as function of the r/m bits

d1indx16:
	.ASCIZ	"[BX+SI]"	;000
	.ASCIZ	"[BX+DI]"	;001
	.ASCIZ	"[BP+SI]"	;010
	.ASCIZ	"[BP+DI]"	;011
	.ASCIZ	"[SI]"{0,0,0}	;100
	.ASCIZ	"[DI]"{0,0,0}	;101
	.ASCIZ	"[BP]"{0,0,0}	;110
	.ASCIZ	"[BX]"{0,0,0}	;111

;Table which gives 32 bit index register string as function of the r/m bits

d1indx32:
	.ASCIZ	"[EAX]"{0,0}	;000
	.ASCIZ	"[ECX]"{0,0}	;001
	.ASCIZ	"[EDX]"{0,0}	;010
	.ASCIZ	"[EBX]"{0,0}	;011
	.ASCIZ	"[???]"{0,0}	;100
	.ASCIZ	"[EBP]"{0,0}	;101
	.ASCIZ	"[ESI]"{0,0}	;110
	.ASCIZ	"[EDI]"{0,0}	;111

;Table which gives 32 bit index register scale value as function of the
;  index field value

scltbl:	.ASCIZ	"]"{0,0}	;00
	.ASCIZ	"*2]"		;01
	.ASCIZ	"*4]"		;10
	.ASCIZ	"*8]"		;11

;Table which gives register names as function of the reg bits in the mode word

r16bit:	.ASCII	"AX"		;000 - 16 bit registers
	.ASCII	"CX"		;001
	.ASCII	"DX"		;010
	.ASCII	"BX"		;011
	.ASCII	"SP"		;100
	.ASCII	"BP"		;101
	.ASCII	"SI"		;110
	.ASCII	"DI"		;111

r8bit:	.ASCII	"AL"		;000 - 8 bit registers
	.ASCII	"CL"		;001
	.ASCII	"DL"		;010
	.ASCII	"BL"		;011
	.ASCII	"AH"		;100
	.ASCII	"CH"		;101
	.ASCII	"DH"		;110
	.ASCII	"BH"		;111

rsegmt:	.ASCII	"ES"		;000 - Segment registers
	.ASCII	"CS"		;001
	.ASCII	"SS"		;010
	.ASCII	"DS"		;011
	.ASCII	"FS"		;100
	.ASCII	"GS"		;101
	.BYTE	0, 0		;110
	.BYTE	0, 0		;111
.PAGE
;Here for instruction with single general register operand

dregopr::
	MOVB	AL, #1			;This is a 1 byte instruction
	CALL	opsout			;Display opcode
dregop2:MOVB	AL, value#		;Get register bits from opcode byte
	JMP	dspregwl		;Go display register

;Here for MOV instruction with segment register operand

dmemxseg::
	XORB	value#, #1		;Make the w bit look right
	TESTB	value#, #2		;Going to segment register?
	JE	dmemxs2			;No
	MOVB	segchgd#, #1		;Yes - remember that
dmemxs2:MOVL	EAX, #dspseg		;Get address of routine to display
					;  segment register
	JMP	dtwoop2			;Call common code

;Here for MOV instruction with control register (CRn) operand

dmovcr::PUSHL	#'C'
	JMP	dmovxr

;Here for MOV instruction with control register (DRn) operand

dmovdr::PUSHL	#'D'
	JMP	dmovxr

;Here for MOV instruction with control register (TRn) operand

dmovtr::PUSHL	#'T'
dmovxr:	MOVB	AL, #3			;This is a 3 byte instruction
	CALL	opsout			;Output opcode
	TESTB	value+1, #2		;To control register?
	JNE	10$			;Yes
	MOVB	AL, value+2		;No - display general register
	CALL	dspreg32
	CALL	outcma#
	POPL	EAX			;Get first letter for control register
dspcrg:	CALL	outchr#			;  name
	MOVB	AL, #'R'		;Display control register name
	CALL	outchr#
	MOVB	AL, value+2
	SHRB	AL, #3
	ANDB	AL, #7
	ADDB	AL, #'0'
	JMP	outchr#

;Here if moving to control register

10$:	POPL	EAX			;Get first letter
	CALL	dspcrg			;Display control register
	CALL	outcma#			;Followed by comma
	MOVB	AL, value+2		;Followed by general register
	JMP	dspreg32
.PAGE
;Here for instruction with 16 bit memory destination and 16 bit memory source

dtwoopm16::
	MOVB	value, #1		;Fix up the d and w bits
	MOVB	oprsz16, #1		;Indicate 16 bit operands
	JMP	dtwoopr			;Continue with common code

;Here for instruction with two 16 or 32 bit operands with register destination

dtwoopx::
	ORB	value, #3		;Fix up the d and w bits

;Here for instruction with two opeands

dtwoopr::
	MOVL	EAX, #dspreg		;Get address of routine to display
dtwoop2:PUSHL	EAX			;  register
	MOVB	AL, #2			;Assume size is 2
	CALL	opsout
	CALL	getoo1			;Get mode byte
	JC	hvaerr
	MOVL	EAX, opxaddr		;Store address of possible offset
	ADDL	EAX, #2
	MOVL	opofset, EAX
	TESTB	value, #2		;Which way is this going?
	JNE	dtwo2rg			;To register
	CALL	doprnd			;To memory - display memory operand
	JC	hvaerr
	CALL	outcma			;Followed by a comma
	POPL	EDI			;Get address of register display routine
dtwoo2:	MOVB	AL, value+1		;Get reg bits
	SHRB	AL, #3
	JMPIL	EDI			;Followed by register operand

;Here if register is destination

dtwo2rg:POPL	EDI			;Get address of register display routine
	CALL	dtwoo2			;Display register operand
	JC	hvaerr
	CALL	outcma			;Followed by a comma
	JMP	doprnd			;Followed by memory operand
.PAGE
;Here for one operand floating point instructions whose operand is a floating
;  point register.  Note that there is also a no register form for some of
;  these, but that's handled by a separate table entry

doneflt::
	CALL	dtwobyt			;Display opcode
	MOVB	AL, value+1		;Get register number
	ANDL	EAX, #0x07
	JMP	6$			;Continue

;Here for two operand floating point instructions whose operands are floating
;  point registers.  These may be displayed with 1 or 2 operands as follows:
;	Fxxx  STn, ST0  ==>  Fxxx  STn
;	Fxxx  ST0, STn  ==>  Fxxx  ST0, STn
;  Note that there is also a no register form for some of these, but that's
;  handled by a separate table entry

dtwoflt::
	CALL	dtwobyt			;Display opcode
	MOVB	AL, value+1		;Get register number
	ANDL	EAX, #0x07
	TESTB	value+0, #0x04
	JNE	2$
	XCHGB	AL, AH
2$:	CMPB	AH, #0
	JE	6$
	PUSHL	EAX
	CALL	outfprg
	CALL	outcma
	POPL	EAX
	MOVB	AL, AH
6$:	CALL	outfprg
	JMP	outtab#

outfprg:PUSHL	EAX
	MOVB	AL, #'S'
	CALL	outchr
	MOVB	AL, #'T'
	CALL	outchr
	POPL	EAX
	ADDB	AL, #'0'
	JMP	outchr
.PAGE
;Here for the IMUL instruction

dimul::	MOVB	AL, #3			;This is basically a 3 byte instruction
	CALL	opsout
	MOVL	EAX, opxaddr
	ADDL	EAX, #2
	MOVL	opofset, EAX
	CALL	getoo1			;Get mode byte
	JC	hvaerr
	MOVB	CH, AL
	MOVB	AH, AL
	MOVB	CL, #3
	SHRB	AL, CL
	ANDB	AH, #0xC0		;See if first two operands are the
	CMPB	AH, #0xC0		;  same
	JNE	4$			;No
	XORB	CH, AL
	ANDB	CH, #7
	JE	di2m03			;Yes
4$:	CALL	dspreg			;No - display register
	JC	hvaerr
	CALL	outcma			;Followed by a comma
	JMP	di2m03			;Continue with common stuff
.PAGE
;Here for immediate operand to memory without size bit

dim2mem::ANDB	value, #1		;Only care about w bit here

;Here for immediate operand to memory with size bit

dims2mem::
	MOVB	AL, #3			;This is at least a 3 byte instruction
	CALL	opsout
	MOVL	EAX, opxaddr
	INCL	EAX
	INCL	EAX
	MOVL	opofset, EAX
	CALL	getoo1			;Get mode byte
	JC	hvaerr
di2m03:	CALL	doprnd			;Display destination operand
	JC	hvaerr
	CALL	outcma			;Followed by a comma
	MOVB	AL, #'#'		;Followed by #
	CALL	outchr
	MOVL	EBX, opofset
	TESTB	value, #1		;8 bit instruction?
	JNE	di2m06			;No
	CALL	getmbyte#		;Yes - get 8 bit immediate value
	JC	hvaerr
	JMP	outbyte#

;Here if word or long instruction

di2m06:	TESTB	value, #2		;Have 8 bit value?
	JE	6$			;No
	CALL	getmbyte#		;Yes - get it
	JC	hvaerr
	CALL	outbyte#		;Display it followed by .B
	MOVL	EBX, #dotbstr
	JMP	outstr#

;Here if have full length immediate value

6$:	TESTB	oprsz16, #1		;16 bit instruction?
	JE	8$			;No - 32 bit
	CALL	getmword#		;Yes - get 16 bit immediate value
	JC	hvaerr
	INCB	opnsiz#			;Bump length of instruction
	JMP	outword#

8$:	CALL	getmlong#		;Get 32 bit immediate value
	JC	hvaerr
	ADDB	opnsiz, #3
	JMP	outval#
.PAGE
;Here for immediate operand to general register

dim2reg::
	MOVB	AL, #2			;This is a 2 or 3 byte instruction
	CALL	opsout
	MOVB	AL, value		;Get register bits
	RORB	value, #3		;Get the w bit in the normal place
	CALL	dspreg			;Display register
di2r02:	CALL	outcma
	MOVB	AL, #'#'
	CALL	outchr#
	MOVL	EBX, opxaddr#
	INCL	EBX
	TESTB	value#, #1		;Word operation?
	JNE	4$			;Yes
	CALL	getmbyte#		;No - get immediate byte
	JC	hvaerr
	JMP	outbyte#		;Display the byte

4$:	INCB	opnsiz#			;Fix up the size
	TESTB	oprsz16, #1		;16 bit operand?
	JE	6$			;No
	CALL	getmword#		;Yes - get immediate word
	JC	hvaerr
	JMP	outword#

6$:	ADDB	opnsiz, #2
	CALL	getmlong#
	JC	hvaerr
	JMP	outval#

;Here for immediate operand to AX or AL

dim2ax::MOVB	AL, #2			;This is a 2 or 3 byte instruction
	CALL	opsout			;Display opcode
	CALL	daxoal			;Display AX or AL
	JMP	di2r02			;Continue with common code
.PAGE
;Here for MOV instruction with AX or AL as one operand

dmemxax::
	MOVB	AL, #3			;This is at least a 3 byte instruction
	CALL	opsout
	TESTB	value, #2		;Which way?
	JNE	dax2mem			;To memory
	CALL	daxoal			;To register - display AX or AL
	CALL	outcma			;And a comma
dmxax02:MOVZBL	EBX, segpfx		;Save segment prefix value
	PUSHL	EBX
	CALL	dsegspc			;Display segment override if needed
	MOVL	EBX, opxaddr#		;Get memory address
	INCL	EBX
	TESTB	adrsz16, #1		;16 bit operand?
	JNE	2$			;Yes
	ADDB	opnsiz, #2		;No - 32 bit
	CALL	getmlong#
	POPL	EBX
	JC	hvaerr
	PUSHL	#'L'
	JMP	4$

2$:	CALL	getmword
	POPL	EBX
	JC	hvaerr
	PUSHL	#'W'
4$:	MOVL	EDX, uregDS#
	TESTL	EBX, EBX		;Did we have a segment specified?
	JE	6$			;No
	MOVL	EDX, uregES#-2[EBX*2]	;Yes - get right segment prefix value
6$:	CALL	outaddr#		;Display address
	JMP	ddirj4

;Here if moving from register to memory

dax2mem:CALL	dmxax02			;Display memory adderss
	JC	hvaerr
	CALL	outcma			;Followed by a comma
					;Fall into daxoal to display AX or AL

;Subroutine to display AX or AL
;	CALL	daxoal

daxoal:	TESTB	oprsz16, #1		;16 bit operand?
	JNE	14$			;Yes
	TESTB	value, #1		;Byte operation?
	JE	14$			;Yes
	MOVB	AL, #'E'		;No - 32 bit - start out with E
	CALL	outchr
14$:	MOVB	AL, #'A'		;Always start out with A
	CALL	outchr
	MOVB	AL, #'X'		;Assume want X next
	TESTB	value, #1		;Really a word operation?
	JNE	di2ax02			;Yes
	MOVB	AL, #'L'		;No - display L next
di2ax02:JMP	outchr
.PAGE
;Here for PUSH instruction with immediate operand

dpushim::
	MOVB	AL, #2			;Assume 2 bytes
	CALL	opsout
	MOVB	AL, #'#'
	CALL	outchr
	MOVL	EBX, opxaddr		;Get address of operand
	INCL	EBX
	JMP	di2m06
.PAGE
;Here for one byte instructions with single segment register operand

dsegrgc::
	MOVB	segchgd#, #1		;Indicate segment register changed
dsegreg::
	CALL	donebyt			;Display opcode
	MOVB	AL, value		;Get register bits
	JMP	10$			;Continue

;Here for two byte instructions with single segment register operand

dsg3rgc::
	MOVB	segchgd#, #1		;Indicate segment register changed
dsg3reg::
	CALL	donebyt			;Display opcode
	INCB	opnsiz			;Fix up the size
	MOVB	AL, value+1		;Get register bits
10$:	SHRB	AL, #3
	JMP	dspseg			;Go display segment register
.PAGE
;Here for single bit shift and rotate instructions

dsrotone::
	CALL	doneopr			;Display first operand
	JC	hvaerr
	MOVL	EBX, #cl1str		;Followed by ,#1
	JMP	outstr

;Here for variable shift and rotate instructions

dsrotcl::
	CALL	doneopr			;Display first operand
	JC	hvaerr
	MOVL	EBX, #cclstr		;Followed by ,CL
	JMP	outstr

;Here for immediate shift and rotate instructions

dsrotim::
	CALL	doneopr			;Display first operand
	JC	hvaerr
	CALL	outcma
	INCB	opnsiz
	MOVB	AL, #'#'
	CALL	outchr
	MOVL	EBX, opofset
	CALL	getmbyte		;Get 8 bit immediate value
	JC	hvaerr
	JMP	outby0#			;And display the byte value
.PAGE
;Here for XCHG instruction when one operand is AX or AL

dxchgax::
	CALL	donebyt			;Display opcode
	JC	hvaerr
	MOVL	EBX, #axcstr		;Followed by AX,
	CALL	outstr
	JMP	dregop2			;Followed by register operand

;Here for ENTER instruction

dentrins::
	MOVB	AL, #4
	CALL	opsout			;Display opcode
	MOVL	EBX, opxaddr		;Get first operand value
	INCL	EBX
	CALL	getmword#
	JC	hvaerr
	CALL	outwordna#		;Display it
	CALL	outcma			;Followed by a comma
	MOVL	EBX, opxaddr		;Get second operand value
	ADDL	EBX, #3
	CALL	getmbyte#
	JC	hvaerr
	JMP	outby0			;Display it
.PAGE
;Here for the conditional looping instructions

dloop::	MOVB	AL, #2
	CALL	opsout			;Display opcode
	TESTB	adrsz16, #1		;16 bit operation?
	JNE	2$			;Yes
	MOVB	AL, #'E'		;No
	CALL	outchr
2$:	MOVL	EBX, #cxcstr		;Display rest of register name
	CALL	outstr
	JMP	4$

;Here for conditional and short jump instructions

dbranch::
	MOVB	AL, #2
	CALL	opsout			;Display opcode
4$:	MOVL	EBX, opxaddr		;Get offset value
	INCL	EBX
	CALL	getmbyte
	JC	hvaerr
	CBW
	CWL
	ADDL	EAX, #2
	MOVB	CL, #'S'
	JMP	ddirj2

;Here for long conditional jump instructions

dlngbr::MOVB	AL, #4			;This is a 4 (or 6) byte instruction
	CALL	opsout			;Display opcode
	MOVL	EBX, opxaddr		;Get offset value
	INCL	EBX
	INCL	EBX
	TESTB	oprsz16, #1
	JE	8$
	CALL	getmword
	JC	hvaerr
	CWL
	ADDL	EAX, #4
	MOVB	CL, #'R'
	JMP	ddirj2

8$:	CALL	getmlong
	JC	hvaerr
	ADDL	EAX, #6
	ADDB	opnsiz, #2
	MOVB	CL, #'Q'
	JMP	ddirj2
.PAGE
;Here for direct (16 bit offset) near jump and call instructions

ddirjmpn::
	MOVB	AL, #3			;This is a 3 (or 5) byte instruction
	CALL	opsout
	MOVL	EBX, opxaddr		;Get address of diplacement value
	INCL	EBX
	TESTB	oprsz16, #1
	JE	4$
	CALL	getmword
	JC	hvaerr
	CWL
	ADDL	EAX, #3
	MOVB	CL, #'R'
	JMP	ddirj2

4$:	CALL	getmlong
	JC	hvaerr
	ADDL	EAX, #5
	ADDB	opnsiz, #2
	MOVB	CL, #'Q'
ddirj2:	PUSHL	ECX
	ADDL	EAX, opxaddr
	CALL	outaddr#		;Display address
ddirj4:	MOVB	AL, #'.'
	CALL	outchr
	POPL	EAX
	CALL	outchr
	CLC
	RET
.PAGE
;Here for direct far jump and call instructions

ddirjmpf::
	MOVB	AL, #5			;This is a 5 (or 7) byte instruction
	CALL	opsout
	MOVL	EBX, opxaddr		;Get address of memory offset
	INCL	EBX
	TESTB	oprsz16, #1
	JE	14$
	CALL	getmword
	JC	hvaerr
	CWL
	INCL	EBX
	INCL	EBX
	MOVB	CL, #'W'
	JMP	16$

14$:	CALL	getmlong
	JC	hvaerr
	ADDL	EBX, #4
	ADDB	opnsiz, #2
	MOVB	CL, #'L'
16$:	PUSHL	EAX
	CALL	getmword		;Get segment selector
	POPL	EDX
	JC	hvaerr

	JMP	hvaerr		;????????????????

	PUSHL	ECX
;;;;;	XORL	EAX, opnseg		;Make it the same type selector as
;;;;;	XORW	AX, opnseg		;  the address we are looking at
	XCHGL	EAX, EDX
	CALL	outaddr#
	JMP	ddirj4
.PAGE
;Here for return instruction with stack fixup

dretfix::
	MOVB	AL, #3			;This is a 3 byte instruction
	CALL	opsout
	MOVB	AL, #'#'
	CALL	outchr
	MOVL	EBX, opxaddr		;Get immediate value
	INCL	EBX
	CALL	getmword
	JC	hvaerr
	MOVW	value+1, AX
	CWD
	CALL	outwordna#		;Display the value	
	CLC
	RET

;Here for INT instruction

dintins::
	MOVB	AL, #2			;This is a 2 byte instruction
	CALL	opsout
	MOVL	EBX, opxaddr		;Get second byte
	INCL	EBX
	CALL	getmbyte
	JC	hvaerr
	CALL	outby0			;Display the value	
	CLC
	RET
.PAGE
;Here for IO instruction with fixed IO port

diofix::MOVB	AL, #2			;This is a 2 byte instruction
	CALL	opsout
	MOVL	EBX, opxaddr		;Get second byte
	INCL	EBX
	CALL	getmbyte
	JC	hvaerr
	CALL	outby0			;Display the value	
	CLC
	RET

;Here for IO instruction with variable IO port

diovar::CALL	donebyt			;Display opcode
	MOVL	EBX, #xdxstr		;Followed by [DX]
	CALL	outstr
	CLC
	RET
.PAGE
dlngimdb::
	MOVB	value, #3		;Make this look like both s and w are
	MOVW	AX, value+2		;  set
	MOVW	value+1, AX
	INCL	opxaddr
	MOVB	AL, #4			;This is a 4 byte instruction
	CALL	opsout
	MOVL	EAX, opxaddr
	ADDL	EAX, #2
	MOVL	opofset, EAX
	CALL	doprnd			;Display destination operand
	JC	hvaerr
	CALL	outcma			;Followed by a comma
	MOVB	AL, #'#'		;Followed by #
	CALL	outchr
	MOVL	EBX, opofset
	CALL	getmbyte		;Get 8 bit immediate value
	JC	hvaerr
	JMP	outbyte#
.PAGE
dmovxb::MOVB	rgopsz, #SZ_8
	JMP	2$

dmovxw::MOVB	rgopsz, #SZ_16
2$:	MOVB	AL, value+1
	MOVB	value, AL
	INCL	opxaddr
	INCB	opnsiz
	MOVL	EAX, #dspregwl
	JMP	dtwoop2			;Display instruction

;Here for long format instructions with one byte operand

dlng1bopr::
	MOVB	value, #0		;Clear "w bit"
	JMP	4$

;Here for long format instructions with one word operand

dlng1wopr::
	MOVB	oprsz16, #1		;Force operand size to 16 bits

;Here for long format instructions with one word or long operand

dlng1wlopr::
	MOVB	value, #1		;Set "w bit"
4$:	INCL	opxaddr
	INCB	opnsiz
	JMP	doneopr

dlngsdim::
	CALL	dlng2oprs		;Display all but last field
	INCB	opnsiz			;Include immediate byte in the size
	CALL	outcma			;Followed by a comma
	MOVB	AL, #'#'		;Followed by #
	CALL	outchr
	MOVL	EBX, opofset
	CALL	getmbyte#		;Get 8 bit immediate value
	JC	hvaerr
	JMP	outbyte#		;And display it

;Here for long format shift double with variable count

dlngsdcl::
	CALL	dlng2oprs		;Display all but last field
	MOVL	EBX, #cclstr		;Last field is always CL
	JMP	outstr

;Here for long format instructions with two operands and register source

dlng2oprs::
	MOVB	value, #1
	JMP	14$

;Here for long format instructions with two operands and register destination

dlng2oprd::
	MOVB	value, #3
	JMP	14$

;Here for long format instructions with two operands

dlng2opr::
	MOVB	AL, value+1
	MOVB	value, AL
14$:	INCL	opxaddr			;Adjust offset for rest of instruction
					;  bytes
	INCB	opnsiz
	JMP	dtwoopr			;Display instruction
.PAGE
;Here for the unconditional string instructions

dstring::
	CMPB	reppfx, #0		;Have repeat prefix?
	JE	6$			;No
	MOVB	AL, #'R'		;Yes - prefix it with an R
	CALL	outchr
	JMP	6$

;Here for the conditional string instructions

dstrcon::
	CMPB	reppfx, #0		;Have repeat prefix?
	JE	6$			;No
	MOVB	AL, #'R'		;Yes - start out with R
	CALL	outchr
	MOVB	AL, #'N'		;Assume test is for not equal
	TESTB	reppfx, #1		;Right?
	JE	4$			;Yes
	MOVB	AL, #'E'		;No - its for equal
4$:	CALL	outchr
6$:	CALL	donebyt			;Output opcode
	MOVB	AL, value		;Do we need a destination operand?
	ANDB	AL, #0xFE
	CMPB	AL, #0xAC
	JE	10$
	CMPB	AL, #0x6E
	JE	10$
	MOVL	EBX, #sdststr		;Yes - assume 16 bit address size
	TESTB	adrsz16, #1		;Right?
	JNE	8$			;Yes
	ADDL	EBX, #sedststr-sdststr	;No - use right string
8$:	CALL	outstr
	TESTB	value, #0x08		;Need source too?
	JNE	20$			;No - all done here
	CALL	outcma			;Yes - need comma next
10$:	CALL	dsegspc			;Output segment specification if needed
	MOVL	EBX, #ssrcstr		;Assume 16 bit address size
	TESTB	adrsz16, #1		;Right?
	JNE	12$			;Yes
	ADDL	EBX, #sesrcstr-ssrcstr	;No - use right string
12$:	JMP	outstr

20$:	RET
.PAGE
;Here for the FLTJMP "instruction" - this is not really an instruction but is
;  a sequence used by XOS to indicate an address to transfer to if the
;  preceeding instruction causes a memory exception - it is the sequence:
;	JMP	$+7.S
;	NOP
;	.LONG	address

dfltjmp::
	MOVB	AL, #7			;This is a 7 byte instruction
	CALL	opsout
	MOVL	EBX, opxaddr#		;Get address of memory offset
	ADDL	EBX, #3
	CALL	getmlong		;Get address
	JC	hvaerr
	CALL	outaddr#
	CLC
	RET
.PAGE
;Here for the CRASH "instruction" - this is really an INT 1F followed inlie by
;  four ASCII characters!

dcrash::MOVB	AL, #6			;This is a 6 byte instruction
	CALL	opsout
	MOVL	EBX, opxaddr		;Get address of ASCII characters
	INCL	EBX
	INCL	EBX
	CALL	getmlong		;Get characters
	JC	hvaerr			;If error
	MOVL	ECX, #4			;Output 4 characters
4$:	PUSHL	EAX
	CALL	outchr			;Output character
	POPL	EAX
	SHRL	EAX, #8			;Get next character
	LOOP	ECX, 4$			;Continue if more to output
	CLC				;Finished
	RET
.PAGE
;Here for the repeat prefix

dreppfx::
	MOVB	AL, value		;Store prefix value
	MOVB	reppfx, AL
	JMP	outopn			;Continue

;Here for the operand size prefix

doszpfx::
	XORB	oprsz16, #1		;Change the operand size indicator
	JMP	outopn

;Here for the address size prefix

daszpfx::
	XORB	adrsz16, #1		;Change the operand size indicator
outopn:	INCL	opxaddr			;Bump address
	MOVL	EBX, opxaddr		;Get next byte
	CALL	getmbyte
	JC	hvaerr
	MOVB	value, AL		;Save first byte
	INCB	opnsiz			;Adjust size
	JMP	outop2			;Display instruction

;Segment override prefix for FS

dsfspfx::
	MOVB	AL, #5
	JMP	10$

;Segment override prefix for GS

dsgspfx::
	MOVB	AL, #6
	JMP	10$

;Here for the segment override prefix for ES, CS, SS, or DS

dsegpfx::
	MOVB	AL, value		;Get prefix byte
	SHRB	AL, #3			;Get segment bits in right place
	ANDB	AL, #3
	INCB	AL
10$:	MOVB	segpfx, AL		;Remember the prefix
	JMP	outopn			;Display instruction prefix applies to
.PAGE
;Subroutine to display segment specificaiton
;	CALL	dsegspc

dsegspc:CMPB	segpfx, #0		;Do we need a segment specification?
	JE	ret410			;No
	MOVZBL	EBX, segpfx		;Yes - get segment
	MOVB	segpfx, #0
	LEAL	EBX, segstbl-4[EBX*4]	;Point to string
	JMP	outstr			;Output it and return

;Segment specification table

segstbl:.ASCIZ	"ES:"
	.ASCIZ	"CS:"
	.ASCIZ	"SS:"
	.ASCIZ	"DS:"
	.ASCIZ	"FS:"
	.ASCIZ	"GS:"
.PAGE
;Subroutine to get second byte of instruction
;	CALL	getoo1

getoo1:	MOVL	EBX, opxaddr		;Get mode byte
	INCL	EBX
	CALL	getmbyte
	MOVB	value+1, AL
ret410:	RET
.PAGE
;Subroutine to display opcode string
;	c{EBX} = Offset of opcode string (up to 6 characters, trailing space
;		   filled)
;	CALL	oopstr

oopstr:	MOVL	ECX,#7			;Output up to 7 characters
2$:	MOVB	AL, [EBX]		;Get character
	CMPB	AL, #' '		;Space?
	JE	ret410			;Yes - done
	CALL	outchr			;No - output character
	INCL	EBX			;Bump pointer
	LOOP	ECX, 2$			;Loop back if more possible
	RET
.PAGE
bdomsg:	 .ASCIZ	{ERR}"?? "{TXT}
xdxstr:	 .ASCIZ	"[DX]"
cl1str:	 .ASCIZ	",#1"
cclstr:	 .ASCIZ	",CL"
axcstr:	 .ASCIZ	"AX,"
cxcstr:	 .ASCIZ	"CX,"
dotbstr: .ASCIZ	".B"
sdststr: .ASCIZ	"[DI]"
sedststr:.ASCIZ	"[EDI]"
ssrcstr: .ASCIZ	"[SI]"
sesrcstr:.ASCIZ	"[ESI]"

	DATA

	.MOD	4
opofset:.LONG	0
oofetch:.WORD	0
segpfx:	.BYTE	0		;Segment prefix flag
reppfx:	.BYTE	0		;Repeat prefix value
rgopsz:	.BYTE	0		;Size of register used as memory operand
adrsz16:.BYTE	0		;1 if 16 bit addresses, 0 if 32 bit
oprsz16:.BYTE	0		;1 if 16 bit operands, 0 if 32 bit

	CODE
.PAGE
