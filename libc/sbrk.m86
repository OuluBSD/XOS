	.TITLE	brk - Low level memory allocation routines for C programs
	.SBTTL	Run-time library for XC for XOS

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

	.INCLUD	XOSINC:\XMAC\XOS.PAR
	.INCLUD XOSINC:\XMAC\XOSERR.PAR
	.INCLUD	XOSINC:\XMAC\STDIO.PAR

	.STDSEGS

;These functions allocate a block of memory at the top of memory by expanding
;  the programs memory allocation to provide more room.  This space does NOT
;  become part of malloc's pool of allocatable memory.  It cannot be deallocated
;  by calling free.  It does not, however, interfere in any may with malloc's
;  ability to manage memory blocks either above or below the space allocated.

mab_membase=!0t
mab_mempnt =!4t
mab_memtop =!8t

	.PSECT	_TEXT_p

;Function to set up a memory block
;	int makex(
;	    MAB *mb,
;	    long offset);
;  Value returned is 0 if normal or -1 if error (errno is set)

	.ENTRY	makex
makex:	MOVL	EDX, 4[ESP]		;Get offset of the MAB
	MOVL	EAX, 8[ESP]		;Get base of the msect
	MOVL	mab_membase[EDX], EAX
	MOVL	mab_mempnt[EDX], EAX
	CLRL	EAX
	MOVL	mab_memtop[EDX], EAX
	RET

;Function to discard a memory block
;	int junkx(
;	    MAB *mb);
;  Value returned is 0 if normal or -1 if error (errno is set)

	.ENTRY	junkx
junkx:	MOVL	EDX, 4[ESP]
	CMPL	mab_membase[EDX], #0
	JE	2$
	PUSHL	mab_membase[EDX]
	PUSHL	#0
	PUSHL	#0
	CALL	svcMemChange##
	TESTL	EAX, EAX
	JS	fail
2$:	CLRL	EAX
	MOVL	EDX, 4[ESP]
	MOVL	mab_membase[EDX], EAX
	MOVL	mab_memtop[EDX], EAX
	MOVL	mab_mempnt[EDX], EAX
	RET
.PAGE
;Function to permanently allocate a block of memory in any msect given size of
;  the block
;	void *sbrkx(
;	    long size,		// Size of block to allocate (in bytes)
;	    MAB *mem);		// Memory allocation block
;  Value returned is -1 if error or address of memory obtained if normal

sbrkx_size=!8
sbrkx_mem =!12t

	.ENTRY	sbrkx
sbrkx:	PUSHL	EBX
	MOVL	EBX, sbrkx_mem[ESP]	;Get offset of the MAB
	JMP	4$

;Function to permanently allocate a block of memory in any msect given size of
;  the block without forcing long alignment
;	void *sbrkxx(
;	    long  size,		// Size of block to allocate (in bytes)
;	    MAB  *mem(;		// Memory allocation block
;  Value returned is -1 if error or address of memory obtained if normal

	.ENTRY	sbrkxx
sbrkxx:	PUSHL	EBX
	MOVL	EBX, sbrkx_mem[ESP]	;Get offset of the MAB
	MOVL	EDX, sbrkx_size[ESP]	;Get size requested
	TESTL	EDX, EDX
	JS	toobig
	MOVL	ECX, mab_mempnt[EBX]	;Get value to return if OK
	ADDL	EDX, ECX		;Get new top offset
	JMP	brk4			;Continue

;Function to permanently allocate a block of memory give size of the block
;	void *sbrk(size);
;	     long size);	// Size of block to allocate (in bytes)
;  Value returned is -1 if error or address of memory obtained if normal

sbrk_size=!8

	.ENTRY	sbrk
sbrk:	PUSHL	EBX
	MOVL	EBX, #_clib_membase#
4$:	MOVL	EDX, sbrk_size[ESP]	;Get size requested
	TESTL	EDX, EDX
	JS	toobig
	MOVL	ECX, mab_mempnt[EBX]	;Get value to return if OK
	ADDL	EDX, ECX		;Get new top offset
	JMP	brk2			;Continue
.PAGE
	.SBTTL	brkx - Function to permanently allocate memory given new high offset

;Function to permanently allocate a block of memory give the new high offset
;	void *brkx(
;	    void *top,		// Requested new top of memory offset
;	    MAB  *mem);
;  Value returned is -1 if error or address of memory obtained if normal

brkx_top=!8
brkx_mem=!12t

	.ENTRY	brkx
brkx:	PUSHL	EBX
	MOVL	EBX, brkx_mem[ESP]
	JMP	4$

;Function to permanently allocate a block of memory given the new high offset
;	void *brk(
;	    void *top);		// Requested new top of memory offset
;  Value returned is -1 if error or address of memory obtained if normal

brk_top=!8

	.ENTRY	brk
brk:	PUSHL	EBX
	MOVL	EBX, #_clib_membase#
4$:	CLRL	ECX			;Get value for good return
	MOVL	EDX, brk_top[ESP]	;Get new top offset wanted
brk2:	ADDL	EDX, #3			;Make sure even number of longs
	ANDL	EDX, #0xFFFFFFFC
brk4:	CMPL	EDX, mab_memtop[EBX]	;Need more memory now?
	JBE	6$			;No
	MOVL	EAX, EDX
	SUBL	EAX, mab_membase[EBX]	;Yes - get new size wanted
	PUSHL	mab_membase[EBX]
	PUSHL	#3
	PUSHL	EAX
	CALL	svcMemChange#
	TESTL	EAX, EAX		;Error?
	JS	fail			;Yes
	ADDL	EAX, mab_membase[EBX]	;Get new top pointer
	MOVL	mab_memtop[EBX], EAX
6$:	MOVL	mab_mempnt[EBX], EDX	;Store new break pointer
	MOVL	EAX, ECX		;Get value to return
	POPL	EBX
	RET

;Here if error allocating memory

toobig:	MOVL	EAX, #ER_NEMA
fail:	NEGL	EAX			;Negate it for errno
	MOVL	errno#, EAX		;Store error code
	MOVL	EAX, #-1		;Return -1
	POPL	EBX
	RET

	.END
