	.TITLE	memmove - ANSI C function to copy memory regions
	.SBTTL	STDC run-time library for XOS

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----
	.INCLUD	XOSINC:\xmac\xos.par
	.INCLUD	XOSINC:\xmac\stdio.par

	.STDSEGS

.MACRO	MOVSEG	dst, src, reg
.IF	NB	{reg}
	MOVL	reg, src
	MOVL	dst, reg
.IFF
	PUSHL	src
	POPL	dst
.ENDC
.ENDM

	.PSECT	_TEXT_p

;memmove - ANSI C function to copy memory regions
;	void memmove(
;	    char *dst,
;	    char *src,
;	    int   cnt);

arg_dst=!16t
arg_src=!20t
arg_cnt=!24t

	.ENTRY	memmove
memmove:PUSHL	EBX
	PUSHL	EDI
	PUSHL	ESI
	PUSHL	DS
	POPL	ES
	MOVL	EDI, arg_dst[ESP]	;Get offset of destination string
	MOVL	ESI, arg_src[ESP]	;Get offset of source string
	MOVL	EBX, arg_cnt[ESP]	;Get no. of bytes to copy
	MOVL	EAX, EDI		;Return offset of destination string
        TESTL	EBX, EBX                ;Zero?
        JE      30$			;Yes, quit now
	MOVL	ECX, EBX
        CMPL    EDI, ESI                ;Do we need to copy backwards?
        JBE     10$			;No
	LEAL	EDX, [ESI+EBX]
	CMPL	EDI, EDX
	JAE	10$
        STD				;Yes
        LEAL    ESI, -1[ESI+EBX]	;Point to end of source
        LEAL    EDI, -1[EDI+EBX]	;Point to end of destination
	CMPL	EBX, #8
	JBE	24$
	LEAL	ECX, -3[EDI]
	ANDL	ECX, #03
	JE	4$
	SUBL	EBX, ECX
	RMOVSB	[EDI], [ESI]
4$:	SUBL	ESI, #3
	SUBL	EDI, #3
	MOVL	ECX, EBX
	SHRL	ECX, #2
	RMOVSL	[EDI], [ESI]
	MOVL	ECX, EBX
	ANDL	ECX, #03
	JE	30$
	ADDL	ESI, #3
	ADDL	EDI, #3
        JMP     24$			;Join common code

;Here if we want to copy in the forward direction

10$:	CLD				;Make sure MOVS copies forward
	CMPL	ECX, #8
	JBE	24$
        MOVL    ECX, EDI		;Copy destination address
        NEGL    ECX			;Negate so ANDL works correctly
20$:    ANDL    ECX, #3			;Calculate no. of bytes needed
        SUBL    EBX, ECX                ;   for longword alignment
	RMOVSB	[EDI], [ESI]		;Copy 0-3 bytes
        MOVL    ECX, EBX                ;Get the no. of remaining bytes
        SHRL    ECX, #2                 ;Calculate longword count
        RMOVSL  [EDI], [ESI]            ;Move data by longwords
        MOVL    ECX, EBX                ;Calculate the number
        ANDL    ECX, #3			; of bytes left to output
24$:	RMOVSB	[EDI], [ESI]		;Copy 0-3 bytes
30$:	CLD				;Leave D clear to keep Watcom happy!
	POPL	ESI
	POPL	EDI
	POPL	EBX
	RET

	.END
