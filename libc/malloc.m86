	.TITLE	malloc - ANSI C memory allocation functions
	.SBTTL	STDC run-time library for XOS

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

;+
; Edit history:
;
;  Date    Who  Description
; -------  ---  -----------

	.INCLUD	XOSINC:\XMAC\XOS.PAR
	.INCLUD	XOSINC:\XMAC\STDIO.PAR

	.STDSEGS

;;;$$DEBUG=!1

; malloc uses a linked list of memory blocks, each of which has a 24 byte
; header. Each block begins on a long boundry.  The format of the header is
; as follows:
;
;    +-------------------------------+
;    |m m m m m m m m m m m m m m m m|  mb_magic Magic number
;    |m m m m m m m m m m m m m m m m|
;    +-------------------------------+
;    |b b b b b b b b b b b b b b b b|  mb_mprev Backward memory pointer
;    |b b b b b b b b b b b b b b b b|
;    +-------------------------------+
;    |f f f f f f f f f f f f f f f f|  mb_mnext Forward memory pointer
;    |f f f f f f f f f f f f f f f f|
;    +-------------------------------+
;    |b b b b b b b b b b b b b b b b|  mb_pfree Backward free list pointer
;    |b b b b b b b b b b b b b b b b|
;    +-------------------------------+
;    |f f f f f f f f f f f f f f f f|  mb_nfree Forward free list pointer
;    |f f f f f f f f f f f f f f f f|
;    +-------------------------------+
;    |s s s s s s s s s s s s s s s s|  mb_size  Size of block
;    |s s s s s s s s s s s s s s s s|
;    +-------------------------------+
;
;  All pointers are offsets which point to the first allocated byte in the
;  block, which immediately follows the header.  The size is the number of
;  bytes in the block, rounded up to a multiple of 4.  Note that the memory
;  list (which links all blocks managed by malloc) is maintained in memory
;  offset order.  The free list, which links only free blocks, is not kept
;  in any order.  Blocks are always freed by being linked to the end of the
;  list.

mb_magic=!-24t
mb_mprev=!-20t
mb_mnext=!-16t
mb_pfree=!-12t
mb_nfree=!-8t
mb_size =!-4t

MB_MAGIC=!52525252h  	;Value for mb_magic
HDRSIZE =!24t		;Size of the memory block header

	.PSECT	_DATA_p

memerr:
	.ASCIZ	"? Memory allocation error"{CR,LF}

	.PSECT	_BSS_p

_malloc_mhead::				;Head of memory list
	.BLKL  1		
_malloc_mtail::				;Tail of memory list
	.BLKL  1
_malloc_fhead::				;Head of free list
	.BLKL  1
_malloc_ftail::				;Tail of free list
	.BLKL  1
_malloc_amount::			;No. of bytes currently allocated
	.BLKL  1
_malloc_crit::				;CRIT structure
	.LONG	'CRIT'
	.BLKL	crit_SIZE-4

	.PSECT	_TEXT_p
.PAGE
	.SBTTL	calloc - ANSI C function to allocate memory and initialize it

;ANSI C function to allocate memory and initialize it
;	void *calloc(
;	    long num,		// Number of items
;	    long size)		// Size of each item
;  Value returned is address of memory allocated or NULL if error (errno is
;    set on error)

argc_num =!4t
argc_size=!8t

	.ENTRY	calloc
calloc:	MOVL	EAX, argc_num[ESP]	;Get the no. of items
	MOVL	ECX, argc_size[ESP]	;Get the size of each item
	MULL	ECX			;Multiply to get total bytes
	JNO	10$			;No overflow, so continue
	CLRL	EAX			;Return a NULL pointer
	RET

;Non-ANSI C function to allocate memory and initialize it
;	void *cmalloc(
;	    long size);
;  Value returned is address of memory allocated or NULL if error (errno is
;    set on error)

argcm_size=!4

	.ENTRY	cmalloc
cmalloc:
	MOVL	EAX, argcm_size[ESP]

;Here if the total number of bytes is okay

10$:	PUSHL	EAX			;Save the total number of bytes
	CALL	malloc			;Allocate it
	POPL	ECX			;Restore passed parameter
	TESTL	EAX, EAX		;Did we get anything?
	JE	20$			;No, so quit

;Clear what was just allocated - we know it is long aligned and an even
;  number of longs in length (malloc rounds the size up)

	PUSHL	EDI
	MOVL	EDX, EAX
	MOVL	EDI, EAX
	MOVL	EAX, DS
	MOVL	ES, EAX
	SHRL	ECX, #2
	CLD
	CLRL	EAX
	RSTOSL	[EDI]
	POPL	EDI
	MOVL	EAX, EDX
20$:	RET				;Return pointer or NULL
.PAGE
	.SBTTL	malloc - ANSI C function to allocate memory

;XOS function to allocate permenate memory

pmalloc::				;For now, just fall into malloc!
	NOP

;ANSI C function to allocate memory
;	void *malloc(
;	    long size);		// Size of block to allocate
;  Value returned is address of block allocated if normal or NULL if error
;    (errno is set if error)

argm_size=!8

	.ENTRY	malloc
malloc:	PUSHL	EBX

	critBegin _malloc_crit

.IF DEF $$DEBUG
	CALL	memchk
.ENDC

	MOVL	ECX, argm_size[ESP]	;Get size requested
	TESTL	ECX, ECX		;Make sure not 0
	JE	44$
	ADDL	ECX, #3			;Round up to multiple of 4
	ANDL	ECX, #0xFFFFFFFC
	MOVL	EDX, _malloc_fhead	;Get head of our free list
	JMP	20$			;Start checking

;Here to run through all memory blocks until we find one big enough

10$:	MOVL	EDX, mb_nfree[EDX]	;Step to next block in free list
20$:	TESTL	EDX, EDX		;Anything more to check?
	JE	getmemory		;No - go allocate more

;Here with another block to check

	CMPL	mb_magic[EDX], #MB_MAGIC ;Is it a valid block?
	JE	22$
	CALL	badmemory		;No, so die horrible death
	HLT

22$:	CMPL	mb_size[EDX], ECX	;Is this block big enough?
	JB	10$			;No, keep checking

;Here with a block which is big enough to use

	CALL	removefree		;Remove block from free list
	CALL	splitmem		;Split the block
	JMP	30$			;Now exit

;Here if we cannot satisfy the memory request

nomemory:
	CLRL	EAX			;Return NULL pointer
	JMP	40$			;Now exit

;Here if something is wrong with the memory list

badmemory::
	MOVL	EAX, #memerr
	CALL    _assert#                ;Output this as assertion failure
	HLT

;Here if must allocate a new block to satisify this request

getmemory:
	PUSHL	ECX			;Save size we want
	ADDL	ECX, #HDRSIZE		;Add space for header
	MOVL	EDX, _clib_mempnt#	;Get value to return if OK
	ADDL	ECX, EDX		;Get new top offset
	CMPL	ECX, _clib_memtop#	;Need more memory now?
	JBE	26$			;No
	MOVL	EAX, ECX
	SUBL	EAX, _clib_membase#	;Yes - get new size wanted
	PUSHL	ECX
	PUSHL	EDX
	PUSHL	_clib_membase#
	PUSHL	#3
	PUSHL	EAX
	CALL	svcMemChange#
	POPL	EDX
	POPL	ECX
	TESTL	EAX, EAX		;Error?
	JS	42$			;Yes
	ADDL	EAX, _clib_membase#	;Get new top pointer
	MOVL	_clib_memtop#, EAX
26$:	MOVL	_clib_mempnt#, ECX	;Store new break pointer
	MOVL	EAX, EDX		;Get address in right register
	POPL	ECX			;Restore size
	LEAL	EDX, HDRSIZE[EAX]	;No - point to start of block
	CALL	initmem			;Initialize the memory
	CALL	addmem			;Add it to tail of memory list
30$:	MOVL	ECX, mb_size[EDX]	;Get the size of the new block
	ADDL	_malloc_amount, ECX	;Adjust current allocation
	MOVL	EAX, EDX		;Return pointer to block

.IF DEF $$DEBUG
	CALL	memchk
.ENDC
mend::	critEnd _malloc_crit

40$:	POPL	EBX
	RET

42$:	POPL	ECX
44$:	NEGL	EAX
	MOVL	errno#, EAX
	CLRL	EAX
	JMP	mend
.PAGE
	.SBTTL	realloc - ANSI C function to reallocate memory

;ANSI C function to reallocate memory
;	void *realloc(
;	    void *oldmem,
;	    long size)
;  Value returned is the new address of the memory block (it may be the same
;    or different from the old block)

arg_oldmem=!8
arg_size  =!12t

	.ENTRY	realloc
realloc:PUSHL	EBX
	MOVL	EDX, arg_oldmem[ESP]	;Get pointer to old block
	MOVL	ECX, arg_size[ESP]	;Get new size
	TESTL	EDX, EDX		;Does the user have a block already?
	JNE	10$			;Yes
	PUSHL	ECX			;No, we need to allocate a block
	CALL	malloc			;  by passing the new size to malloc
	POPL	ECX			;Discard the size
	RET				;Exit with EAX = new block or NULL

;Here to see if the user wants to free up an allocated block

10$:	TESTL	ECX, ECX		;Is the size zero?
	JNE	20$			;No
	PUSHL	EDX			;Yes, gotta free the memory
	CALL	free			;So free it up already
	POPL	EDX			;Discard the parameter
	POPL	EBX
	RET				;Return with EAX = NULL

;Here to see if the user wants to make the block smaller

20$:	CMPL	ECX, mb_size[EDX]	;Making block larger or smaller?
	JE	24$			;Neither, so just exit
	JA	30$			;Larger
	ADDL	ECX, #3			;Smaller - first round up to
	ANDL	ECX, #-4		; longword multiple
	CALL	splitmem		;Split the block if we can
24$:	MOVL	EAX, EDX		;Return pointer in right register
	POPL	EBX
	RET				;Finsihed

;Here if the user is trying to make the block larger

30$:	PUSHL	EDX			;Save the old block
	PUSHL	ECX			;Pass the new size
	CALL	malloc			;Now try to allocate it
	POPL	ECX			;Get the new size again
	POPL	EDX			;Get the old block back
	MOVL	ECX, mb_size[EDX]	;Get the amount we need to copy
	TESTL	EAX, EAX		;Did we get a new block?
	JE	40$			;No
	PUSHL	EAX			;Save address of the new block
	PUSHL	EDX			;Save address of the old block
	PUSHL	ECX			;Copy the block
	PUSHL	EDX
	PUSHL	EAX
	CALL	memcpy#
	ADDL	ESP, #12t
	CALL	free			;Free up the old block (the address
	POPL	EAX			;  was pushed above)
	POPL	EAX			;Get address of the new block
40$:	POPL	EBX
	RET				;Finished here
.PAGE
	.SBTTL	free - ANSI C function to deallocate memory

;ANSI C function to deallocate memory
;	void free(
;	    void *mem);		// Address of memory block to free

;NOTE:	Even though this function "officially" returns void, it really
;	returns with c{EAX} = 0 (mostly for realloc)

arg_mem=!8

	.ENTRY	free
free:	PUSHL	EBX

	critBegin _malloc_crit

.IF DEF $$DEBUG
	CALL	memchk
.ENDC

	MOVL	EDX, arg_mem[ESP]	;Get offset
	TESTL	EDX, EDX		;Null pointer?
	JE	30$			;Yes, just exit
	CMPL	mb_magic[EDX], #MB_MAGIC ;Valid memory block?
	JE	10$			;No!
	CALL	badmemory               ;We have bad memory, so die
	HLT

10$:	CMPL	mb_nfree[EDX], #-1	;Yes - is it in use?
	JE	20$			;Yes
	CALL	badmemory               ;We have bad memory, so die
	HLT

;Here if have a valid memory block which is allocated

20$:	MOVL	EAX, mb_size[EDX]	;Get size of the block
	SUBL	_malloc_amount, EAX	;Reduce total amount allocated
	CALL	freemem			;Give up the block
30$:
	critEnd _malloc_crit

	CLRL	EAX			;Ensure we return a NULL value just in
	POPL	EBX			;  case someone tries to use it!
	RET
.PAGE
	.SBTTL	addfree - Add block to tail of free list

;Subroutine to add a block to the tail of the free list
;	c{EDX} = Memory block to add
;	CALL 	addfree

addfree:MOVL	EAX, _malloc_ftail	;Link this block onto the end of
	MOVL	_malloc_ftail, EDX	;  the free list
	MOVL	mb_pfree[EDX], EAX	;Previous ptr points to old tail
	MOVL	mb_nfree[EDX], #0	;Next ptr points to NULL
	TESTL	EAX, EAX		;Was the free list empty?
	JE	4$			;Yes
	MOVL	mb_nfree[EAX], EDX	;No
	JMP     8$

; Here if free list is empty - add block to head

4$:	MOVL	_malloc_fhead, EDX      ;Free list head points to our block
8$:	RET
.PAGE
	.SBTTL	addmem - Add block to tail of memory list

;Subroutine to add a block to the tail of the memory list
;	c{EDX} = Memory block to add
;	CALL 	addmem

addmem:	MOVL	mb_mnext[EDX], #0	;Next pointer is NULL
	MOVL	EAX, _malloc_mtail	;Link into memory list
	MOVL	_malloc_mtail, EDX	;This becomes the new tail
	MOVL	mb_mprev[EDX], EAX	;Point our block to the old tail
	TESTL	EAX, EAX		;Anything in the memory list?
	JE	10$			;No
	MOVL	mb_mnext[EAX], EDX	;Yes, old tail must point to us
	JMP	12$			;Now exit

; Here if there is nothing in the memory list

10$:	MOVL	_malloc_mhead, EDX	;Update the head pointer
12$:	RET
.PAGE
	.SBTTL	combine - Combine two memory blocks

;Subroutine To combine two memory blocks
;	c{EBX} = Second (higher) memory block
;	c{EDX} = First (lower) memory block
;	CALL 	combine
;	c{EDX} = Resulting block

combine:
	MOVL	EAX, mb_size[EBX]	;Get size of second block
	ADDL	EAX, #HDRSIZE
	MOVL	ECX, mb_mnext[EBX]	;Get next block in memory
	MOVL	mb_magic[EBX], #0	;Make sure this is no longer a header
	ADDL	mb_size[EDX], EAX	;Adjust size
	MOVL	mb_mnext[EDX], ECX
	TESTL	ECX, ECX		;Is this last block in memory?
	JE	10$			;Yes
	MOVL	mb_mprev[ECX], EDX	;No - fix up back pointer
	JMP	20$			;Now exit

; Here if the second block was the last block in memory

10$:	MOVL	_malloc_mtail, EDX	;Update the tail
20$:	RET				;All done here

	.PAGE
	.SBTTL	freemem - Free memory block

;Subroutine to free a memory block
;	c{EDX} = Offset of memory block to free
;	CALL 	freemem

freemem:MOVL	EBX, mb_mnext[EDX]	;Point to next block in memory
	LEAL	EAX, HDRSIZE[EDX]	;See if next block is contiguous
	ADDL	EAX, mb_size[EDX]
	CMPL	EAX, EBX
	JNE	20$			;Not contiguous
	CMPL	mb_magic[EBX], #MB_MAGIC ;Yes - is it valid?
	JE	10$			;Yes
	CALL	badmemory               ;We have bad memory, so die
	HLT

;Here if there is a block following ours and it is okay

10$:	CMPL	mb_nfree[EBX], #-1	;Is it free?
	JE	20$			;No
	PUSHL	EDX
	MOVL	EDX, EBX
	CALL	removefree		;Yes, so remove it from the free list
	POPL	EDX
	CALL	combine			;And combine it with ours
20$:	MOVL	EBX, mb_mprev[EDX]	;Point to previous block in memory
	TESTL	EBX, EBX
	JE	40$			;If none
	LEAL	EAX, HDRSIZE[EBX]	;See if previous block is contiguous
	ADDL	EAX, mb_size[EBX]
	CMPL	EAX, EDX
	JNE	40$			;Not contiguous
	CMPL	mb_magic[EAX], #MB_MAGIC ;Is it valid?
	JE	30$			;Yes
	CALL	badmemory               ;We have bad memory, so die
	HLT

;Here if there is a block preceding ours and it is okay

30$:	CMPL	mb_nfree[EBX], #-1	;Is it free?
	JE	40$			;No
	XCHGL	EDX, EBX
	CALL	removefree		;Yes, remove it from the free list
	CALL	combine			;And combine it with ours
40$:	CMPL	mb_mnext[EDX], #0	;Is this the last block in memory?
	JNE	addfree			;No - go put it on the free list
	LEAL	EAX, HDRSIZE[EDX]
	ADDL	EAX, mb_size[EDX]	;Maybe
	CMPL	_clib_mempnt#, EAX
	JNE	addfree			;Not last
	MOVL	EAX, mb_mprev[EDX]	;Last in memory, unlink this block from
	MOVL	_malloc_mtail, EAX	;  the memory list
	TESTL	EAX, EAX
	JE	50$
	MOVL	mb_mnext[EAX], #0
	JMP	60$

50$:	MOVL	_malloc_mhead, EAX
60$:	SUBL	EDX, #HDRSIZE		;Give up the memory containing this

;;;;;;;;;;;;;;;###############;;;;;;;;;;;;;;; ;; GIVE UP MEMORY!!!

;;;;;;	INT3

	RET
.PAGE
	.SBTTL	initmem - Initialize memory block

;Subroutine to initialize memory block
;	c{ECX} = Size of block
;	c{EDX} = Offset of memory block to initialize
;	CALL 	initmem

initmem:MOVL	mb_magic[EDX], #MB_MAGIC
	MOVL	mb_size[EDX], ECX	;Store size
	MOVL	mb_mnext[EDX], #-1	;Indicate not in memory list
	MOVL	mb_mprev[EDX], #-1
	MOVL	mb_pfree[EDX], #-1	;Indicate not in free list
	MOVL	mb_nfree[EDX], #-1
	RET
.PAGE
	.SBTTL	removefree - Remove memory block from free list

;Subroutine to remove a memory block from the free list
;	c{EDX} = Offset of memory block to remove
;	CALL 	removefree

removefree:
	PUSHL	EBX			;Get a scratch register
	MOVL	EAX, mb_pfree[EDX]	;Get pointer to previous
	MOVL	EBX, mb_nfree[EDX]	;Get pointer to next
	MOVL	mb_pfree[EDX], #-1	;Mark this block as not free
	MOVL	mb_nfree[EDX], #-1
	TESTL	EAX, EAX		;Is it the first?
	JE	10$			;Yes
	MOVL	mb_nfree[EAX], EBX	;No
	JMP	20$			;Continue with common code

;Here if the block we are removing is the first in the free list

10$:	MOVL	_malloc_fhead, EBX      ;Update the free list head pointer
20$:	TESTL	EBX, EBX		;Is it the last?
	JE	30$			;Yes
	MOVL	mb_pfree[EBX], EAX	;No
	JMP	40$			;Continue with common code

;Here if the block we are removing is the last in the free list

30$:	MOVL	_malloc_ftail, EAX	;Update the free list tail
40$:	POPL	EBX			;Restore scratch register
	RET

	.PAGE
	.SBTTL	splitmem - Split memory block into 2 pieces if possible

;Subroutine to split a memory block into 2 pieces if possible
;	c{ECX} = Size of block we want
;	c{EDX} = Offset ot memory block to split
;	CALL 	splitmem

;  This function takes the current memory block and sees if we can split it
;    into two pieces. For example, if the user wants a 400 byte block and we
;    presently have a 1000 byte block, we split off the last 600 bytes and
;    add it to both the memory list and the free list. If we can't split the
;    block, then we just exit.

splitmem:
	MOVL	EAX, mb_size[EDX]	;Get current size
	LEAL	EBX, HDRSIZE[ECX]	;Get requested size plus header size
	SUBL	EAX, EBX		;Subtract current size
	JLE	30$			;If can't split it
	PUSHL	EAX			;Save the new block size
	MOVL	mb_size[EDX], ECX	;We can split it - store new size
	MOVL	EAX, EDX		;Calculate offset for new block
	ADDL	EAX, EBX		;Add in block and header sizes
	MOVL	EBX, mb_mnext[EDX]	;Get current forward pointer
	MOVL	mb_mnext[EDX], EAX
	MOVL	mb_mprev[EAX], EDX	;Link new block to memory list
	MOVL	mb_mnext[EAX], EBX
	POPL	mb_size[EAX]		;Store size of new block
	MOVL	mb_magic[EAX], #MB_MAGIC
	TESTL	EBX, EBX		;Is there a next block?
	JE	10$			;No
	MOVL	mb_mprev[EBX], EAX	;Yes - fix up its back-pointer
	JMP	20$

;Here if we are adding a new block to the memory list tail

10$:	MOVL	_malloc_mtail, EAX	;Change the tail pointer
20$:	PUSHL	EDX
	MOVL	EDX, EAX		;Point to block we are freeing
	CALL	addfree 		;Give up the second block
	POPL	EDX			;Restore offset of first block
30$:	RET				;And return
.PAGE
	.SBTTL	memchk - Check memory list for consistency

;Subroutine to check memory list for consistancy
;	CALL	memchk

.IF DEF $$DEBUG
memchk:	PUSHL	EAX
	PUSHL	EDX
	PUSHL	ECX
	PUSHL	EDI
	PUSHL	ESI
	CLRL	ESI			;Clear the free block count
	MOVL	blkcnt, ESI
	MOVL	EAX, _malloc_mhead	;Point to first block
	TESTL	EAX, EAX		;Anything there?
	JNE	10$			;Yes
	CMPL	_malloc_mtail, #0	;No, is the tail NULL also?
	JE	40$			;Yes, just exit
	CALL	badmemory               ;We have bad memory, so die
	HLT

;Here with first block on memory list

10$:	CMPL	mb_mprev[EAX], #0	;Is the previous pointer NULL?
	JE	20$			;Yes, it's okay
	CALL	badmemory               ;We have bad memory, so die
	HLT

;Here if first block has valid mprev pointer

20$:	CMPL	mb_magic[EAX], #MB_MAGIC
	JE	22$
	CALL	badmemory
	HLT

;Here if the magic number is correct

22$:	MOVL	EBX, EAX		;Copy pointer to block
	MOVL	ECX, EBX		;Get top of block
	ADDL	ECX, mb_size[EBX]
	MOVL	EAX, mb_mnext[EAX]	;Get next block
	TESTL	EAX, EAX		;Have another?
	JE	30$			;No
	CMPL	EAX, ECX		;Is it above the previous block?
	JAE	24$			;Yes - go on
	CALL	badmemory
	HLT

;Here if block is above the previous block

24$:	CMPL	mb_mprev[EAX], EBX	;Is the back-pointer correct?
	JE	26$			;Yes
	CALL	badmemory               ;No
	HLT

;Here if the back-pointer is correct

26$:	CMPL	mb_nfree[EAX], #-1	;Is it on the free list?
	JNE	28$			;Yes
	CMPL	mb_pfree[EAX], #-1	;No - make sure both pointer are OK
	JE	295$
	CALL	badmemory
	HLT

;Here if block is on the free list

28$:	CMPL	mb_pfree[EAX], #-1
	JNE	29$
	CALL	badmemory
	HLT

29$:	INCL	ESI
295$:	INCL	blkcnt
	JMP	20$

;Here when all done scanning the in-use memory list

30$:	CMPL	_malloc_mtail, EBX	;Make sure tail pointer is OK
	JE	32$			;Just dandy, so quit
	CALL	badmemory               ;We have bad memory, so die
	HLT

32$:
;;;	PUSHL	blkcnt
;;;	PUSHL	#fmt01
;;;	PUSHL	#chkbfr
;;;	CALL	sprintf#
;;;	ADDL	ESP, #12t
;;;	PUSHL	#DH_STDTRM
;;;	PUSHL	#chkbfr
;;;	PUSHL	#0
;;;	CALL	svcIoOutString##

;Here if the tail pointer matches our last block - now check the free list

40$:	CLRL	EDI
	MOVL	EAX, _malloc_fhead	;Point to first block
	TESTL	EAX, EAX		;Anything there?
	JNE	44$			;Yes
	CMPL	_malloc_ftail, #0	;No, is the tail NULL also?
	JE	42$			;Yes
	CALL	badmemory               ;We have bad memory, so die
	HLT

;Here if the free list is empty

42$:	TESTL	ESI, ESI		;Did we find any free blocks?
	JE	60$			;No - OK
	CALL	badmemory
	HLT

;Here with first block on the free list

44$:	CMPL	mb_pfree[EAX], #0	;Is the previous pointer NULL?
	JE	50$			;Yes, it's okay
	CALL	badmemory               ;We have bad memory, so die
	HLT

;Here if first block has valid fprev pointer

50$:	CMPL	mb_magic[EAX], #MB_MAGIC
	JE	52$
	CALL	badmemory
	HLT

;Here if the magic number is correct

52$:	INCL	EDI			;Count the free block
	MOVL	EBX, EAX		;Copy pointer to block
	MOVL	EAX, mb_nfree[EAX]	;Get next block
	TESTL	EAX, EAX		;Have another?
	JE	56$			;No
	CMPL	mb_pfree[EAX], EBX	;Is the back-pointer correct?
	JE	52$			;Yes
	CALL	badmemory               ;No
	HLT

;Here when all done scanning the free list

56$:	CMPL	_malloc_ftail, EBX	;Make sure tail pointer is OK
	JE	58$			;Just dandy, so quit
	CALL	badmemory               ;We have bad memory, so die
	HLT

;Here if the tail pointer matches our last block

58$:	CMPL	ESI, EDI		;Is the number of free block correct?
	JE	60$
	CALL	badmemory
	HLT

60$:
;;;	PUSHL	ESI
;;;	PUSHL	#fmt02
;;;	PUSHL	#chkbfr
;;;	CALL	sprintf#
;;;	ADDL	ESP, #12t
;;;	PUSHL	#DH_STDTRM
;;;	PUSHL	#chkbfr
;;;	PUSHL	#0
;;;	CALL	svcIoOutString##

	POPL	ESI
	POPL	EDI
	POPL	ECX
	POPL	EDX
	POPL	EAX
	RET

fmt01:	.ASCIZ	"m%d"
fmt02:	.ASCIZ	"f%d"

	.psect	_DATA_p
blkcnt:	.LONG	0
chkbfr:	.BLKB	32t

.ENDC
	.END
