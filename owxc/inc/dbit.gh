#ifndef A_BIT_SET_DEFINED
typedef unsigned a_bit_set;
#define A_BIT_SET_DEFINED
#endif

#define _DBit_SIZE 256

typedef struct dom_bit_set {
	a_bit_set	_0;
	a_bit_set	_1;
	a_bit_set	_2;
	a_bit_set	_3;
	a_bit_set	_4;
	a_bit_set	_5;
	a_bit_set	_6;
	a_bit_set	_7;
} dom_bit_set;

#define _DBitAssign( dst, src ) { \
			(dst)._0 = (src)._0; \
			(dst)._1 = (src)._1; \
			(dst)._2 = (src)._2; \
			(dst)._3 = (src)._3; \
			(dst)._4 = (src)._4; \
			(dst)._5 = (src)._5; \
			(dst)._6 = (src)._6; \
			(dst)._7 = (src)._7; \
		}

#define _DBitEmpty( set ) ( \
			(set)._0 == 0 && \
			(set)._1 == 0 && \
			(set)._2 == 0 && \
			(set)._3 == 0 && \
			(set)._4 == 0 && \
			(set)._5 == 0 && \
			(set)._6 == 0 && \
			(set)._7 == 0  )

#define _DBitSet( dst, a, b, c, d, e, f, g, h ) { \
			(dst)._0 = a; \
			(dst)._1 = b; \
			(dst)._2 = c; \
			(dst)._3 = d; \
			(dst)._4 = e; \
			(dst)._5 = f; \
			(dst)._6 = g; \
			(dst)._7 = h; \
		}

#define _DBitFirst( set ) _DBitSet( set, 1, 0, 0, 0, 0, 0, 0, 0 )

#define _DBitInit( set, val ) _DBitSet( set, val, val, val, val, val, val, val, val )

#define _DBitIter( routine, set ) { \
			(routine)( (set)._0 ); \
			(routine)( (set)._1 ); \
			(routine)( (set)._2 ); \
			(routine)( (set)._3 ); \
			(routine)( (set)._4 ); \
			(routine)( (set)._5 ); \
			(routine)( (set)._6 ); \
			(routine)( (set)._7 ); \
		}

#define _DBitOverlap( a, b ) ( \
			( (a)._0 & (b)._0 ) || \
			( (a)._1 & (b)._1 ) || \
			( (a)._2 & (b)._2 ) || \
			( (a)._3 & (b)._3 ) || \
			( (a)._4 & (b)._4 ) || \
			( (a)._5 & (b)._5 ) || \
			( (a)._6 & (b)._6 ) || \
			( (a)._7 & (b)._7 ) )

#define _DBitSame( a, b ) ( \
			( (a)._0 == (b)._0 ) && \
			( (a)._1 == (b)._1 ) && \
			( (a)._2 == (b)._2 ) && \
			( (a)._3 == (b)._3 ) && \
			( (a)._4 == (b)._4 ) && \
			( (a)._5 == (b)._5 ) && \
			( (a)._6 == (b)._6 ) && \
			( (a)._7 == (b)._7 ) )

#define _DBitTurnOff( a, b ) { \
			(a)._0 &= ~(b)._0; \
			(a)._1 &= ~(b)._1; \
			(a)._2 &= ~(b)._2; \
			(a)._3 &= ~(b)._3; \
			(a)._4 &= ~(b)._4; \
			(a)._5 &= ~(b)._5; \
			(a)._6 &= ~(b)._6; \
			(a)._7 &= ~(b)._7; \
		}

#define _DBitIntersect( a, b ) { \
			(a)._0 &= (b)._0; \
			(a)._1 &= (b)._1; \
			(a)._2 &= (b)._2; \
			(a)._3 &= (b)._3; \
			(a)._4 &= (b)._4; \
			(a)._5 &= (b)._5; \
			(a)._6 &= (b)._6; \
			(a)._7 &= (b)._7; \
		}

#define _DBitTurnOn( a, b ) { \
			(a)._0 |= (b)._0; \
			(a)._1 |= (b)._1; \
			(a)._2 |= (b)._2; \
			(a)._3 |= (b)._3; \
			(a)._4 |= (b)._4; \
			(a)._5 |= (b)._5; \
			(a)._6 |= (b)._6; \
			(a)._7 |= (b)._7; \
		}

#define _DBitScalar( a ) ( (a)._0 )

#ifdef _DBit_DEFINE_BITNEXT
static void _DBitNext( dom_bit_set *set ) {

    if( set->_0 & 0x80000000 ) {
	_DBitSet( *set, 0, 1, 0, 0, 0, 0, 0, 0 );
    } else {
	if( set->_1 & 0x80000000 ) {
	    _DBitSet( *set, 0, 0, 1, 0, 0, 0, 0, 0 );
	} else {
	    if( set->_2 & 0x80000000 ) {
		_DBitSet( *set, 0, 0, 0, 1, 0, 0, 0, 0 );
	    } else {
		if( set->_3 & 0x80000000 ) {
		    _DBitSet( *set, 0, 0, 0, 0, 1, 0, 0, 0 );
		} else {
		    if( set->_4 & 0x80000000 ) {
			_DBitSet( *set, 0, 0, 0, 0, 0, 1, 0, 0 );
		    } else {
			if( set->_5 & 0x80000000 ) {
			    _DBitSet( *set, 0, 0, 0, 0, 0, 0, 1, 0 );
			} else {
			    if( set->_6 & 0x80000000 ) {
				_DBitSet( *set, 0, 0, 0, 0, 0, 0, 0, 1 );
			    } else {
				if( set->_7 & 0x80000000 ) {
				    _DBitSet( *set, 0, 0, 0, 0, 0, 0, 0, 0 );
				} else {
				    (*set)._0 <<= 1;
				    (*set)._1 <<= 1;
				    (*set)._2 <<= 1;
				    (*set)._3 <<= 1;
				    (*set)._4 <<= 1;
				    (*set)._5 <<= 1;
				    (*set)._6 <<= 1;
				    (*set)._7 <<= 1;
				}
			    }
			}
		    }
		}
	    }
	}
    }
}
#endif

