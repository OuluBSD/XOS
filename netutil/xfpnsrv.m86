	.TITLE	xfpnsrv - XFP file server for XOS

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

	.PROC	80386

	.INCLUD	XOSINC:\XMAC\STDIO.PAR
	.INCLUD	XOSINC:\XMAC\CTYPE.PAR
	.INCLUD	XOSINC:\XMAC\PROCARG.PAR
	.INCLUD	XOSINC:\XMAC\XOS.PAR
	.INCLUD	XOSINC:\XMAC\XOSERR.PAR
	.INCLUD	XOSINC:\XMAC\XOSTIME.PAR
	.INCLUD	XOSINC:\XMAC\XOSNET.PAR

	.STDSEGS

INSTMAX =!31t		;Maximum instance number
CMDTDB  =!2C000h
CDBBASE =!30000h	;Base offset for first CDB
MAXOPENS=!128t
DFTOPENS=!10t
MAXCONS =!4088t
DFTCONS =!20t

;This program is the XFP file server.  It is initialized as a symbiont with the
;  following command:

;	SYMBIONT XFPSRV UNIT=n LOGLEVEL=l LOGFILE=log
;	  Where:
;		UNIT     = Server unit number (default = 1)
;		LOGLEVEL = Specifies the logging level, default is 3 if LOGFILE
;			   is specified, 0 otherwise
;				0 = No logging
;				1 = Log major events
;				2 = Log all network messages
;		LOGFILE  = Specifies file for log output, if not specified no
;			   log output is generated

;Each copy of XFPSRV running on a system must have a unique unit number.  The
;  actual connections between network TCP devices and the server are made after
;  the server is loaded using the SERVER utility.

;Description of data structures used:

;  The server can support up to 31 server instances.  Each instance is
;  associated with an TCP unit/port number pair and can support up to 4088
;  open files (in theory!).  For each instance an IDB is allocated (at the
;  base of a 16MB address space which is reserved for the IDB and the
;  associated CDBs) and contains all data needed to operate the instance.
;  The IDB includes a table of pointers to each possible CDB.  The size of
;  this table is equal to the maximum number of open files allowed.  CDBs
;  (each of which is 4KB) are only allocated when a file is opened.  Each
;  one is allocated as a separate 1 page msect.

;Memory layout for a single instance (starts on a 16MB boundry, base for
;  unit 1 starts at 16MB):
;    base + 00000000:        IDB
;    base + idb_cdbtbl:      CDB table (first entry is for CDB number 8)
;    base + 00008000:        First CDB
;    base + 00009000:        Second CDB
;    ...

;  Free CDBs are managed using a free list linked through the CDB table.  Each
;  free list entry contains the NUMBER of the next free CDB.  The number is
;  the difference between the CDBs offset and the base of the IDB divided by
;  1000h.  The first CDB thus has a number of 8.

.PAGE
;1.1  10-Sep-04	Modifed to use type 2 connections instead of type 3


VERSION=!2t		;Version number
EDITNUM=!1t		;Edit number

VECT_OPEN   =!70t	;TCP open done signal
VECT_HEADER =!71t	;TCP header input available signal
VECT_DATA   =!72t	;TCP data input available signal
VECT_OUTPUT =!73t	;TCP output complete signal
VECT_CLOSE  =!74t	;TCP close done signal
VECT_DISK   =!75t	;Disk IO done signal

NUMHNDL   =!4t		;Maximum number of open files per connection
DFLT_OPENS=!3t		;Default number of queued opens
DFLT_CONTS=!30t		;Default number of open connections

BUFRSIZE  =!1600t
PARMSIZE  =!1600t

;Define offsets in the IDBs (Instance Data Blocks)

$$$=!0
BLK idb_opnqab  , qab_SIZE	;TCP open QAB
BLK idb_instance, 4t		;Instance number
BLK idb_numcon  , 4t		;Maximum number of connections
BLK idb_cntcon  , 4t		;Current number of connections
BLK idb_cdbfree , 4t		;Offset of first free CDB
BLK idb_tcpdev  , 20t		;Name of TCP device
BLK idb_parm    , 48t		;Parameter list buffer
BLK idb_cdbtbl  , 0		;CDB offset table (must be last item in IDB)
idb_SIZE=!$$$

;Define offsets in the CDBs (Connection Data Blocks)

cdb_MSIZE=!48t
$$$=!-cdb_MSIZE
BLK cdb_curhndl , 1t		;Current XFP handle
BLK cdb_cntsize , 1t		;Size of data count in data response message
BLK             , 2t
BLK cdb_parmsize, 4t		;Size of parameter
BLK cdb_parmbits, 4t		;Bits for parameter
BLK cdb_parmend , 4t		;Offset of end of parameter list
BLK cdb_string  , 4t		;Offset for allocating string buffers
BLK cdb_reqtotal, 4t		;Total amount requested
BLK cdb_diskdsp , 4t		;Dispatch for disk io done
BLK cdb_idb     , 4t		;Offset of IDB
BLK cdb_number  , 4t		;CDB number
BLK cdb_rmtnode , 4t		;Network address of remote node
BLK cdb_rmtport , 4t		;Remote port number
BLK cdb_lclport , 4t		;Local port number
BLK cdb_tcpqab  , qab_SIZE	;QAB for TCP IO
.IF NE cdb_tcpqab
	.IRP	q, >cdb_tcpqab
	.ERROR	CDB starting offset is wrong, cdb_tcpqab = q'h
	.ENDR
.ENDC
BLK cdb_diskqab , qab_SIZE	;QAB for disk IO
BLK cdb_hndltbl , NUMHNDL*4	;XFP handle table
BLK cdb_hndlamnt, NUMHNDL*4	;Amount output table
BLK cdb_buffer  , BUFRSIZE	;Data buffer
BLK cdb_parm    , PARMSIZE	;Parameter list buffer
cdb_SIZE=!$$$
.PAGE
	.PSECT	_DATA_p

kwadd:     .ASCIZ "ADD"
kwremove:  .ASCIZ "REMOVE"
kwstatus:  .ASCIZ "STATUS"
kwdisable: .ASCIZ "DISABLE"
kwenable:  .ASCIZ "ENABLE"
kwnumcon:  .ASCIZ "NUMCON"
kwdevice:  .ASCIZ "DEVICE"
kwdev:     .ASCIZ "DEV"
kwinstance:.ASCIZ "INSTANCE"
kwins:     .ASCIZ "INS"

cmdword::
	.LONG	kwadd    , 0, 0, srvFncCommand#, cmdadd
	.LONG	kwremove , 0, 0, srvFncCommand#, cmdremove
	.LONG	kwstatus , 0, 0, srvFncCommand#, cmdstatus
	.LONG	kwdisable, 0, 0, srvFncCommand#, cmddisable
	.LONG	kwenable , 0, 0, srvFncCommand#, cmdenable
	.LONG	0

keywordadd:
	.LONG	kwnumcon  , ASF$VALREQ|ASF$NVAL , 0, fncnumcon  , 0
	.LONG	kwdevice  , ASF$VALREQ|ASF$LSVAL, 0, fncdevice  , 0
	.LONG	kwdev     , ASF$VALREQ|ASF$LSVAL, 0, fncdevice  , 0
keyword:.LONG	kwinstance, ASF$VALREQ|ASF$NVAL , 0, fncinstance, 0
	.LONG	kwins     , ASF$VALREQ|ASF$NVAL , 0, fncinstance, 0
	.LONG	0
.PAGE
	.SBTTL	Start of program

	.PSECT	_OTEXT_p

setup1::PUSHL	#VECT_OPEN		;Set the open done vector
	PUSHL	#84h+{VT_XOSS<8}
	PUSHL	CS
	PUSHL	#opendone
	CALLF	svcSchSetVector#
	TESTL	EAX, EAX
	JS	4$
	PUSHL	#VECT_HEADER		;Set the header input ready vector
	PUSHL	#84h+{VT_XOSS<8}
	PUSHL	CS
	PUSHL	#headerdone
	CALLF	svcSchSetVector#
	TESTL	EAX, EAX
4$:	JS	srvVectFailR#
	PUSHL	#VECT_DATA		;Set the data input ready vector
	PUSHL	#84h+{VT_XOSS<8}
	PUSHL	CS
	PUSHL	#datadone
	CALLF	svcSchSetVector#
	TESTL	EAX, EAX
	JS	4$
	PUSHL	#VECT_OUTPUT		;Set the output complete vector
	PUSHL	#84h+{VT_XOSS<8}
	PUSHL	CS
	PUSHL	#outputdone
	CALLF	svcSchSetVector#
	TESTL	EAX, EAX
	JS	4$
	PUSHL	#VECT_CLOSE		;Set the close done vector
	PUSHL	#84h+{VT_XOSS<8}
	PUSHL	CS
	PUSHL	#closedone
	CALLF	svcSchSetVector#
	TESTL	EAX, EAX
	JS	4$
	PUSHL	#VECT_DISK		;Set the disk IO done vector
	PUSHL	#84h+{VT_XOSS<8}
	PUSHL	CS
	PUSHL	#diskdone
	CALLF	svcSchSetVector#
	TESTL	EAX, EAX
	JS	4$
	RET

finishcmd::
setup2::RET
.PAGE
	.SBTTL	setupcmd - Subroutine to set up for command processing

;Subroutine to set up for command processing
;	CALL	setupcmd

setupcmd::
	CLRL	EAX
	MOVL	instance, EAX
	RET

message::
	CLRL	EAX
	INCL	EAX
	RET
.PAGE
	.SBTTL	fncdevice - Function to process the DEVICE keyword

;Function to process the DEVICE keyword - this specifies the maximum number of
;  connections allowed for an ADD command

fncdevice:
	MOVL	ESI, 4t.B[ESP]		;Get offset of name to copy
	MOVL	ESI, argdata_value.B[ESI]
	MOVL	EDI, #tcpdev
	MOVL	ECX, #16t
	PUSHL	DS
	POPL	ES
	CLD
	MOVB	AH, #0
2$:	LODSB	[ESI]			;Get character
	CMPB	AL, #0
	JE	6$.S
	STOSB	[EDI]			;Store character
	CMPB	AL, #':'
	JNE	4$.S
	MOVB	AH, #1
4$:	LOOP	ECX, 2$			;Loop if room for more
	MOVL	EBX, #toolngmsg
	JMP	fncbad

6$:	CMPB	AH, #0
	JNE	8$.S
	MOVB	AL, #':'
	STOSB	[EDI]
8$:	MOVB	[EDI], #0
	JMP	rtnone
.PAGE
	.SBTTL	fncnumcon - Function to process the NUMCON keyword

;Function to process the NUMCON keyword - this specifies the maximum number of
;  connections allowed for an ADD command

fncnumcon:
	MOVL	EBX, 4[ESP]		;Get offset of the argument data
	MOVL	EAX, argdata_value[EBX] ;Get value
	TESTL	EAX, EAX
	JNE	6$
	MOVB	AL, #DFTCONS
6$:	CMPL	EAX, #MAXCONS
	JA	8$
	MOVL	numcon, EAX		;Store it
rtnone:	CLRL	EAX
	INCL	EAX
	RET

;Here if he wants too many connections

8$:	MOVL	EBX, #bncmsg
	JMP	fncbad

	.SBTTL	fncinstance - Function to process the INSTANCE keyword

;Function to process the INSTANCE keyword - this specifies the instance number

fncinstance:
	MOVL	EBX, 4[ESP]		;Get offset of the argument data
	MOVL	EAX, argdata_value[EBX]	;Get value
	TESTL	EAX, EAX
	JE	10$
	CMPL	EAX, #INSTMAX		;Valid?
	JA	10$			;No
	MOVL	instance, EAX		;Yes - store it
	JMP	rtnone

;Here if the instance number is not valid

10$:	MOVL	EBX, #bdimsg
fncbad:	PUSHL	ESI
	PUSHL	EDI
	PUSHL	#0
	PUSHL	EBX
	PUSHL	#0
	CALL	srvCmdErrorResp#
	ADDL	ESP, #12t
	POPL	EDI
	POPL	ESI
	CLRL	EAX
	RET

bncmsg:	.ASCIZ	"Invalid number of connections specified"
bdimsg:	.ASCIZ	"Invalid instance number"
.PAGE
	.SBTTL	cmdadd - Subroutine to process the ADD command

;Subroutine to process the ADD command

cmdadd:	MOVL	EAX, 4t[ESP]
	MOVL	cmdpntr, EAX
	MOVB	tcpname, #0
	MOVL	tcpport, #UDPP_XFP
	MOVL	numcon, #DFTCONS
	MOVL	numopen, #DFTOPENS
	PUSHL	#0			;No default extension for indirect file
	PUSHL	#0			;No next line function
	PUSHL	#srvCmdError#		;Error function
	PUSHL	#0			;Function called for non-keyword args
	PUSHL	#keywordadd		;Offset of keyword table
	PUSHL	#0			;Offset of option table
	PUSHL	#PAF$INDIRECT|PAF$EATQUOTE ;Flag bits
	PUSHL	#cmdpntr		;Offset of arg string pointer
	CALL	procarg#		;Process arguments
	ADDL	ESP, #32t
	TESTL	EAX, EAX
	JE	2$
	CALL	requireinst		;Make sure instance was specified
	JC	2$
	MOVL	EAX, instance
	BTL	instx, EAX		;Is the instance defined now?
	JNC	4$			;No - go on
	SUBL	ESP, #100t		;Yes - complain and fail
	MOVL	ESI, ESP
	PUSHL	instance
	PUSHL	#iiufmt
	PUSHL	ESI
	CALL	sprintf#
	PUSHL	#0
	PUSHL	ESI
	PUSHL	#0
	CALL	srvCmdErrorResp#
	ADDL	ESP, #124t
2$:	RET

;Here if specified instance does not now exist

4$:	MOVL	ESI, instance
	SHLL	ESI, #24t
	PUSHL	DS
	PUSHL	ESI
	PUSHL	#PG$READ|PG$WRITE
	MOVL	EAX, #idb_SIZE
	IMULL	EDX, numcon, #4
	ADDL	EAX, EDX
	PUSHL	EAX
	CALLF	svcMemChange##
	TESTL	EAX, EAX		;Error?
	JNS	6$			;No - go on
	SUBL	ESP, #100t		;Yes - complain and fail
	MOVL	ESI, ESP
	PUSHL	instance
	PUSHL	#nmifmt
err2:	PUSHL	ESI
	CALL	sprintf#
	PUSHL	#0
	PUSHL	ESI
	PUSHL	#0
	CALL	srvCmdErrorResp#
	ADDL	ESP, #124t
	RET

;Here with memory allocated for the instance

6$:	MOVL	EAX, instance		;Indicate instance exists
	BTSL	instx, EAX
	MOVL	idb_instance[ESI], EAX	;Store the instance number
	MOVL	ECX, numcon		;Store maximum number of connections
	MOVL	idb_numcon[ESI], ECX
	LEAL	EBX, idb_cdbtbl[ESI]	;Set up the CDB free list
	MOVL	EAX, #8t
	MOVL	idb_cdbfree[ESI], EAX
	DECL	ECX
	JE	10$
8$:	INCL	EAX
	MOVL	[EBX], EAX
	ADDL	EBX, #4
	LOOP	ECX, 8$
10$:	PUSHL	#O$IN|O$OUT
	PUSHL	DS
	PUSHL	#tcpdev
	PUSHL	DS
	PUSHL	#openparms
	CALLF	svcIoOpen##
	TESTL	EAX, EAX
	JNS	14$
	MOVL	ESI, #orpcmsg
12$:	PUSHL	#0
	PUSHL	ESI
	PUSHL	EAX
	CALL	srvCmdErrorResp#
	ADDL	ESP, #12t
	RET

;Here with the TCP queueing device open - now do a queued open

14$:	MOVL	idb_opnqab+qab_func[ESI], #QFNC_OPEN
	MOVL	idb_opnqab+qab_option[ESI], #O$IN|O$OUT
	MOVL	idb_opnqab+qab_vector[ESI], #VECT_OPEN
	LEAL	EDI, idb_tcpdev[ESI]
	MOVL	idb_opnqab+qab_buffer1+0[ESI], EDI
	MOVL	idb_opnqab+qab_buffer1+4[ESI], DS
	LEAL	EDX, idb_parm[ESI]
	MOVL	idb_opnqab+qab_parm+0[ESI], EDX
	MOVL	idb_opnqab+qab_parm+4[ESI], DS
	PUSHL	DS
	POPL	ES
	CLD
	PUSHL	ESI
	MOVL	ESI, #tcpdev
	MOVL	ECX, #5
	RMOVSL	[EDI], [ESI]
	MOVL	EDI, EDX
	MOVL	ESI, #opnparms
	MOVL	ECX, #{OPNPSIZE+3}/4
	RMOVSL	[EDI], [ESI]
	POPL	ESI
	MOVL	idb_parm+opn_conhndl[ESI], EAX
	PUSHL	DS
	PUSHL	ESI
	CALLF	svcIoQueue##
	ORL	EAX, EAX
	JNS	16$
	MOVL	ESI, qrpcmsg
	JMP	12$

;Here with initial queued TCP open queued

$$$$done::
16$:	SUBL	ESP, #100t
	MOVL	EDI, ESP
	PUSHL	idb_instance[ESI]
	PUSHL	#okfmt
	PUSHL	EDI
	CALL	sprintf#
	PUSHL	EDI
	CALL	srvCmdResponse#
	ADDL	ESP, #116t
	RET

iiufmt:	.ASCIZ	"Instance %d already exists"
nmifmt:	.ASCIZ	"Cannot allocate memory for instance %d"
orpcmsg:.ASCIZ  "Error opening TCP device"
qrpcmsg:.ASCII  "Error queueing initial TCP open for incoming connections"
	.ASCIZ	" device"
okfmt:	.ASCIZ	{MT_FINALMSG}"XFPSRV: Instance %d created"

	.MOD	4
opnparms:
	.BYTE	PAR$SET|REP_HEXV, 4
	.WORD	IOPAR_NETCONHNDL
opn_conhndl=!$-opnparms
	.LONG	0
	.BYTE	PAR$GET|REP_HEXV, 4
	.WORD	IOPAR_NETLCLPORT
opn_lclport=!$-opnparms
	.LONG	0
	.BYTE	PAR$SET|REP_DECV, 2
	.WORD	IOPAR_NETPKTMAX
	.WORD	1452t
	.BYTE	PAR$SET|REP_DECV, 2
	.WORD	IOPAR_NETKATIME
	.WORD	120t
	.BYTE	PAR$GET|REP_HEXV, 4
	.WORD	IOPAR_NETRMTNETAR
opn_rmtnode=!$-opnparms
	.LONG	0
	.BYTE	PAR$GET|REP_HEXV, 2
	.WORD	IOPAR_NETRMTPORTR
opn_rmtport=!$-opnparms
	.WORD	0
	.BYTE	0
OPNPSIZE=!$-opnparms
.PAGE
	.SBTTL	cmdremove - Subroutine to process the REMOVE command

;Subroutine to process the REMOVE command

cmdremove:
	CALL	requireinst
	JC	10$
	PUSHL	#rmvmsg
	CALL	srvCmdResponse#
	ADDL	ESP, #4t
10$:	RET

rmvmsg:	.ASCIZ	{MT_FINALERR}"? XFPSRV: REMOVE command not implemented yet!"
.PAGE
	.SBTTL	cmdstatus - Subroutine to process the STATUS command

;Subroutine to process the STATUS command

cmdstatus:
	MOVL	EDI, #stsmsg
	JMP	srvCmdResponse#

stsmsg:	.ASCIZ	{MT_FINALERR}"? XFPSRV: STATUS command not implemented yet!"
.PAGE
	.SBTTL	cmdenable - Subroutine to process the ENABLE command

;Subroutine to process the ENABLE command

cmdenable:
	CALL	requireinst
	JC	10$
	PUSHL	#enbmsg
	CALL	srvCmdResponse#
	ADDL	ESP, #4t
10$:	RET

enbmsg:	.ASCIZ	{MT_FINALERR}"? XFPSRV: ENABLE command not implemented yet!"
.PAGE
	.SBTTL	cmddisenable - Subroutine to process the DISABLE command

;Subroutine to process the DISABLE command

cmddisable:
	CALL	requireinst
	JC	10$
	PUSHL	#dismsg
	CALL	srvCmdResponse#
	ADDL	ESP, #4t
10$:	RET

dismsg:	.ASCIZ	{MT_FINALERR}"? XFPSRV: DISABLE command not implemented yet!"
.PAGE
	.SBTTL	requireinst

requireinst:
	CMPL	instance, #0
	JNE	4$
	PUSHL	#noinmsg
	CALL	srvCmdResponse#
	ADDL	ESP, #4t
	STC
4$:	RET

noinmsg:.ASCIZ	{MT_FINALERR}"? XFPSRV: No instance specified"

	.SBTTL	End of command processing
.PAGE
	.SBTTL	qinput - Subroutine to queue TCP input

;Subroutine to queue TCP input
;	c{EDI} = Offset of CDB
;	c{ESI} = Offset of SDB
;	CALL	qinput

qinput:	MOVW	cdb_tcpqab+qab_func[EDI], #QFNC_INBLOCK ;Set up the QAB
	MOVL	cdb_tcpqab+qab_count[EDI], #4t
	MOVL	cdb_tcpqab+qab_vector[EDI], #VECT_HEADER
	LEAL	EAX, cdb_buffer[EDI]
	MOVL	cdb_tcpqab+qab_buffer1+0[EDI], EAX
	PUSHL	DS			;Queue an input
	PUSHL	EDI
	CALLF	svcIoQueue#
	TESTL	EAX, EAX
	JS	4$			;If error
	RET				;Thats all

;Here if error queueing input

4$:	PUSHL	#qinmsg
	PUSHL	EAX
	CALL	srvLogSysLog#
	ADDL	ESP, #8t
	RET
.PAGE
	.SBTTL	opendone - Signal routine for TCP open complete

;Signal routine for queued TCP open complete

opendone:
	PUSHAL				;Save registers
	MOVL	ESI, 64t[ESP]		;Get offset of the IDB
	CMPL	idb_opnqab+qab_error[ESI], #0 ;Error on the open?
	JNS	6$			;No
	PUSHL	#opnemsg2		;Yes
	PUSHL	idb_opnqab+qab_error[ESI]
	CALL	srvLogSysLog#
	ADDL	ESP, #8t
	JMP	opnfin

;Here if no error on the queued open - Allocate a CDB

6$:	MOVL	ECX, idb_cdbfree[ESI]	;Yes - get a free CDB slot
	TESTL	ECX, ECX
	JNE	8$			;Go if have one available
	PUSHL	#nocdbsmsg
	PUSHL	#0
	CALL	srvLogSysLog#
	ADDL	ESP, #8t
	JMP	opnfin

;Here with an available CDB slot

8$:	CMPB	srvDebugLevel#, #1	;Should we log this?
	JB	10$			;No
	PUSHL	ECX			;Yes
	PUSHL	ECX
	PUSHL	#confmt
	PUSHL	srvDebugStream#
	CALL	fprintf#
	ADDL	ESP, #12t
	POPL	ECX
10$:	MOVL	EDI, ECX
	SHLL	EDI, #12t		;Get offset of the CDB
	ADDL	EDI, ESI
	PUSHL	DS			;Allocate memory for the CDB
	PUSHL	EDI
	PUSHL	#PG$WRITE|PG$READ
	PUSHL	#cdb_SIZE
	CALLF	svcMemChange#
	TESTL	EAX, EAX
	JNS	12$			;If OK
	PUSHL	#nomcdbmsg
	CALL	srvLogSysLog#
	POPL	EAX
	JMP	opnfin

;Here with memory allocated for the CDB

12$:	MOVL	EAX, idb_cdbtbl-8*4[ESI+ECX*4] ;Remove CDB from the free list
	MOVL	idb_cdbfree[ESI], EAX
	ADDL	EDI, #cdb_MSIZE
	MOVL	idb_cdbtbl-8*4[ESI+ECX*4], EDI
	MOVL	cdb_number[EDI], ECX	;Store index
	MOVL	cdb_idb[EDI], ESI	;Store offset of the IDB
	MOVL	EAX, idb_opnqab+qab_handle[ESI] ;Store TCP device handle
	MOVL	cdb_tcpqab+qab_handle[EDI], EAX
	MOVZWL	EAX, idb_parm+opn_lclport[ESI] ;Store local port number
	MOVL	cdb_lclport[EDI], EAX
	MOVZWL	EAX, idb_parm+opn_rmtport[ESI] ;Store remote port number
	MOVL	cdb_rmtport[EDI], EAX
	MOVL	EAX, idb_parm+opn_rmtnode[ESI] ;And store remote IP address
	MOVL	cdb_rmtnode[EDI], EAX
	MOVL	cdb_diskqab+qab_buffer1+4[EDI], DS
	MOVL	cdb_diskqab+qab_buffer2+4[EDI], DS
	MOVL	cdb_diskqab+qab_parm+4[EDI], DS
	MOVL	cdb_diskqab+qab_vector[EDI], #VECT_DISK
	MOVL	cdb_tcpqab+qab_buffer1+4[EDI], DS
	MOVL	cdb_tcpqab+qab_buffer2+4[EDI], DS
	MOVL	cdb_tcpqab+qab_parm+4[EDI], DS
	CALL	qinput			;Queue an input for this connection

;Here with all processing done for the queued open - now queue another open

opnfin:	PUSHL	DS
	PUSHL	ESI
	CALLF	svcIoQueue##
	ORL	EAX, EAX
	JS	20$
	POPAL				;Restore registers
	CALLF	svcSchDismiss#		;And dismiss

;Here if error queuing the TCP open

20$:	HLT				;WRITE THIS SOON
.PAGE
	.SBTTL	headerdone - Software interrupt routine for TCP header input complete

;Software interrupt routine for TCP header input complete

headerdone:
	PUSHAL				;Save registers
	MOVL	EDI, 64t[ESP]		;Get offset of the CDB
	TESTB	cdb_tcpqab+qab_status+1[EDI], #QSTS$DONE>8 ;Really finished?
	JE	6$			;No - false alarm!
2$:	CMPL	cdb_tcpqab+qab_error[EDI], #0 ;Yes - any errors?
	JS	tcperr			;Yes
	CMPB	srvDebugLevel#, #2
	JB	4$
	MOVL	EBX, #strtcpi
	MOVL	EDX, #tablei
	MOVL	ECX, cdb_tcpqab+qab_amount[EDI]
	CALL	logmsg
4$:	CMPL	cdb_tcpqab+qab_amount[EDI], #4t
	JNE	10$
	MOVZWL	EAX, cdb_buffer+0[EDI]	;Get the message length
	XCHGB	AL, AH
	CMPL	EAX, #BUFRSIZE-4t	;Is it too long?
	JG	12$
	MOVL	cdb_tcpqab+qab_count[EDI], EAX
	MOVB	AL, cdb_buffer+3[EDI]	;Get the channel number
	ANDL	EAX, #0Fh
	DECL	EAX
	JS	proterr
	CMPB	AL, #NUMHNDL		;Valid value?
	JAE	proterr			;No - fail
	MOVB	cdb_curhndl[EDI], AL	;Yes - remember the handle
	MOVL	EAX, cdb_hndltbl[EDI+EAX*4] ;Get disk handle
	MOVL	cdb_diskqab+qab_handle[EDI], EAX
	MOVL	cdb_tcpqab+qab_vector[EDI], #VECT_DATA
	LEAL	EAX, cdb_buffer+4[EDI]
	MOVL	cdb_tcpqab+qab_buffer1+0[EDI], EAX
	PUSHL	DS			;Queue an input
	PUSHL	EDI
	CALLF	svcIoQueue#
	TESTL	EAX, EAX
	JS	tcperr			;If error
6$:	POPAL
	CALLF	svcSchDismiss#

;Here if header input is incomplete

10$:	MOVL	EAX, #ER_ICMIO
	JMP	tcperr

;Here if message is too long

12$:	MOVL	EAX, #ER_NDRTL
	JMP	tcperr
.PAGE
	.SBTTL	datadone - Software interrupt routine for TCP data input complete

;Software interrupt routine for TCP data input complete

datadone:
	PUSHAL				;Save registers
	MOVL	EDI, 64t[ESP]		;Get offset of the CDB
	TESTB	cdb_tcpqab+qab_status+1[EDI], #QSTS$DONE>8 ;Really finished?
	JE	6$			;No - false alarm!
2$:	CMPL	cdb_tcpqab+qab_error[EDI], #0 ;Yes - any errors?
	JS	tcperr			;Yes
	CMPB	srvDebugLevel#, #2
	JB	4$
	MOVL	EBX, #strtcpi
	MOVL	EDX, #tablei
	MOVL	ECX, cdb_tcpqab+qab_amount[EDI]
	CALL	logmsg
4$:	MOVL	EAX, cdb_tcpqab+qab_amount[EDI]
	CMPL	EAX, cdb_tcpqab+qab_count[EDI]
	JNE	10$
	MOVB	AL, cdb_buffer+2[EDI]	;Get the function value
	ANDL	EAX, #0Fh
	JMPIL	cmddsp[EAX*4]		;Dispatch on the function

6$:	POPAL
	CALLF	svcSchDismiss#

;Here if input is not the correct length

10$:	MOVL	EAX, #ER_ICMIO
	JMP	tcperr

	.MOD	4
cmddsp:	.LONG	proterr		;	         = 0  - Illegal
	.LONG	proterr		;XFPF_CONNECT    = 1  - Connect
	.LONG	proterr		;XFPF_PASSWORD   = 2  - Password
	.LONG	proterr		;XFPF_DISCONNECT = 3  - Disconnect
	.LONG	proterr		;XFPF_SESSION    = 4  - Add to session
	.LONG	proterr		;XFPF_KEEPALIVE  = 5  - Keep alive
	.LONG	proterr		;                = 6
	.LONG	proterr		;                = 7
	.LONG	msgopen		;XFPF_OPEN       = 8  - Open
	.LONG	msgdevparm	;XFPF_PARM       = 9  - Parmeter function
	.LONG	msgclose	;XFPF_CLOSE      = 10 - Close
	.LONG	msgcommit	;XFPF_COMMIT     = 11 - Commit data to file
	.LONG	msgdelete	;XFPF_DELETE     = 12 - Delete file
	.LONG	msgrename	;XFPF_RENAME     = 13 - Rename file
	.LONG	msgdata		;XFPF_DATA       = 14 - Data message
	.LONG	msgdatareq	;XFPF_DATAREQ    = 15 - Data request

proterr:MOVL	EAX, #ER_NPERR
	JMP	sererr
.PAGE
;Here on fatal protocol error

faterr:	MOVL	EAX, #ER_NPERR
	JMP	tcper2

;Here if error on input - all errors reported here indicate a serious problem
;  with the network connection - an ER_NCCLR error is the normal indication
;  of the other end clearing the connection

tcperr:	MOVL	EAX, cdb_tcpqab+qab_error[EDI]
tcper2:	CMPL	EAX, #ER_NCCLR		;Normal clearing?
	JE	clrcon			;Yes - go on
	CMPB	srvDebugLevel#, #1	;Should we log this?
	JB	clrcon			;No
	PUSHL	cdb_tcpqab+qab_handle[EDI]
	PUSHL	EAX
	PUSHL	cdb_number[EDI]
	PUSHL	#rerfmt
	PUSHL	srvDebugStream#
	CALL	fprintf#
	ADDL	ESP, #20t
clrcon:	CMPB	srvDebugLevel#, #1	;Should we log this?
	JB	2$			;No
	PUSHL	cdb_tcpqab+qab_handle[EDI]
	PUSHL	EAX
	PUSHL	cdb_number[EDI]
	PUSHL	#clrfmt
	PUSHL	srvDebugStream#
	CALL	fprintf#
	ADDL	ESP, #20t
2$:	MOVL	cdb_tcpqab+qab_func[EDI], #QFNC_CLOSE ;Close the TCP device
	CLRL	EAX
	MOVL	cdb_tcpqab+qab_option[EDI], EAX
	MOVL	cdb_tcpqab+qab_parm[EDI], EAX
	MOVB	cdb_tcpqab+qab_vector[EDI], #VECT_CLOSE
	PUSHL	DS
	PUSHL	EDI
	CMPB	srvDebugLevel#, #1	;Should we log this?
	JB	3$			;No
	PUSHL	cdb_tcpqab+qab_handle[EDI]
	PUSHL	EAX
	PUSHL	cdb_number[EDI]
	PUSHL	#cbgfmt
	PUSHL	srvDebugStream#
	CALL	fprintf#
	ADDL	ESP, #20t
3$:	CALLF	svcIoQueue#
	TESTL	EAX, EAX
	JS	6$			;If error
4$:	POPAL				;OK - restore registers
	CALLF	svcSchDismiss#		;And dismiss

;Here with error while clearing the TCP connection

6$:
;;;;;;;;CODE GOES HERE TO LOG THE ERROR!!!

;;;;;;;	JMP	14$

	JMP	8$			;Forget the TCP close, go close any
					;  open devices

;TCP close done software interrupt routine

closedone:
	PUSHAL				;Save registers
	MOVL	EDI, 64t[ESP]		;Get offset of the CDB
	TESTB	cdb_tcpqab+qab_status+1[EDI], #QSTS$DONE>8 ;Really finished?
	JE	4$			;No - false alarm!
	CMPB	srvDebugLevel#, #2
	JB	7$
	PUSHL	cdb_tcpqab+qab_handle[EDI]
	PUSHL	EAX
	PUSHL	cdb_number[EDI]
	PUSHL	#cdnfmt
	PUSHL	srvDebugStream#
	CALL	fprintf#
	ADDL	ESP, #20t
7$:	CMPL	cdb_tcpqab+qab_error[EDI], #0 ;Yes - any errors?
	JS	6$			;Yes
8$:	CLRL	EAX
10$:	CMPL	cdb_hndltbl[EDI+EAX*4], #0 ;This handle in use?
	JNE	14$			;Yes
	INCL	EAX			;No - bump handle index
	CMPL	EAX, #NUMHNDL		;Finished?
	JB	10$			;No - continue
givecdb:MOVL	ESI, cdb_idb[EDI]	;Yes
	MOVL	ECX, cdb_number[EDI]	;Put this slot on the free list
	MOVL	EAX, idb_cdbfree[ESI]
	MOVL	idb_cdbtbl-8*4[ESI+ECX*4], EAX
	MOVL	idb_cdbfree[ESI], ECX
	SUBL	EDI, #cdb_MSIZE		;Give up our CDB
	PUSHL	DS
	PUSHL	EDI
	PUSHL	#PG$WRITE|PG$READ
	PUSHL	#0
	CALLF	svcMemChange#
	POPAL				;Finished here
	CALLF	svcSchDismiss#

;Here with a handle which is in use

14$:	MOVL	EDX, cdb_hndltbl[EDI+EAX*4] ;Get XOS handle
	MOVL	cdb_diskqab+qab_handle[EDI], EDX ;Store it
	MOVL	cdb_hndltbl[EDI+EAX*4], #0 ;Clear the handle table entry
	MOVW	cdb_diskqab+qab_func[EDI], #QFNC_CLOSE
	CLRL	EAX
	MOVL	cdb_diskqab+qab_option[EDI], EAX
	MOVL	cdb_diskqab+qab_parm[EDI], EAX
	MOVL	cdb_diskdsp[EDI], #8$	;Set dispatch for disk done
	JMP	dodisk			;Continue
.PAGE
;Here for the XFPF_DATA function - Data

msgdata:TESTB	cdb_buffer+1[EDI], #20h	;Have any parameters?
	JE	2$			;No
	CALL	getvalue		;Yes - get length of data area
	JC	6$
	SUBL	cdb_tcpqab+qab_amount[EDI], EAX ;Get length of parameter area
	JNS	4$
	JMP	proterr
2$:	CLRL	EAX
	XCHGL	EAX, cdb_tcpqab+qab_amount[EDI]
4$:	MOVL	cdb_diskqab+qab_count[EDI], EAX
	MOVL	cdb_diskqab+qab_buffer1[EDI], ESI ;Store data buffer offset
	ADDL	ESI, EAX		;Point to the parameters (if any)
	CALL	setupparms		;Set up the parameter list
6$:	JC	sererr
8$:	MOVL	cdb_diskdsp[EDI], #outputrdy ;Set dispatch for disk done
	MOVW	cdb_diskqab+qab_func[EDI], #QFNC_OUTBLOCK ;Store function
	JMP	dodisk			;Continue
.PAGE
;Here when disk output is complete

outputrdy:
	MOVL	EAX, cdb_diskqab+qab_amount[EDI] ;Get amount
	MOVZBL	EBX, cdb_curhndl[EDI]
	ADDL	cdb_hndlamnt[EDI+EBX*4], EAX ;Add in to amount for handle
	CMPL	cdb_diskqab+qab_error[EDI], #0 ;Error?
	JL	2$			;Yes
	CMPL	cdb_diskqab+qab_count[EDI], EAX ;Was it all output?
	JNE	4$			;No - return error
	TESTB	cdb_buffer+1[EDI], #10h	;Yes - need a response?
	JE	outputdon2		;No
2$:	MOVL	EAX, cdb_hndlamnt[EDI+EBX*4] ;Yes - get total amount output
	MOVL	cdb_diskqab+qab_amount[EDI], EAX ;Store for reply
	CLRL	EAX			;Clear the amount
	MOVL	cdb_hndlamnt[EDI+EBX*4], EAX
	CALL	setresp			;Set up the response
	JNC	sndresp			;Send it
	JMP	clrcon			;Clear connection if error

;Here if output was incomplete

4$:	MOVL	cdb_diskqab+qab_error[EDI], #ER_ICMIO
	JMP	2$
.PAGE
;Here for the XFPF_DATAREQ function - Data request

msgdatareq:
	LEAL	ESI, cdb_buffer+4[EDI]
	CALL	getvalue		;Get count value
	JC	sererr
	MOVL	cdb_reqtotal[EDI], EAX	;Store total amount wanted
	MOVZBL	EBX, cdb_curhndl[EDI]
	MOVL	cdb_hndlamnt[EDI+EBX*4], #0
	CALL	setupparms		;Set up the parameter list
	JC	sererr
datreq2:MOVL	EAX, cdb_reqtotal[EDI]	;Get amount wanted
	CMPL	EAX, #1024t		;Too big?
	JBE	2$			;No
	MOVL	EAX, #1024t		;Yes
2$:	MOVL	cdb_diskqab+qab_count[EDI], EAX ;Store byte count
	LEAL	EBX, cdb_buffer+8[EDI]	;Get offset of the data buffer
	CMPL	cdb_diskqab+qab_parm[EDI], #0 ;Have any parameters?
	JE	4$			;No
	ADDL	EBX, #2			;Yes - allow room for the data size
4$:	MOVL	cdb_diskqab+qab_buffer1[EDI], EBX ;Store buffer offset
	MOVW	cdb_diskqab+qab_func[EDI], #QFNC_INBLOCK ;Store function
	MOVL	cdb_diskdsp[EDI], #inputrdy ;Set dispatch for disk done
	JMP	dodisk			;Continue
.PAGE
;Here when disk input is done

inputrdy:
	LEAL	ESI, cdb_buffer+8[EDI]	;Point to first byte after header
					;  (assume no error)
	MOVL	EAX, cdb_diskqab+qab_amount[EDI] ;Get amount of data read
	MOVZBL	ECX, cdb_curhndl[EDI]
	ADDL	cdb_hndlamnt[EDI+ECX*4], EAX ;Add in to amount for handle
	MOVL	ESI, cdb_diskqab+qab_buffer1[EDI] ;Point to first byte past
	ADDL	ESI, EAX			  ;  the data
	CMPL	cdb_diskqab+qab_parm+0[EDI], #0 ;Have any parameters?
	JE	4$			;No
	MOVL	EDX, EAX		;Yes - store the data count
	XCHGB	DL, DH
	MOVW	cdb_buffer+8[EDI], DX
	CALL	storeparms		;Store parameters in the message
	JC	sererr			;If error
4$:	LEAL	EBX, cdb_buffer+4[EDI]	;Point to the header (Assume no error)
	MOVL	EDX, #0x01000000+{XFPOF_DATARESP<16t}
	CMPL	cdb_diskqab+qab_parm+0[EDI], #0
	JE	6$
	ORL	EDX, #0x20000000
6$:	MOVL	EAX, cdb_diskqab+qab_error[EDI]
	TESTL	EAX, EAX		;Right?
	JNS	8$			;Yes
	XCHGB	AL, AH			;No - store error code
	RORL	EAX, #16t
	XCHGB	AL, AH
	MOVL	[EBX], EAX
	SUBL	EBX, #4t		;Adjust beginning of message
	ORL	EDX, #0x90000000	;Indicate error and final
	MOVL	cdb_reqtotal[EDI], #0
8$:	MOVL	EAX, cdb_diskqab+qab_amount[EDI] ;Did we get all we asked for?
	CMPL	EAX, cdb_diskqab+qab_count[EDI]
	JL	10$			;No - must be at EOF
	SUBL	cdb_reqtotal[EDI], EAX	;Yes - reduce amount wanted
	JG	12$			;If need more
10$:	ORL	EDX, #0x10000000	;indicate final
	MOVL	cdb_reqtotal[EDI], #0
12$:	LEAL	EAX, -4[ESI]		;Get total length of message
	SUBL	EAX, EBX
	XCHGB	AL, AH
	ORL	EAX, EDX
	MOVL	[EBX], EAX		;Store header bytes
	SUBL	ESI, EBX		;OK - calculate length of the response
	MOVL	cdb_tcpqab+qab_count[EDI], ESI ;Store it in the QAB
	JMP	sndres2			;Send the response
.PAGE
;Here for the XFPF_COMMIT function - Commit data to file

msgcommit:
	CALL	setupparms		;Set up the parameter list
	JC	sererr			;If error
	MOVL	cdb_diskdsp[EDI], #commitrdy ;Set dispatch for disk done
	MOVW	cdb_diskqab+qab_func[EDI], #QFNC_COMMIT ;Store function
	JMP	dodisk			;Continue
.PAGE
;Here when commit function is complete

commitrdy:
	CMPL	cdb_diskqab+qab_error[EDI], #0 ;Error?
	JL	4$			;Yes
	CLRL	EAX			;OK - amount is always 0
	MOVL	cdb_diskqab+qab_amount[EDI], EAX ;Store for reply
4$:	JMP	closerdy		;Continue
.PAGE
;Here for the XFPF_OPEN function - Open file

msgopen:MOVW	cdb_diskqab+qab_func[EDI], #QFNC_OPEN
	CALL	opensetup		;Do first part of this
	JC	sererr
	MOVL	cdb_diskdsp[EDI], #openrdy ;Set dispatch for disk done
	JMP	dodisk

;Here if have a serious error.  This code generates an error message without
;  parameters with an item count of 0.  Generally, this is used when we detect
;  an error with the format of an input message or if some internal resource
;  is not available.
;	c{EAX} = Error code

sererr:	MOVL	cdb_buffer+0[EDI], #XFPOF_RESPONSE+9000h
	XCHGB	AL, AH
	RORL	EAX, #16t
	XCHGB	AL, AH
	MOVL	cdb_buffer+3[EDI], EAX
	MOVL	cdb_tcpqab+qab_count[EDI], #7t
	CLRL	EAX
	MOVL	cdb_tcpqab+qab_parm+0[EDI], EAX
	JMP	sndresp
.PAGE
;Here when the open is finished

openrdy:CMPL	cdb_diskqab+qab_error[EDI], #0 ;Error?
	JL	2$			;Yes
	MOVL	EAX, cdb_diskqab+qab_handle[EDI] ;No - store XOS handle
	MOVZBL	EBX, cdb_curhndl[EDI]		 ;  in the XFP handle table
	MOVB	cdb_hndltbl[EDI+EBX*4], AL
	CLRL	EAX			;Clear amount output
	MOVL	cdb_hndlamnt[EDI+EBX*4], EAX
2$:	CALL	setresp			;Set up the response message
	JC	sererr
sndresp:LEAL	EBX, cdb_buffer[EDI]
sndres2:MOVL	cdb_tcpqab+qab_buffer1+0[EDI], EBX
	MOVW	cdb_tcpqab+qab_func[EDI], #QFNC_OUTBLOCK
	MOVB	cdb_tcpqab+qab_vector[EDI], #VECT_OUTPUT
	CLRL	EAX
	MOVL	cdb_tcpqab+qab_parm+0[EDI], EAX
	CMPB	srvDebugLevel#, #2
	JB	4$
	MOVL	EBX, #strtcpo
	MOVL	EDX, #tableo
	MOVL	ECX, cdb_tcpqab+qab_count[EDI]
	CALL	logmsg
4$:	PUSHL	DS			;Start output
	PUSHL	EDI
	CALLF	svcIoQueue#
	TESTL	EAX, EAX
	JS	clrcon			;If error, just quietly clear the
					;  conection
	POPAL				;Restore registers
	CALLF	svcSchDismiss#		;And dismiss
.PAGE
;Here for the XFPF_DEVPARM function - Device parameter function

msgdevparm:
	MOVW	cdb_diskqab+qab_func[EDI], #QFNC_DEVPARM
devparm2:
	CALL	opensetup		;Do first part of this
	JC	sererr
	MOVL	cdb_diskdsp[EDI], #devparmrdy ;Set dispatch for disk done
dodisk:	PUSHL	DS
	LEAL	EAX, cdb_diskqab[EDI]
	PUSHL	EAX
	CALLF	svcIoQueue#		;Do the function
	TESTL	EAX, EAX
	JS	sererr			;If error
	POPAL
	CALLF	svcSchDismiss#		;Dismiss the interrupt
.PAGE
;Here if a devparm function has just finished

devparmrdy:
	CALL	setresp			;Set up the response message
	JNC	sndresp			;If OK
	JMP	sererr
.PAGE
;Here for the XFPF_CLOSE function - Close

msgclose:
	SUBL	cdb_tcpqab+qab_amount[EDI], #4 ;Must have at least 4 bytes
	JS	4$
	LEAL	ESI, cdb_buffer+8[EDI]
	MOVL	EAX, -4[ESI]		;Get the command bits
	ADDL	ESI, #4t
	XCHGB	AL, AH			;Fix up the byte order
	RORL	EAX, #16t
	XCHGB	AL, AH
	MOVL	cdb_diskqab+qab_option[EDI], EAX
	CALL	setupparms		;Set up the parameter list
	JC	4$
	MOVL	cdb_diskdsp[EDI], #closerdy ;Set dispatch for disk done
2$:	MOVW	cdb_diskqab+qab_func[EDI], #QFNC_CLOSE
	JMP	dodisk			;Continue

;Here if packet is too short to contain the close command bits or if have
;  error setting up the parameter list - close the file anyway but report
;  the error

4$:	CLRL	EAX
	MOVL	cdb_diskqab+qab_option[EDI], EAX
	MOVL	cdb_diskqab+qab_parm+0[EDI], EAX
	MOVL	cdb_diskdsp[EDI], #closeerr
	JMP	2$

;Here when the close function is done if had problem setting up the parameter
;  list

closeerr:
	MOVL	EAX, #ER_NPERR
	MOVL	cdb_diskqab+qab_error[EDI], EAX

;Here when the close function is done

closerdy:
	CLRL	EAX			;Clear input request amount
	MOVL	cdb_reqtotal[EDI], EAX
	MOVZBL	EDX, cdb_curhndl[EDI]
	MOVL	cdb_hndltbl[EDI+EDX*4], EAX
	CALL	setresp			;Set up the response
	JNC	sndresp			;Send it
	JMP	clrcon			;Clear connection if error
.PAGE
;Here for the XFPF_DELETE function - Delete file

msgdelete:
	MOVW	cdb_diskqab+qab_func[EDI], #QFNC_DELETE
	JMP	devparm2
.PAGE
;Here for the XFPF_RENAME function - Rename file

msgrename:
	MOVW	cdb_diskqab+qab_func[EDI], #QFNC_RENAME
	JMP	devparm2
.PAGE
	.SBTTL	opensetup - Subroutine to do set up for open type functions

;Subroutine to do set up for open type functions
;	CALL	opensetup
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

opensetup:
	SUBL	cdb_tcpqab+qab_amount[EDI], #4 ;Must have at least 4 bytes
	JS	12$
	LEAL	ESI, cdb_buffer+8[EDI]
	MOVL	EAX, -4[ESI]		;Get the command bits
	XCHGB	AL, AH			;Fix up the byte order
	RORL	EAX, #16t
	XCHGB	AL, AH
	MOVL	cdb_diskqab+qab_option[EDI], EAX
	CALL	getname			;Get offset of name string
	JC	10$
	MOVL	cdb_diskqab+qab_buffer1+0[EDI], EDX ;Store offset of name
	CMPB	cdb_diskqab+qab_func[EDI], #QFNC_RENAME ;Rename?
	JNE	2$			;No
	PUSHL	ESI
	CALL	getname			;Get offset of new name
	POPL	EBX
	JC	10$
	MOVL	cdb_diskqab+qab_buffer2+0[EDI], EDX ;Store offset of name
	MOVB	[EBX], #0		;Store null to terminate name
2$:	PUSHL	ESI			;Save offset of byte after name
	CALL	setupparms		;Set up the parameter list
	POPL	EBX
	JC	10$			;If error
	MOVB	[EBX], #0		;Store null to terminate name
	CMPB	srvDebugLevel#, #1	;Should we log this?
	JB	8$			;No
	CMPB	cdb_diskqab+qab_func[EDI], #QFNC_RENAME
	JE	4$
	PUSHL	cdb_diskqab+qab_buffer1[EDI]
	PUSHL	#namfmt
	PUSHL	srvDebugStream#
	CALL	fprintf#
	ADDL	ESP, #12t
	CLC
	RET

4$:	PUSHL	cdb_diskqab+qab_buffer2[EDI]
	PUSHL	cdb_diskqab+qab_buffer1[EDI]
	PUSHL	#renfmt
	PUSHL	srvDebugStream#
	CALL	fprintf#
	ADDL	ESP, #16t
8$:	CLC
10$:	RET

12$:	MOVL	EAX, #ER_NPERR
	STC
	RET

namfmt:	.ASCIZ	"nam: %s"{LF}
renfmt:	.ASCIZ	"nam: %s %s"{LF}

;Subroutine to get offset of name string
;	CALL	getname
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EDX} = Offset of name string
;	  c{ESI} = Pointer to first byte after name string

getname:CALL	getvalue		;Get length of file specification
	JC	14$			;If error
	SUBL	cdb_tcpqab+qab_amount[EDI], EAX
	JS	12$
	MOVL	EDX, ESI		;Save offset of name
	ADDL	ESI, EAX		;Point to next byte past name
14$:	RET
.PAGE
	.SBTTL	getvalue - Subroutine to get variable length value from the input packet

;Subroutine to get variable length value from the input packet
;	CALL	getvalue
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Value

getvalue:
	DECL	cdb_tcpqab+qab_amount[EDI]
	JS	4$
	MOVZBL	EAX, [ESI]
	INCL	ESI
	BTZL	EAX, #7t
	JNC	2$
	DECL	cdb_tcpqab+qab_amount[EDI]
	JS	4$
	MOVB	AH, AL
	MOVB	AL, [ESI]
	INCL	ESI
	BTZL	EAX, #14t
	JNC	2$
	DECL	cdb_tcpqab+qab_amount[EDI]
	JS	4$
	SHLL	EAX, #8t
	MOVB	AL, [ESI]
	INCL	ESI
	BTZL	EAX, #21t
	JNC	2$
	DECL	cdb_tcpqab+qab_amount[EDI]
	JS	4$
	SHLL	EAX, #8t
	MOVB	AL, [ESI]
	INCL	ESI
	CLC
2$:	RET

;Here if don't have enough data in the packet

4$:	MOVL	EAX, #ER_NPERR
	STC
ret010:	RET

	.SBTTL	putvalue - Subroutine to store variable length value in output packet

;Subroutine to store variable length value in output packet
;	c{EAX} = Value to store
;	CALL	putvalue

putvalue:
	CMPL	EAX, #7Fh		;Will it fit in 1 byte?
	JA	6$			;No
	MOVB	[ESI], AL		;Yes
	INCL	ESI
	RET

;Here if value will not fit in 1 byte

6$:	TESTL	EAX, #0FFFFC000h	;Will it fit in 2 bytes?
	JNE	8$			;No
	ORB	AH, #80h		;Yes
	JMP	10$

;Here if value will not fit in 2 bytes

8$:	TESTL	EAX, #0FF700000h	;Will it fit in 3 bytes?
	JNE	12$			;No
	RORL	EAX, #16t		;Yes
	ORB	AL, #0C0h
	MOVB	[ESI], AL
	INCL	ESI
	RORL	EAX, #16t
10$:	XCHGB	AL, AH
	MOVW	[ESI], AX
	ADDL	ESI, #2t
	RET

;Here if value will not fit in 3 bytes

12$:	XCHGB	AL, AH
	RORL	EAX, #16t
	XCHGB	AL, AH
	ORB	AL, #0E0h
	MOVL	[ESI], EAX
	ADDL	ESI, #4t
	RET
.PAGE
;Subroutine to get number of bytes required for a variable length value
;	c{EAX} = Value
;	c{ECX} = Current size value
;	CALL	getvalsize
;	c{ECX} = Updated size value

getvalsize:
	INCL	ECX			;Assume 1 byte will do
	CMPL	EAX, #7Fh		;Right?
	JBE	2$			;Yes
	INCL	ECX			;No
	TESTL	EAX, #0FFFFC000h	;Will 2 bytes do?
	JE	2$			;Yes
	INCL	ECX			;No
	TESTL	EAX, #0FF700000h	;Will 3 bytes do?
	JE	2$			;Yes
	INCL	ECX			;No
2$:	RET
.PAGE
	.SBTTL	setupparms - Subroutine to set up a parameter list

;Subroutine to set up a parameter list for an IO call given the received
;  XFP parameter list.
;	c{ESI} = Offset of the first parameter byte
;	CALL	setupparms
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

setupparms:
	CLRL	EAX
	MOVL	cdb_diskqab+qab_parm+0[EDI], EAX ;Assume no parameters
	CMPL	cdb_tcpqab+qab_amount[EDI], EAX ;Have any parameters?
	JE	ret010			;No
	MOVL	EAX, ESI		        ;Yes - store offset of end of
	ADDL	EAX, cdb_tcpqab+qab_amount[EDI] ;  the parameter list
	MOVL	cdb_parmend[EDI], EAX
	LEAL	EBX, cdb_parm[EDI]	;Point to place for XOS parameters
	MOVL	cdb_diskqab+qab_parm+0[EDI], EBX
	LEAL	EAX, cdb_parm+PARMSIZE[EDI] ;Store pointer for strings
	MOVL	cdb_string[EDI], EAX
2$:	CLRL	EAX
	MOVB	AL, [ESI]		;Get parameter index
	INCL	ESI
	CMPB	AL, #PARMMAX
	JA	snperr
	MOVZWL	EDX, xfp2xos[EAX*2]	;Translate to the XOS parameter
	TESTL	EDX, EDX		;  value
	JE	snperr
	MOVB	CL, xfp2rep[EAX]	;Get the parameter representation
	MOVB	AL, [ESI]		;Get bits and first part of count
	INCL	ESI
	MOVB	cdb_parmbits[EDI], AL	;Save bits
	ANDB	cdb_parmbits[EDI], #0C0h
	ANDB	AL, #1Fh
	TESTB	AL, #10h		;Need the second count byte?
	JE	4$			;No
	ANDB	AL, #0Fh
	MOVB	AH, AL			;Yes
	MOVB	AL, [ESI]
	INCL	ESI
4$:	CMPL	EAX, #1024t		;Is the parameter too long?
	JBE	6$			;No
	MOVL	EAX, #1024t		;Yes - just use maximum length
6$:	MOVL	cdb_parmsize[EDI], EAX ;Save parmeter length
	CMPW	DX, #IOPAR_DIRHNDL	;Is this the directory handle parameter?
	JE	dirhndl			;Yes - go handle that
	ORB	CL, cdb_parmbits[EDI]	;Merge in the bits
	MOVB	cdb_parmbits[EDI], CL
	MOVB	[EBX], CL		;Store it
	INCL	EBX
	XORB	CL, #REP_STR		;Does it have a string value?
	TESTB	CL, #0Fh
	JE	26$			;Yes - go handle that
	MOVB	AL, cdb_parmsize[EDI] ;No - store size
	MOVB	[EBX], AL
	INCL	EBX
	MOVW	[EBX], DX		;Store parameter index
	ADDL	EBX, #2
	TESTB	cdb_parmbits[EDI], #PAR$SET ;Are we setting the value?
	JNE	10$			;Yes - this is harder!
	ADDL	EBX, cdb_parmsize[EDI] ;No - just skip the space for the value
	JMP	setupnx

;Here if need to store a value for the parameter

10$:	MOVZBL	EAX, cdb_parmbits[EDI]
	ANDB	AL, #0Fh
	MOVL	ECX, cdb_parmsize[EDI]
	BTL	valmask, EAX		;Should we invert the byte order?
	JNC	22$			;No
	ADDL	EBX, ECX		;Yes
	CMPL	EBX, cdb_string[EDI]	;Too big?
	JAE	23$			;Yes - fail
	PUSHL	EBX
20$:	MOVB	AL, [ESI]		;Get a value byte
	INCL	ESI
	DECL	EBX
	MOVB	[EBX], AL		;Store it
	LOOP	ECX, 20$
	POPL	EBX
	JMP	setupnx

;Here if to not need to invert byte order for the value

22$:	LEAL	EAX, [EBX+ECX]		;Make sure not too big
	CMPL	EAX, cdb_string[EDI]
23$:	JAE	snperr			;Too big - fail
24$:	MOVB	AL, [ESI]
	INCL	ESI
	MOVB	[EBX], AL
	INCL	EBX
	LOOP	ECX, 24$
	JMP	setupnx

;Here if have a string value

26$:	MOVB	[EBX], #0FFh		;Store parameter "size"
	INCL	EBX
	MOVW	[EBX], DX		;Store parameter index
	ADDL	EBX, #2
	MOVL	ECX, cdb_parmsize[EDI]	;Get string length
	SUBL	cdb_string[EDI], ECX
	MOVL	EDX, cdb_string[EDI]
	CMPL	EBX, EDX		;Too big?
	JAE	snperr			;Yes - fail
	MOVL	[EBX], EDX		;No - store address of string buffer
	MOVL	4[EBX], DS
	TESTB	cdb_parmbits[EDI], #PAR$SET ;Are we setting the value?
	JE	28$			;No
	SHLL	ECX, #16t		;Yes - store size in string length
	ORL	ECX, cdb_parmsize[EDI]	;  field too
28$:	MOVL	8[EBX], ECX	
	ADDL	EBX, #12t
	TESTB	cdb_parmbits[EDI], #PAR$SET ;Are we setting the value?
	JE	setupnx			;No - finished here
	MOVZWL	ECX, CX			;Yes - copy the value to the string
	PUSHL	EDI
	MOVL	EDI, EDX
	CLD
	RMOVSB	[EDI], [ESI]
	POPL	EDI
setupnx:CMPL	EBX, cdb_string[EDI]	;Too big?
	JAE	snperr			;Yes - fail
	CMPL	ESI, cdb_parmend[EDI]	;At end of the list?
	JB	2$			;No - continue
	MOVB	[EBX], #0		;Finished - put a 0 at the end	
	CLC
	RET

;Here for serious protocol error

snperr:	MOVL	EAX, #ER_NPERR
	STC
	RET
.PAGE
;Here for the XFPAR_DIRHNDL parameter

dirhndl:CMPL	EAX, #1			;Is the length one byte?
	JNE	4$			;No - fail
	MOVB	AL, [ESI]		;Yes - get the value byte
	INCL	ESI
	DECL	EAX
	JS	4$			;Cannot be 0
	CMPL	EAX, #NUMHNDL		;Valid value?
	JAE	4$			;No - fail
	MOVL	EAX, cdb_hndltbl[EDI+EAX*4] ;Yes - get XOS handle
	TESTL	EAX, EAX		;Is it open?
	JE	4$			;No - fail
	MOVL	[EBX], #{PAR$SET|REP_DECV}+{4<8}+{IOPAR_DIRHNDL<16t}
	MOVL	4[EBX], EAX
	ADDL	EBX, #8
	JMP	setupnx			;Continue

;Here if error

4$:	MOVL	EAX, #ER_PARMV
	STC
	RET
.PAGE
	.PSECT	_DATA_p

	.MACRO	XFPAR
  XX 0   , 0			;		= 0.   - Illegal
  XX HEXV, IOPAR_FILOPTN	;XFPAR_FILOPTN  = 1.   - File option bits
  XX STR , IOPAR_FILSPEC	;XFPAR_FILSPEC  = 2.   - File spec. string
  XX HEXV, IOPAR_DEVSTS		;XFPAR_DEVSTS   = 3.   - Device status
  XX HEXV, IOPAR_UNITNUM	;XFPAR_UNITNUM  = 4.   - Unit number
  XX HEXV, IOPAR_GLBID		;XFPAR_GLBID    = 5.   - Global device ID
  XX 0   , 0			;		= 6.   - Illegal
  XX HEXV, IOPAR_TIMEOUT	;XFPAR_TIMEOUT  = 7.   - Illegal
  XX HEXV, IOPAR_INPSTS		;XFPAR_INPSTS   = 8.   - Illegal
  XX HEXV, IOPAR_OUTSTS		;XFPAR_OUTSTS   = 9.   - Illegal
  XX 0   , 0			;		= 10.  - Illegal
  XX 0   , 0			;		= 11.  - Illegal
  XX HEXV, IOPAR_DIRHNDL	;XFPAR_DIRHNDL  = 12.  - Dir. handle for srch
  XX 0   , 0			;		= 13.  - Illegal
  XX HEXV, IOPAR_SRCATTR	;XFPAR_SRCATTR  = 14.  - File attr. for srch
  XX HEXV, IOPAR_FILATTR	;XFPAR_FILATTR  = 15.  - File attr.
  XX HEXV, IOPAR_DIROFS		;XFPAR_DIROFS   = 16.  - Dir. offset for srch
  XX HEXV, IOPAR_ABSPOS		;XFPAR_ABSPOS   = 17.  - Absolute pos. in file
  XX HEXV, IOPAR_RELPOS		;XFPAR_RELPOS   = 18.  - Relative pos. in file
  XX HEXV, IOPAR_EOFPOS		;XFPAR_EOFPOS   = 19.  - Position rel. to EOF
  XX 0   , 0			;		= 20.  - Illegal
  XX HEXV, IOPAR_LENGTH		;XFPAR_LENGTH   = 21.  - Written length of file
  XX HEXV, IOPAR_REQALLOC	;XFPAR_REQALLOC = 22.  - Request allocation
  XX HEXV, IOPAR_RQRALLOC	;XFPAR_RQRALLOC = 23.  - Require allocation
  XX HEXV, IOPAR_GRPSIZE	;XFPAR_GRPSIZE  = 24.  - Allocation group size
  XX HEXV, IOPAR_ADATE		;XFPAR_ADATE    = 25.  - Last access date/time
  XX HEXV, IOPAR_CDATE		;XFPAR_CDATE    = 26.  - Creation date/time
  XX HEXV, IOPAR_MDATE		;XFPAR_MDATE    = 27.  - Modify date/time
  XX HEXV, IOPAR_PROT		;XFPAR_PROT     = 28.  - File protection
  XX STR , IOPAR_OWNER		;XFPAR_OWNNAME  = 29.  - Owner
  XX 0   , 0			;		= 30.  - Illegal
  XX HEXV, IOPAR_SETLOCK	;XFPAR_SETLOCK  = 31.  - Set file lock
  XX HEXV, IOPAR_CLRLOCK	;XFPAR_CLRLOCK  = 32.  - Clear file lock
  XX HEXV, IOPAR_SHRPARMS 	;XFPAR_SHRPARMS = 33.  - File sharing parameters
  XX 0   , 0		 	;		= 34.  - Illegal
  XX 0   , 0		 	;		= 35.  - Illegal
  XX 0   , 0		 	;		= 36.  - Illegal
  XX 0   , 0		 	;		= 37.  - Illegal
  XX 0   , 0		 	;		= 38.  - Illegal
  XX 0   , 0		 	;		= 39.  - Illegal
  XX 0   , 0		 	;		= 40.  - Illegal
  XX 0   , 0		 	;		= 41.  - Illegal
  XX 0   , 0		 	;		= 42.  - Illegal
  XX 0   , 0		 	;		= 43.  - Illegal
  XX 0   , 0		 	;		= 44.  - Illegal
  XX 0   , 0		 	;		= 45.  - Illegal
  XX 0   , 0		 	;		= 46.  - Illegal
  XX 0   , 0		 	;		= 47.  - Illegal
  XX 0   , 0		 	;		= 48.  - Illegal
  XX 0   , 0		 	;		= 49.  - Illegal
  XX 0   , 0		 	;		= 50.  - Illegal
  XX 0   , 0		 	;		= 51.  - Illegal
  XX 0   , 0		 	;		= 52.  - Illegal
  XX 0   , 0		 	;		= 53.  - Illegal
  XX 0   , 0		 	;		= 54.  - Illegal
  XX 0   , 0		 	;		= 55.  - Illegal
  XX 0   , 0		 	;		= 56.  - Illegal
  XX 0   , 0		 	;		= 57.  - Illegal
  XX 0   , 0		 	;		= 58.  - Illegal
  XX 0   , 0		 	;		= 59.  - Illegal
  XX 0   , 0		 	;		= 60.  - Illegal
  XX 0   , 0		 	;		= 61.  - Illegal
  XX 0   , 0		 	;		= 62.  - Illegal
  XX 0   , 0		 	;		= 63.  - Illegal
  XX 0   , 0		 	;		= 64.  - Illegal
  XX 0   , 0		 	;		= 65.  - Illegal
  XX 0   , 0		 	;		= 66.  - Illegal
  XX 0   , 0		 	;		= 67.  - Illegal
  XX 0   , 0		 	;		= 68.  - Illegal
  XX 0   , 0		 	;		= 69.  - Illegal
  XX 0   , 0		 	;		= 70.  - Illegal
  XX 0   , 0		 	;		= 71.  - Illegal
  XX 0   , 0		 	;		= 72.  - Illegal
  XX 0   , 0		 	;		= 73.  - Illegal
  XX 0   , 0		 	;		= 74.  - Illegal
  XX 0   , 0		 	;		= 75.  - Illegal
  XX 0   , 0		 	;		= 76.  - Illegal
  XX 0   , 0		 	;		= 77.  - Illegal
  XX 0   , 0		 	;		= 78.  - Illegal
  XX 0   , 0		 	;		= 79.  - Illegal
  XX 0   , 0		 	;		= 80.  - Illegal
  XX 0   , 0		 	;		= 81.  - Illegal
  XX 0   , 0		 	;		= 82.  - Illegal
  XX 0   , 0		 	;		= 83.  - Illegal
  XX 0   , 0		 	;		= 84.  - Illegal
  XX 0   , 0		 	;		= 85.  - Illegal
  XX 0   , 0		 	;		= 86.  - Illegal
  XX 0   , 0		 	;		= 87.  - Illegal
  XX 0   , 0		 	;		= 88.  - Illegal
  XX 0   , 0		 	;		= 89.  - Illegal
  XX 0   , 0		 	;		= 90.  - Illegal
  XX 0   , 0		 	;		= 91.  - Illegal
  XX 0   , 0		 	;		= 92.  - Illegal
  XX 0   , 0		 	;		= 93.  - Illegal
  XX 0   , 0		 	;		= 94.  - Illegal
  XX 0   , 0		 	;		= 95.  - Illegal
  XX HEXV, IOPAR_DSKFSTYPE	;XFPAR_FSTYPE   = 96.  - File system type
  XX HEXV, IOPAR_DSKSECTSIZE	;XFPAR_SECTSIZE = 97.  - Sector size
  XX HEXV, IOPAR_DSKCLSSIZE 	;XFPAR_CLSSIZE  = 98.  - Cluster size
  XX HEXV, IOPAR_DSKTTLSPACE	;XFPAR_TTLSPACE = 99.  - Total space
  XX HEXV, IOPAR_DSKAVLSPACE	;XFPAR_AVLSPACE = 100. - Available space
  XX HEXV, IOPAR_DSKNUMHEAD 	;XFPAR_NUMHEAD  = 101. - Number of heads
  XX HEXV, IOPAR_DSKNUMSECT 	;XFPAR_NUMSECT  = 102. - Number of sectors
  XX HEXV, IOPAR_DSKNUMCYLN 	;XFPAR_NUMCYLN  = 103. - Number of cylinders
	.ENDM

	.MACRO	XX type, parm
	.WORD	parm
	.ENDM

	.MOD	4
xfp2xos:XFPAR
PARMMAX=!$-xfp2xos-1

	.MACRO	XX type, parm
.IF NE parm
	.BYTE	REP_'type	
.IFF
	.BYTE	0
.ENDC
	.ENDM

xfp2rep:XFPAR

	.MOD	4
xos2xfp:
	.LONG	xos2xfpgen	;IOPAR_xxxxxx = 00xx - Generic IO parameters
	.LONG	xos2xfpfil	;IOPAR_FILxxx = 01xx - File system IO parameters
	.LONG	0		;IOPAR_TRMxxx = 02xx - Terminal IO parameters
	.LONG	xos2xfpdsk	;IOPAR_DSKxxx = 03xx - Disk IO parameters
XOSMAX=!{$-xos2xfp}/4


	.BYTE	XOSGENMAX
xos2xfpgen:
	.BYTE	0		;		   = 0000h
	.BYTE	XFPAR_FILOPTN	;IOPAR_FILOPTN     = 0001h
	.BYTE	XFPAR_FILSPEC	;IOPAR_FILSPEC     = 0002h
	.BYTE	XFPAR_DEVSTS	;IOPAR_DEVSTS      = 0003h
	.BYTE	XFPAR_UNITNUM	;IOPAR_UNITNUM     = 0004h
	.BYTE	XFPAR_GLBID	;IOPAR_GLBID       = 0005h
	.BYTE	0		;IOPAR_DELAY       = 0006h
	.BYTE	0		;IOPAR_TIMEOUT     = 0007h
	.BYTE	0		;IOPAR_INPSTS      = 0008h
	.BYTE	0		;IOPAR_OUTSTS      = 0009h
	.BYTE	0		;IOPAR_INPQLMT     = 000Ah
	.BYTE	0		;IOPAR_OUTQLMT     = 000Bh
	.BYTE	0		;IOPAR_SIGVECT1    = 000Ch
	.BYTE	0		;IOPAR_SIGVECT2    = 000Dh
	.BYTE	0		;IOPAR_SIGDATA     = 000Eh
	.BYTE	0		;IOPAR_NUMOPEN     = 000Fh
	.BYTE	0		;IOPAR_BUFRLMT	   = 0010h
XOSGENMAX=!{$-xos2xfpgen}

	.BYTE	XOSFILMAX
xos2xfpfil:
	.BYTE	0		;		   = 0100h
	.BYTE	XFPAR_DIRHNDL	;IOPAR_DIRHNDL     = 0101h
	.BYTE	XFPAR_SRCATTR	;IOPAR_SRCATTR     = 0102h
	.BYTE	XFPAR_FILATTR	;IOPAR_FILATTR     = 0103h
	.BYTE	XFPAR_DIROFS	;IOPAR_DIROFS      = 0104h
	.BYTE	XFPAR_ABSPOS	;IOPAR_ABSPOS      = 0105h
	.BYTE	XFPAR_RELPOS	;IOPAR_RELPOS      = 0106h
	.BYTE	XFPAR_EOFPOS	;IOPAR_EOFPOS      = 0107h
	.BYTE	0		;		   = 0108h
	.BYTE	XFPAR_LENGTH	;IOPAR_LENGTH      = 0109h
	.BYTE	XFPAR_REQALLOC	;IOPAR_REQALLOC    = 010Ah
	.BYTE	XFPAR_RQRALLOC	;IOPAR_RQRALLOC    = 010Bh
	.BYTE	XFPAR_GRPSIZE	;IOPAR_GRPSIZE     = 010Ch
	.BYTE	XFPAR_ADATE	;IOPAR_ADATE       = 010Dh
	.BYTE	XFPAR_CDATE	;IOPAR_CDATE       = 010Eh
	.BYTE	XFPAR_MDATE	;IOPAR_MDATE       = 010Fh
	.BYTE	XFPAR_PROT	;IOPAR_PROT        = 0110h
	.BYTE	XFPAR_OWNER	;IOPAR_OWNNAME     = 0111h
	.BYTE	0		;		   = 0112h
	.BYTE	XFPAR_SETLOCK	;IOPAR_SETLOCK     = 0113h
	.BYTE	XFPAR_CLRLOCK	;IOPAR_CLRLOCK     = 0114h
	.BYTE	0		;IOPAR_CLSTIME     = 0115h
	.BYTE	0		;IOPAR_CLSNAME     = 0116h
	.BYTE	0		;IOPAR_CLSMSG      = 0117h
	.BYTE	XFPAR_SHRPARMS	;IOPAR_SHRPARMS    = 0118h
XOSFILMAX=!{$-xos2xfpfil}

	.BYTE	XOSDSKMAX
xos2xfpdsk:
	.BYTE	0		;		   = 0300h
	.BYTE	XFPAR_FSTYPE	;IOPAR_DSKFSTYPE   = 0301h
	.BYTE	XFPAR_SECTSIZE	;IOPAR_DSKSECTSIZE = 0302h
	.BYTE	XFPAR_CLSSIZE	;IOPAR_DSKCLSSIZE  = 0303h
	.BYTE	XFPAR_TTLSPACE	;IOPAR_DSKTTLSPACE = 0304h
	.BYTE	XFPAR_AVLSPACE	;IOPAR_DSKAVLSPACE = 0305h
	.BYTE	XFPAR_NUMHEAD	;IOPAR_DSKNUMHEAD  = 0306h
	.BYTE	XFPAR_NUMSECT	;IOPAR_DSKNUMSECT  = 0307h
	.BYTE	XFPAR_NUMCYLN	;IOPAR_DSKNUMCYLN  = 0308h
XOSDSKMAX=!{$-xos2xfpdsk}

BITS=!{1<REP_DECV}+{1<REP_HEXV}+{1<REP_OCTV}+{1<REP_BINV}+{1<REP_VERN}
BITS=!BITS+{1<REP_TIME}+{1<REP_DATE}+{1<REP_DT}

	.MOD	4
valmask:.LONG	BITS

	.PSECT	_TEXT_p
.PAGE
	.SBTTL	outputdone - Software interrupt routine for TCP output complete

;Software interrupt routine for TCP output complete - all this routine does
;  is queue another TCP input

outputdone:
	PUSHAL				;Save registers
	MOVL	EDI, 64t[ESP]		;Get offset of the CDB
	CMPL	cdb_tcpqab+qab_error[EDI], #0.B ;Error on output?
	JS	tcperr			;Yes
	CMPL	cdb_reqtotal[EDI], #0	;No - need to finish an input request?
	JNE	datreq2			;Yes
outputdon2:
	CALL	qinput
	POPAL				;Restore registers
	CALLF	svcSchDismiss#		;And dismiss
.PAGE
	.SBTTL	diskdone - Software interrupt routine for disk IO complete

;Subroutine software interrupt routine for disk IO complete

diskdone:
	PUSHAL				;Save registers
	MOVL	EDI, 64t[ESP]		;Get offset of the CDB
	SUBL	EDI, #cdb_diskqab.B
	JMPIL	cdb_diskdsp[EDI]	;Dispatch on the current state
.PAGE
	.SBTTL	setresp - Subroutine to set up the response message

;Subroutine to set up the response message
;	CALL	setresp
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

setresp:LEAL	ESI, cdb_buffer+4[EDI]	;Point to place to put item count
	MOVB	-2t[ESI], #XFPOF_RESPONSE
	MOVL	EAX, cdb_diskqab+qab_amount[EDI]
	MOVB	DL, cdb_curhndl[EDI]	;Get XFP channel number
	INCL	EDX
	BTZL	EAX, #31t		;Continued response?
	JC	2$			;Yes
	ORB	DL, #10h		;No - set final bit
2$:	MOVB	-1t[ESI], DL
	CMPL	cdb_diskqab+qab_error[EDI], #0 ;Did this work?
	JGE	4$			;Yes
	ORB	-1t[ESI], #80h		;No
	MOVL	ECX, cdb_diskqab+qab_error[EDI] ;Get error code
	XCHGB	CL, CH			;Fix up the byte order
	RORL	ECX, #16t
	XCHGB	CL, CH
	MOVL	[ESI], ECX		;Store it in the message
	ADDL	ESI, #4.B
4$:	CALL	putvalue		;Store item count
	CLRL	EAX
	MOVL	cdb_tcpqab+qab_parm+0[EDI], EAX
	CMPL	cdb_diskqab+qab_parm+0[EDI], #0.B ;Have any parameters?
	JE	6$			;No - go on
	CALL	storeparms		;Yes - store parameters in the response
	JC	ret020			;If error
6$:	LEAL	EAX, cdb_buffer[EDI] ;Calculate length of the response
	MOVL	cdb_tcpqab+qab_buffer1+0[EDI], EAX
	SUBL	ESI, EAX
	MOVL	cdb_tcpqab+qab_count[EDI], ESI ;Store it in the QAB
	LEAL	EAX, -4[ESI]		;And store it as the header count
	XCHGB	AL, AH
	MOVW	cdb_buffer[EDI], AX
ret020:	RET
.PAGE
	.SBTTL	storeparms - Subroutine to store parameters into the reply

;Subroutine to store parameters into the reply message
;	c{ESI} = Pointer to reply message
;	CALL	storeparms
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

storeparms:
	MOVL	EBX, cdb_diskqab+qab_parm+0[EDI]
	MOVL	cdb_tcpqab+qab_parm+0[EDI], EAX
4$:	MOVB	AL, [EBX]		;Get bits and representation
	TESTB	AL, AL			;Finished?
	JE	ret020			;Yes
	MOVZBL	EDX, 3[EBX]		;No - get parameter page number
	CMPL	EDX, #XOSMAX
	JAE	65$
	MOVL	EDX, xos2xfp[EDX*4]
	MOVZBL	ECX, 2[EBX]
	CMPB	CL, -1[EDX]
	JAE	65$
	MOVB	DL, [EDX+ECX]		;Get XFP value
	MOVB	[ESI], DL		;Store index in response
	MOVB	AH, AL
	ANDB	AH, #0Fh
	CMPB	AH, #REP_STR		;Is it a string?
	JE	20$			;Yes
	MOVZBL	ECX, 1[EBX]		;No - get length
	TESTB	AL, #PAR$GET		;Getting the value?
	JNE	6$			;Yes - always return it
	TESTB	AL, #PAR$ERROR		;No - error indicated?
	JE	7$			;No - skip this parameter
6$:	CALL	strlength		;Store it
	TESTB	AL, #PAR$ERROR		;Error indicated?
	JE	8$			;No
	ADDL	EBX, ECX		;Yes - skip the value
	JMP	4$			;Continue

65$:	MOVL	EAX, #ER_NPERR
	STC
	RET

;Here if want to skip this parameter

7$:	LEAL	EBX, 4[EBX+ECX]
	JMP	4$

;Here to store parameter

8$:	JREGZ	ECX, 4$
	MOVZBL	EAX, AH
	BTL	valmask, EAX		;Should we invert the byte order?
	JNC	12$			;No
	ADDL	ESI, ECX		;Yes

;CHECK LIMITS HERE

	PUSHL	ESI
10$:	MOVB	AL, [EBX]		;Get a value byte
	INCL	EBX
	DECL	ESI
	MOVB	[ESI], AL		;Store it
	LOOP	ECX, 10$
	POPL	ESI
	JMP	4$

;Here if to not need to invert byte order for the value

12$:

;CHECK LIMITS HERE

14$:	MOVB	AL, [EBX]
	INCL	EBX
	MOVB	[ESI], AL
	INCL	ESI
	LOOP	ECX, 14$
	JMP	4$

;Here if have string value

20$:	TESTB	AL, #PAR$GET		;Getting the value?
	JNE	22$			;Yes - always return it
	TESTB	AL, #PAR$ERROR		;No - error indicated?
	JE	26$			;No - skip this parameter
22$:	MOVZWL	ECX, 14t[EBX]		;Get length of the string returned
	CALL	strlength		;Store it
	TESTB	AL, #PAR$ERROR		;Error indicated?
	JNE	24$			;Yes - skip the value
	PUSHL	EDI
	MOVL	EDI, ESI
	MOVL	ESI, [EBX]		;Get offset of the string buffer
	CLD
	RMOVSB	[EDI], [ESI]		;Copy string to response
	MOVL	ESI, EDI
	POPL	EDI
24$:	ADDL	EBX, #12t.B		;Bump pointer
	JMP	4$			;Continue

26$:	ADDL	EBX, #16t.B
	JMP	4$
.PAGE
;	c(AL)  = Representation and bits
;	c{EBX} = Offset of parameter header byte
;	c{ECX} = Length of value
;	c{ESI} = Pointer to index value in response
;	CALL	strlength
;	c{EBX} = Updated pointer
;	c{ECX} = Amount to store
;	c{ESI} = Updated pointer

strlength:
	ANDB	AL, #0E0h
	TESTB	AL, #PAR$ERROR		;Error indicated?
	JNE	10$			;Yes
	CMPL	ECX, #0Fh.B
	JA	6$
	ORB	AL, CL
	MOVB	1[ESI], AL
	JMP	8$

6$:	ORB	AL, CH
	ORB	AL, #10h
	MOVB	1[ESI], AL
	MOVB	2[ESI], CL
	INCL	ESI
8$:	ADDL	ESI, #2.B
	ADDL	EBX, #4.B
	RET

;Here if error indicated

10$:	MOVB	1[ESI], AL
	JMP	8$
.PAGE
;Subroutine to log a message
;	c{EBX} = Offset of initial string
;	c{ECX} = Number of bytes
;	c{EDX} = Offset of function table
;	CALL	logmsg

$$$=!0
FRM log_size  , 4t
FRM log_table , 4t
FRM log_count , 4t
FRM log_begin , 4t
FRM log_buffer, 200t
log_SIZE=!$$$

logmsg:	PUSHL	ESI
	ENTER	log_SIZE
	MOVL	log_table[EBP], EDX
	LEAL	ESI, log_buffer[EBP]
	MOVL	log_size[EBP], ECX
	PUSHL	ECX
	PUSHL	cdb_number[EDI]
	PUSHL	EBX
	PUSHL	#log1fmt
	PUSHL	ESI
	CALL	sprintf#
	ADDL	ESP, #20t.B
	ADDL	ESI, EAX
	MOVL	EBX, log_table[EBP]	;Restore offset of function table
	MOVL	EAX, cdb_tcpqab+qab_buffer1[EDI]
	MOVB	AL, [EAX]		;Get function value
	ANDL	EAX, #0Fh.B
	MOVL	EDX, [EBX+EAX*8]
	MOVL	[ESI], EDX
	MOVL	EAX, 4[EBX+EAX*8]
	MOVL	4[ESI], EAX
	ADDL	ESI, #8t.B
	JMP	4$

;Here if function not in the table

2$:	PUSHL	EAX
	PUSHL	#log2fmt
	PUSHL	ESI
	CALL	sprintf#
	ADDL	ESP, #12t.B
	ADDL	ESI, EAX
4$:

;;; CODE HERE TO DISPLAY MESSAGE FLAGS

	MOVW	[ESI], #LF
	PUSHL	srvDebugStream#
	LEAL	EAX, log_buffer[EBP]
	PUSHL	EAX
	CALL	fputs#
	ADDL	ESP, #8t.B
	CMPL	log_size[EBP], #0.B	;Have 0 length message?
	JE	12$			;Yes - finished
	CMPB	srvDebugLevel#, #2	;Want short form?
	JA	6$			;No
	CMPL	log_size[EBP], #16t.B	;Yes - is message too long?
	JBE	6$			;No
	MOVL	log_size[EBP], #16t	;Yes - only display 16 bytes
6$:	MOVL	EBX, cdb_tcpqab+qab_buffer1[EDI] ;Point to the buffer
8$:	MOVL	log_begin[EBP], EBX
	PUSHL	EBX
	LEAL	ESI, log_buffer[EBP]
	PUSHL	#strnl
	PUSHL	ESI
	CALL	strmov#
	ADDL	ESP, #8t.B
	MOVL	ESI, EAX
	POPL	EBX
	MOVB	log_count[EBP], #0
10$:	MOVZBL	EAX, [EBX]
	INCL	EBX
	PUSHL	EBX
	PUSHL	EAX
	PUSHL	#log3fmt
	PUSHL	ESI
	CALL	sprintf#
	ADDL	ESP, #12t.B
	ADDL	ESI, EAX
	POPL	EBX
	INCL	log_count[EBP]	;Count the item
	DECL	log_size[EBP]		;More to display?
	JE	12$			;No
	CMPB	log_count[EBP], #16t	;Yes - need new line?
	JB	10$			;No
12$:	LEAL	ECX, log_buffer+62t[EBP] ;Fill current line with spaces to the
14$:	CMPL	ESI, ECX		 ;  position for the text part
	JAE	16$
	MOVB	[ESI], #' '
	INCL	ESI
	JMP	14$

16$:	MOVL	EBX, log_begin[EBP]
	CLRL	ECX
18$:	MOVB	AL, [EBX]
	INCL	EBX
	CMPB	AL, #' '
	JB	20$
	CMPB	AL, #0FFh
	JNE	22$
20$:	MOVB	AL, #'.'
22$:	MOVB	[ESI], AL
	INCL	ESI
	INCL	ECX
	CMPB	CL, log_count[EBP]
	JB	18$
	MOVW	[ESI], #LF
	PUSHL	EBX
	PUSHL	srvDebugStream#
	LEAL	EAX, log_buffer[EBP]
	PUSHL	EAX
	CALL	fputs#
	ADDL	ESP, #8t.B
	POPL	EBX
	CMPL	log_size[EBP], #0.B
	JNE	8$
	LEAVE
	POPL	ESI
	RET

log1fmt:.ASCIZ	"%s%2d%6d "
log2fmt:.ASCIZ	"%7d"
log3fmt:.ASCIZ	" %02.2X"
.PAGE
	.SBTTL	Data

	.PSECT	_DATA_p

prgname:: .ASCIZ "XFPNSRV"
srvname:: .ASCIZ "XFPNServer"

toolngmsg:.ASCIZ "Device name is too long"
tcperrmsg:.ASCIZ "Cannot open TCP device"
opnemsg2: .ASCIZ "Error opening pending TCP device"
opnemsg:  .ASCIZ "Error queueing open"
qinmsg:	  .ASCIZ "Error queueing TCP input"
nomcdbmsg:.ASCIZ "Cannot allocate memory for CDB"
nocdbsmsg:.ASCIZ "Too many files open"

confmt:	.ASCIZ	"CON:%2d"{LF}
rerfmt:	.ASCIZ	"ERR:%2d %X %d"{LF}
clrfmt:	.ASCIZ	"CLR:%2d %X %d"{LF}
cbgfmt:	.ASCIZ	"CBG:%2d %X %d"{LF}
cdnfmt:	.ASCIZ	"CDN:%2d %X %d"{LF}


strtcpi: .ASCIZ	"INP:"
strtcpo: .ASCIZ	"OUT:"




strnl:	 .ASCIZ "         "

	 .MOD	4
version::.LONG	VERSION
editnum::.LONG	EDITNUM
numcon:  .LONG	0
instance:.LONG	0
cmdpntr: .LONG	0, 0

instx:	.LONG	0		;Instance existance bit table

	.MOD	4
tablei:	.ASCII	"0       "	; 0
	.ASCII	"OPEN    "	; 1 - Open file
	.ASCII	"PARM    "	; 2 - Parameter function
	.ASCII	"CLOSE   "	; 3 - Close file
	.ASCII	"COMMIT  "	; 4 - Commit data
	.ASCII	"DELETE  "	; 5 - Delete file
	.ASCII	"RENAME  "	; 6 - Rename file
	.ASCII	"7       "	; 7
	.ASCII	"DATA    "	; 8 - Data
	.ASCII	"DATAREQ "	; 9 - Data request
	.ASCII	"10      "	;10
	.ASCII	"11      "	;11
	.ASCII	"12      "	;12
	.ASCII	"13      "	;13
	.ASCII 	"14      "	;14
	.ASCII	"15      "	;15


	.MOD	4
tableo:	.ASCII	"0       "	; 0
	.ASCII	"RESPONSE"	; 1 - Normal response
	.ASCII	"ERROR   "	; 2 - Error response
	.ASCII	"3       "	; 3
	.ASCII	"4       "	; 4
	.ASCII	"5       "	; 5
	.ASCII	"6       "	; 6
	.ASCII	"7       "	; 7
	.ASCII	"DATA    "	; 8 - Data
	.ASCII	"DATARESP"	; 9 - Data response
	.ASCII	"10      "	;10
	.ASCII	"11      "	;11
	.ASCII	"12      "	;12
	.ASCII	"13      "	;13
	.ASCII	"14      "	;14
	.ASCII	"15      "	;15

	  .MOD   4
notoparm: .BYTE  PAR$SET|REP_DECV, 4 ;Parameters for IO without timeout
	  .WORD  IOPAR_TIMEOUT
	  .LONG  -1
	  .BYTE  0

cnomsg:   .ASCIZ "Cannot open TCP device"

tcpname:  .BLKB  12t
tcpspec:  .BLKB  16t

nottcpmsg:.ASCIZ "Device is not an TCP class device"

	  .MOD   4

tcpdev:   .BLKB  20t
phyname:  .BLKB  32t

	  .MOD   4
openparms:.BYTE	 PAR$GET|REP_TEXT, 8 ;Parameters for initial check of TCP
	  .WORD	 IOPAR_CLASS	     ;   device
devclass: .BLKB  8t
	  .BYTE  PAR$SET|REP_HEXV, 4
	  .WORD	 IOPAR_FILOPTN
	  .LONG  FO$XOSNAME
	  .BYTE  PAR$GET|REP_STR, 0
	  .WORD  IOPAR_FILSPEC
	  .LONG  phyname
	  .LONG  !phyname
	  .WORD  12t
phylength:.WORD  0
	  .BYTE  PAR$SET|REP_DECV, 4
	  .WORD  IOPAR_NETCONLIMIT
numopen:  .LONG  0
	  .BYTE  PAR$SET|REP_HEXV, 4
	  .WORD  IOPAR_NETLCLPORT
tcpport:  .LONG  0
	  .BYTE  0
