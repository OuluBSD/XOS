	.TITLE	vesaadev - Loadable driver extensions for VESA compliant displays

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

	.PROC	80486
	.INCLUD	XOSINC:\XMAC\XOS.PAR
	.INCLUD	XOSINC:\XMAC\XOSX.PAR
	.INCLUD	XOSINC:\XMAC\XOSERR.PAR
	.INCLUD	XOSINC:\XMAC\XOSDOS.PAR
	.INCLUD	XOSINC:\XMAC\XOSTRM.PAR
	.INCLUD	XOSINC:\XMAC\XOSXTRM.PAR
	.INCLUD	XOSINC:\XMAC\PCAT.PAR
	.INCLUD	XOSINC:\XMAC\XOSLKE.PAR
	.INCLUD	XOSINC:\XMAC\XOSXLKE.PAR
	.INCLUD	VGAADRV.PAR
	.INCLUD	VBE.PAR

;This LKE provides routines to use the VESA VBE to initialize a compliant
;  display adapter for linear graphics modes.  This driver may be used alone
;  to provide minimal graphics support for any VESA compliant card (no
;  acceration, software graphics cursor) or with an LKE for a specific card
;  which implements acceration and a hardware graphics cursor.  It must be
;  loaded after the standard VGA driver (VGAADRV) is loaded and before any
;  card specific extension drivers are loaded.  Note that only one VGA
;  extension driver and only one card specific extension driver can be loaded.

;This LKE only supports PCI and AGP boards.

MAJV   =!1t
MINV   =!0t
EDITNUM=!0t

;Define offsets for modetbl entries

$$$=!0
BLK mtbl_vesamode , 4t
BLK mtbl_xosmode  , 1t
BLK               , 3t
BLK mtbl_fbufrpa  , 4t
BLK mtbl_maxpixclk, 4t
BLK mtbl_xres     , 4t
BLK mtbl_yres     , 4t
BLK mtbl_pgsize   , 4t
BLK mtbl_pixsize  , 4t
mtbl_SIZE=!$$$

MODETBLMAX=!40t

;Define offsets in the CRTCInfoBlock

$$$=!0
BLX crtc_htotal , 2t
BLX crtc_hsyncs , 2t
BLX crtc_hsynce , 2t
BLX crtc_vtotal , 2t
BLX crtc_vsyncs , 2t
BLX crtc_vsynce , 2t
BLX crtc_flags  , 1t
BLX crtc_clock  , 4t
BLX crtc_refresh, 2t
BLX             , 40t
crtc_SIZE=!$$$

	LKEHEAD  VESAADEV, MAJV, MINV, EDITNUM, LKETYPE_DEVICE

;Once-only initizliation routine

	INITSUB	vesaainit

$$$=!0
FRM vai_value  , 4t
FRM vai_iorpnt , 4t
FRM vai_colors , 4t		;Offset of color format info in the mode block
FRM vai_bufrpa , 4t
FRM vai_multpa , 1t
FRM            , 3t
FRM vai_pcib   , 4t
FRM vai_value  , 4t
FRM vai_dhdb   , 4t
FRM vai_modepnt, 4t
FRM vai_modecnt, 4t
vai_SIZE=!$$$

2$:	LEAVE
	RET

vesaainit:

	INT3

	ENTER	vai_SIZE, 0
	MOVL	EDI, #knlConDhdb##	;Get offset of the first DHDB
	CMPL	dhdb_dispname[EDI], #0
	JE	noconsole
	MOVL	vai_dhdb[EBP], EDI
	CLRL	EBX
	MOVL	vai_bufrpa[EBP], EBX
	MOVB	vai_multpa[EBP], BL
4$:	MOVL	vai_pcib[EBP], #0	;Find the display device
	LEAL	EAX, vai_pcib[EBP]
	PUSHL	EAX
	PUSHL	#3
	PUSHL	#0
	PUSHL	#0
	PUSHL	#0
	CALL	xospciFindByClass##
	TESTL	EAX, EAX
	JS	2$			;If not there

;Here with a device we know about - read the PCI configuration registers
;  to get the addresses we need.

	SHRL	EAX, #8
	MOVW	dhdb_pciaddr[EDI], AX	;Save the bus/device/function number
	MOVL	EBX, vai_pcib[EBP]
	MOVL	EAX, dct_pcidevid[EBX]
	MOVL	dhdb_pciid[EDI], EAX	;Save the device ID
	MOVL	ESI, vai_pcib[EBP]

;Scan the address blocks and register all IO areas

	MOVL	ECX, #6
	ADDL	EBX, #dct_pciaddr0
	MOVL	EDX, #iortblx

10$:	TESTB	[EBX], #0x01		;IO area?
	JE	12$			;No
	MOVZWL	EAX, [EBX]		;Yes
	ANDL	EAX, #0xFFFC		;Store base register number
	MOVW	2[EDX], AX
	MOVL	EAX, 4[EBX]		;Store size of block
	MOVW	[EDX], AX
	ADDL	EDX, #4
12$:	ADDL	EBX, #8
	LOOP	ECX, 10$

;;;	MOVL	dhdb_pgaddr[EDI], EAX
;;;	MOVL	dhdb_praddr[EDI], EAX
;;;	MOVL	dhdb_xioreg[EDI], EAX
.PAGE
;Get the VBE mode information

.IF NE 0
	MOVL	EDX, #dsprom
	MOVL	ECX, #0x8000
8$:	CMPL	[EDX], #'PMID'
	JE	10$
	INCL	EDX
	LOOP	ECX, 8$
10$:	INT3
.ENDC

	INT3

	MOVL	ECX, #0x2000
	CALL	knlRealBiosSetup##
	JC	initerror
	TOFORK
	MOVL	EBX, #realcode		;Execute a VBE function 0 in real mode
	MOVL	ECX, #rcsize		;  to obtain the basic Vesa VBE
	MOVL	EDX, #realregs		;  information
	MOVL	xrr_EAX[EDX], #0x4F00
	MOVL	xrr_ES[EDX], #0
	MOVL	xrr_EDI[EDX], #0x1000
	MOVL	0x1000+vbe_info_signature, #'VBE2'
	PUSHL	EDI
	MOVL	EDI, #iortbl
	CALL	knlExecReal##
	JC	initerrorff
	POPL	EDI
	FROMFORK
	CMPW	realregs+xrr_EAX, #0x004F ;Did it work?
	JNE	vbeerror		;No - can't go on!
	CMPL	1000h+vbe_info_signature, #'VESA' ;Is the data block correct?
	JNE	vbeerror
	MOVL	EAX, #1400h+vbe_mode_lnredmasksz ;Assume version 3.x
	CMPB	1000h+vbe_info_version + 1, #03 ;Right?
	JE	12$			;Yes
	CMPB	1000h+vbe_info_version + 1, #02 ;No - is it 2.x?
	JNE	vbeerror		;No - fail!
	ADDL	EAX, #vbe_mode_redmasksz-vbe_mode_lnredmasksz ;Yes
12$:	MOVL	vai_colors[EBP], EAX
	MOVZWL	EAX, 0x1000+vbe_info_memory ;Get total memory size
	SHLL	EAX, #16t
	MOVL	dhdb_gbfrsize[EDI], EAX
	JMP	getmodes

noconsole:
	MOVL	EAX, #ER_NOCON
	JMP	initerror

initerrorff:
	FROMFORK
	JMP	initerror

vbeerror:
	MOVL	EAX, #ER_PDTYP
initerror:
	LEAVE
	STC
	RET
.PAGE
;Now loop through all of the valid modes, determine which ones we might be
;  able to use, and build our mode table.

getmodes:
	MOVL	vai_modepnt[EBP], #modetbl
	MOVL	vai_modecnt[EBP], #MODETBLMAX
	MOVZWL	ESI, 0x1000+vbe_info_modelist+0
	CMPW	0x1000+vbe_info_modelist+2, #0xC000
	JNE	4$
;;;;;	PUSHL	#GS_BIOSCODE
;;;;;	POPL	FS
4$:	MOVL	EBX, #realcode		;Execute a VBE function 1 in real mode
	MOVL	ECX, #rcsize		;  to obtain mode information
	MOVL	EDX, #realregs
	MOVL	xrr_EAX[EDX], #0x4F01
	MOVZWL	EAX, [ESI]
	CMPW	AX, #0xFFFF		;End of list?
	JE	modesdone		;Yes - finished here
	MOVL	xrr_ECX[EDX], EAX
	MOVL	xrr_ES[EDX], #0
	MOVL	xrr_EDI[EDX], #0x1400
	TOFORK
;;;;;;	PUSHL	FS
	PUSHL	EDI
	MOVL	EDI, #iortbl
	CALL	knlExecReal##
	POPL	EDI
;;;;;;	POPL	FS
	FROMFORK
	CMPW	realregs+xrr_EAX, #0x004F ;Did it work?
	JNE	vbeerror		;No - can't go on!
	MOVB	AL, 0x1400+vbe_mode_attrib ;Is this is a valid RGB graphics
	NOTB	AL			     ;  mode?
	TESTB	AL, #VBE_ATTR_MODEOK|VBE_ATTR_COLOR|VBE_ATTR_GRAPHICS|VBE_ATTR_LINEAR
	JNE	30$			;No - skip it
	CMPB	0x1400+vbe_mode_memmodel, #VBE_MODEL_RGB ;Maybe
	JNE	30$			;No

;Now determine if it conforms to one of the pixel formats that we support

	MOVL	EBX, vai_colors[EBP]
	CMPB	0x1400+vbe_mode_bitsperpix, #32t ;Is this a 32-bit/pixel mode?
	JNE	10$			;No

;Here if have a 32-bit/pixel mode - We support 2 32-bit formats, both are
;  8-8-8-8. One is xRGB and the other is RGBx

;First determine that all elements are 8 bits

	CMPB	[EBX], #8
	JNE	30$
	CMPB	vbe_mode_grnmasksz-vbe_mode_redmasksz[EBX], #8
	JNE	30$
	CMPB	vbe_mode_blumasksz-vbe_mode_redmasksz[EBX], #8
	JNE	30$
	CMPB	vbe_mode_rsvmasksz-vbe_mode_redmasksz[EBX], #8
	JNE	30$

;Now determine that the elements are where we want them

	CMPB	vbe_mode_redmaskpos-vbe_mode_redmasksz[EBX], #24t
	JNE	8$

;If get here this must be RGBx

	CMPB	vbe_mode_grnmaskpos-vbe_mode_redmasksz[EBX], #16t
	JNE	30$
	CMPB	ES:vbe_mode_blumaskpos-vbe_mode_redmasksz[EBX], #8t
	JNE	30$
	CMPB	ES:vbe_mode_rsvmaskpos-vbe_mode_redmasksz[EBX], #0t
	JNE	30$
	MOVL	EAX, #DM_TCG24x
	JMP	20$

;If get here this must be xRGB

8$:	CMPB	vbe_mode_redmaskpos-vbe_mode_redmasksz[EBX], #16t
	JNE	30$
	CMPB	vbe_mode_grnmaskpos-vbe_mode_redmasksz[EBX], #8t
	JNE	30$
	CMPB	vbe_mode_blumaskpos-vbe_mode_redmasksz[EBX], #0t
	JNE	30$
	CMPB	vbe_mode_rsvmaskpos-vbe_mode_redmasksz[EBX], #24t
	JNE	30$
	MOVL	EAX, #DM_TCGx24
	JMP	20$

;Here if this is not a 32-bit/pixel mode

10$:	CMPB	1400h+vbe_mode_bitsperpix, #16t ;is this a 16-bit/pixel mode?
	JNE	30$			;No - can't use it!

;Here if have a 16-bit/pixel mode - We support 2 16-bit formats 1-5-5-5 (xRGB)
;  and 5-6-5 (RGB).

	CMPB	[EBX], #5
	JNE	30$
	CMPB	vbe_mode_blumasksz-vbe_mode_redmasksz[EBX], #5t
	JNE	30$
	CMPB	vbe_mode_blumaskpos-vbe_mode_redmasksz[EBX], #0t
	JNE	30$
	CMPB	vbe_mode_grnmaskpos-vbe_mode_redmasksz[EBX], #5t
	JNE	30$
	CMPB	vbe_mode_grnmasksz-vbe_mode_redmasksz[EBX], #5t
	JNE	14$

;If get here this must be 1-5-5-5 (xRGB)

	CMPB	vbe_mode_rsvmasksz-vbe_mode_redmasksz[EBX], #1t
	JNE	30$
	CMPB	vbe_mode_redmaskpos-vbe_mode_redmasksz[EBX], #10t
	JNE	30$
	CMPB	vbe_mode_rsvmaskpos-vbe_mode_redmasksz[EBX], #15t
	JNE	30$
	MOVL	EAX, #DM_HCGx15
	JMP	20$

;If get here this must be 5-6-5 (xRGB)

14$:	CMPB	vbe_mode_grnmasksz-vbe_mode_redmasksz[EBX], #6
	JNE	30$
	CMPB	vbe_mode_rsvmasksz-vbe_mode_redmasksz[EBX], #0
	JNE	30$
	CMPB	vbe_mode_redmaskpos-vbe_mode_redmasksz[EBX], #11t
	JNE	30$
	MOVL	EAX, #DM_HCG16

;Here if have a mode we can use

20$:	MOVL	EBX, vai_modepnt[EBP]
	MOVL	mtbl_xosmode[EBX], EAX	;Store the XOS mode
	MOVZWL	EAX, [ESI]		;Store the Vesa mode
	MOVL	mtbl_vesamode[EBX], EAX
	MOVZBL	ECX, 0x1400+vbe_mode_bitsperpix ;Get pixel size
	SHRL	ECX, #3
	MOVL	mtbl_pixsize[EBX], ECX
	MOVXWL	EAX, 0x1400+vbe_mode_xres ;Store the X resolution
	MOVL	mtbl_xres[EBX], EAX
	MOVXWL	EDX, 0x1400+vbe_mode_yres ;Store the Y resolution
	MOVL	mtbl_yres[EBX], EDX
	IMULL	EAX, ECX		;Convert to bytes
	IMULL	EAX, EDX		;Calculate page size
	ADDL	EAX, #0xFFFF		;Round up to 64KB boundry
	ANDL	EAX, #0xFFFF0000
	MOVL	mtbl_pgsize[EBX], EAX ;Store the page size
	MOVL	EAX, 0x1400+vbe_mode_maxpixelclk ;Store the maximum pixel
	MOVL	mtbl_maxpixclk[EBX], EAX	   ;  clock
	MOVL	EAX, 0x1400+vbe_mode_fbufrpa ;Store the phycial buffer
	MOVL	mtbl_fbufrpa[EBX], EAX		;  address
	CMPL	vai_bufrpa[EBP], EAX	;Same addres?
	JE	28$			;Yes
	CMPL	vai_bufrpa[EBP], #0	;First mode found?
	JNE	26$			;No
	MOVL	vai_bufrpa[EBP], EAX	;Yes - just store the address
	JMP	28$

26$:	MOVB	vai_multpa[EBP], #1	;Remember have different addresses
28$:	DECL	vai_modecnt[EBP]	;Have too many modes?
	JLE	modesdone		;Yes - stop now
	ADDL	vai_modepnt[EBP], #mtbl_SIZE ;No
30$:	ADDL	ESI, #2t		;Advance to next VBE mode entry
	JMP	4$
.PAGE
modesdone:
;;;;	INT3

	CMPL	vai_bufrpa[EBP], #0	;Did we find at least one usable mode?
	JE	vbeerror		;No - can't use it!


	MOVL	EDX, vai_modepnt[EBP]	;Get number of mode entries
	SUBL	EDX, #modetbl
	SHRL	EDX, #5
	DECL	EDX
	JE	8$			;If only one entry

2$:	MOVL	ECX, EDX
	MOVL	EBX, #modetbl	
4$:	MOVL	EAX, mtbl_xres[EBX]
	CMPL	EAX, mtbl_xres+mtbl_SIZE[EBX]
	JBE	6$
	MOVB	CH, #1
	XCHGL	EAX, mtbl_xres+mtbl_SIZE[EBX]
	MOVL	mtbl_xres[EBX], EAX

	MOVL	EAX, mtbl_vesamode[EBX]
	XCHGL	EAX, mtbl_vesamode+mtbl_SIZE[EBX]
	MOVL	mtbl_vesamode[EBX], EAX

	MOVL	EAX, mtbl_xosmode[EBX]
	XCHGL	EAX, mtbl_xosmode+mtbl_SIZE[EBX]
	MOVL	mtbl_xosmode[EBX], EAX

	MOVL	EAX, mtbl_fbufrpa[EBX]
	XCHGL	EAX, mtbl_fbufrpa+mtbl_SIZE[EBX]
	MOVL	mtbl_fbufrpa[EBX], EAX

	MOVL	EAX, mtbl_maxpixclk[EBX]
	XCHGL	EAX, mtbl_maxpixclk+mtbl_SIZE[EBX]
	MOVL	mtbl_maxpixclk[EBX], EAX

	MOVL	EAX, mtbl_yres[EBX]
	XCHGL	EAX, mtbl_yres+mtbl_SIZE[EBX]
	MOVL	mtbl_yres[EBX], EAX

	MOVL	EAX, mtbl_pgsize[EBX]
	XCHGL	EAX, mtbl_pgsize+mtbl_SIZE[EBX]
	MOVL	mtbl_pgsize[EBX], EAX

	MOVL	EAX, mtbl_pixsize[EBX]
	XCHGL	EAX, mtbl_pixsize+mtbl_SIZE[EBX]
	MOVL	mtbl_pixsize[EBX], EAX

6$:	ADDL	EBX, #mtbl_SIZE
	DECB	CL
	JNE	4$
	CMPB	CH, #0
	JNE	2$

;Here with the mode table sorted

8$:
;;;;	INT3

	MOVL	ECX, #xddb_SIZE		;Allocate an XDDB
	CALL	knlGetXMem##
	JC	initerror
	MOVL	ESI, EDI
	MOVL	EDI, vai_dhdb[EBP]
	MOVL	dhdb_dispname[EDI], #vesatype ;Store pointer to type string
	MOVL	dhdb_xddb[EDI], ESI
	LEAL	EBX, xddb_version[ESI]	;Store version number string
	MOVZBL	EAX, 1000+vbe_info_version+1
	CALL	knlPutDecNmbr##
	MOVB	[EBX], #'.'
	INCL	EBX
	MOVZBL	EAX, 1000+vbe_info_version+0
	CALL	knlPutDecNmbr##
	MOVB	[EBX], #0		;Store description string
	MOVZWL	EAX, 0x1000+vbe_info_oemstring+0
	MOVZWL	EDX, 0x1000+vbe_info_oemstring+2 
	SHLL	EDX, #4
	ADDL	EAX, EDX
	LEAL	EDI, xddb_desc[ESI]
	PUSHL	DS
	PUSHL	ES
	PUSHL	ESI
	MOVL	ESI, EAX
	MOVL	ECX, #64t/4
	RMOVSL	[EDI], [ESI]
	POPL	ESI
	MOVB	xddb_desc+63t[ESI], #0


getedid:

	TOFORK
	MOVL	EBX, #realcode		;Execute a VBE function 15 in real mode
	MOVL	ECX, #rcsize		;  to obtain the EDID data
	MOVL	EDX, #realregs
	MOVL	xrr_EAX[EDX], #4F15h
	MOVL	xrr_EBX[EDX], #0
	MOVL	xrr_ECX[EDX], #0
	MOVL	xrr_EDX[EDX], #0
	MOVL	xrr_ES[EDX], #0
	MOVL	xrr_ES[EDX], #0
	MOVL	xrr_EDI[EDX], #0	;;;1600h
	PUSHL	EDI
	MOVL	EDI, #iortbl
	CALL	knlExecReal##
	POPL	EDI

;;;;	INT3

	JC	initerrorff
	FROMFORK
	CMPW	realregs+xrr_EAX, #004Fh ;Did it work?

;;; ADD STUFF HERE LATER!!!

.PAGE
;If all modes use the same physical buffer address we map it here once and
;  for all.  If different modes use a different address, we skip mapping
;  here.  The buffer will be mapped when the mode is set if necessary.

mapbufr:MOVL	EDI, vai_dhdb[EBP]
	CMPB	vai_multpa[EBP], #0	;Have a single address?
	JNE	10$			;No - skip this
	PUSHL	#graphdisp		;Virtual address
	MOVL	EAX, dhdb_gbfrsize[EDI] ;Number of pages to map
	SHRL	EAX, #12t
	PUSHL	EAX
	PUSHL	#MT_SYS			;Memory type
	PUSHL	#0x27			;Page map bits
	MOVL	EAX, vai_bufrpa[EBP]	;Physical address
	MOVL	dhdb_pgaddr[EDI], EAX
	PUSHL	EAX
	PUSHL	#-1			;Increment mask
	CALL	sysMemMapPhyPages##	;Map the pages
	JC	initerror		;If error

;Update all current TDBs for the display with our values

10$:	MOVL	dhdb_vgaddr[EDI], #graphdisp
	LEAL	EDX, dhdb_tdbtbl[EDI]
	MOVL	ECX, #VDSPMAX
12$:	MOVL	ESI, [EDX]
	ADDL	EDX, #4t
	TESTL	ESI, ESI
	JE	14$
	MOVL	tdb_vgaddr[ESI], #graphdisp
	MOVL	tdb_vraddr[ESI], #0
	MOVL	EAX, dhdb_gbfrsize[EDI]
	MOVL	tdb_gbfrsize[ESI], EAX
14$:	LOOP	ECX, 12$

;Now change the basic VGA driver's links to point to our routines

	MOVL	xosvgaSetGraphic##, #vesasetgraphic
	MOVL	xosvgaSetDHS##, #vesasetdhs
	MOVL	xosvgaSetPage##, #vesasetpage
	MOVL	xosvgaClrBuffer##, #vesaclrbuffer
	MOVL	xosvgaDsp##+tfx_setgvf, #vesasetgvf
	MOVL	xosvgaDsp##+tfx_getgvf, #vesagetgvf
	MOVL	xosvgaDsp##+tfx_getgcurpos, #vesagetcurpos
	MOVL	xosvgaDsp##+tfx_setgcurpos, #vesasetcurpos
	MOVL	xosvgaDsp##+tfx_setgcurcol, #vesasetcurcol
	MOVL	xosvgaDsp##+tfx_setgcurpat, #vesasetcurpat
	CLRL	EAX
	CLRL	EDX
	MOVL	ECX, #codetop
	LEAVE
	RET

	CODE
.PAGE
;Subroutine to do first part of setting to a graphic display mode - in this
;  case we attempt to make both the horizontal and vertical resolution at
;  least as great as specified.  Note that we only support whatever modes
;  are available from the VESA BIOS.  We support 4 XOS modes which specify
;  the color depth:
;    mode 2: hi-color   - 1-5-5-5 (xRGB) using 16 bits
;    mode 3: hi-color   - 5-6-5   (RGB)  using 16 bits
;    mode 4: true-color - 8-8-8-8 (xRGB) using 32 bits
;    mode 5: true-color - 8-8-8-8 (RGBx) using 32 bits
;  We DO NOT support any palette based modes!
;	CALL	vesasetgraphic
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

vesasetgraphic:
	MOVL	EBX, #modetbl
4$:	CMPL	[EBX], #0		;End of the table?
	JE	10$			;Yes
	MOVB	AL, adm_bits[EBP]	;No - is this entry the right mode?
	CMPB	mtbl_xosmode[EBX], AL
	JNE	6$			;No - skip it
	MOVL	EAX, adm_dv+dm_horiz[EBP] ;Get desired horizontal resolution
	CMPL	EAX, mtbl_xres[EBX]	;Is this config OK?
	JA	6$			;Yes
	MOVL	EAX, adm_dv+dm_vert[EBP] ;Get desired vertical resolution
	CMPL	EAX, mtbl_yres[EBX]	;Is this config OK?
	JBE	8$			;Yes
6$:	ADDL	EBX, #mtbl_SIZE		;No - go on
	JMP	4$

;Here with a usuable mode

8$:	MOVL	EAX, mtbl_xres[EBX]	;Store actual X and Y resolutions
	MOVL	tdb_horiz[ESI], EAX
	MOVL	EAX, mtbl_yres[EBX]
	MOVL	tdb_vert[ESI], EAX
	MOVL	EAX, mtbl_pgsize[EBX]
	MOVL	tdb_pgsize[ESI], EAX
	MOVB	AL, mtbl_pixsize[EBX]
	MOVB	tdb_pixsize[ESI], AL
	CLC
	RET

;Here if no usuable mode was found

10$:	MOVL	EAX, #ER_VALUE
	STC
ret008:	RET
.PAGE
;Subroutine to set extended registers for the current mode

vesasetdhs:
	PUSHL	EBX
	CMPB	tdb_mode[ESI], #DM_TEXT	;Want text mode?
	JA	10$			;No
	MOVL	EAX, tdb_dhdb[ESI]	;Yes
	CMPB	dhdb_hwmode[EAX], #DM_TEXT ;Currently in a text mode?
	JBE	4$			;Yes - nothing needed here
	MOVL	EAX, #3			;No - must switch to a text mode
	JMP	12$

4$:	POPL	EBX
	CLC
	RET

6$:	MOVL	EAX, #ER_DEVER
8$:	POPL	EBX
	STC
	RET

;Here if want a graphic mode

10$:	MOVL	EAX, tdb_table[ESI]	;Get the desired Vesa mode
	MOVL	EAX, mtbl_vesamode[EAX]
	ORB	AH, #0xC0
12$:	PUSHL	EAX
	MOVL	ECX, #0x2000
	CALL	knlRealBiosSetup##
	POPL	ECX
	JC	8$
	MOVL	EBX, #realcode
	MOVL	EDX, #realregs
	MOVL	xrr_EAX[EDX], #0x4F02	;Set the mode
	MOVL	xrr_EBX[EDX], ECX


	MOVL	xrr_ES[EDX], #0
	MOVL	xrr_EDI[EDX], #0x1400
.IF NE 0
	MOVW	0x1400+crtc_htotal, #0	;#1600t
	MOVW	0x1400+crtc_hsyncs, #0	;1400t
	MOVW	0x1400+crtc_hsynce, #0	;1500t
	MOVW	0x1400+crtc_vtotal, #0	;1084t
	MOVW	0x1400+crtc_vsyncs, #0	;1044t
	MOVW	0x1400+crtc_vsynce, #0	;1064t
	MOVB	0x1400+crtc_flags, #0
	MOVL	0x1400+crtc_clock, #130000000t
	MOVW	0x1400+crtc_refresh, #6500t
.ENDC
	MOVL	ECX, #rcsize
	PUSHL	EDI
	MOVL	EDI, #iortbl
	CALL	knlExecReal##
	POPL	EDI
	CMPW	realregs+xrr_EAX, #0x004F ;Did it work?
	JNE	6$			;No
	MOVL	EDX, tdb_dhdb[ESI]	;Yes - update current hardware mode
	MOVL	EAX, tdb_mode[ESI]
	MOVB	dhdb_hwmode[EDX], AL
	POPL	EBX
	RET
.PAGE
	.SBTTL	vesasetpage - Subroutine to set high order display start bits

;Subroutine to set graphic mode display start bits - This function will only
;  be called for a graphic mode.
;	c{EBX} = Display start value (bytes)
;	c{ESI} = Offset of TDB
;	CALL	vesasetpage

vesasetpage:
	MOVL	realregs+xrr_EAX, #4F07h
	MOVL	realregs+xrr_EBX, #0000h
	MOVL	EAX, EBX		;Convert byte offset to pixel offset
	CLRL	EDX
	MOVZBL	ECX, tdb_pixsize[ESI]
	IDIVL	ECX
	CLRL	EDX
	DIVL	tdb_horiz[ESI]		;Get row and column values
	MOVL	realregs+xrr_EDX, EAX
	MOVL	realregs+xrr_ECX, EDX
	MOVL	EDX, #realregs
	MOVL	EBX, #realcode
	MOVL	ECX, #rcsize
	PUSHL	EDI
	MOVL	EDI, #iortbl
	CALL	knlExecReal##
	POPL	EDI
	RET
.PAGE
	.SBTTL	vesaclrbuffer - Subroutine to clear the display buffer

;Subroutine to clear the display buffer
;	c{ESI} = Offset of TDB
;	CALL	vesaclrbuffer

vesaclrbuffer:
	MOVL	ECX, tdb_horiz[ESI]	;Get number of pixels in the buffer
	IMULL	ECX, tdb_vert[ESI]
	SHRL	ECX, #1t		;Change to number of longs to store
	CLRL	EAX
	MOVL	EDI, tdb_vgaddr[ESI]	;Get offset of the buffer
	PUSHL	DS
	POPL	ES
	CLD
	RSTOSL	[EDI]
	RET
.PAGE
	.SBTTL	vesasetgvf - Subroutine to set vertical frequency

;Subroutine to set vertical frequency
;	c{EAX} = Desired frequency
;	c{ESI} = Offset of TDB
;	CALL	vesasetgvf

vesasetgvf:
	CMPL	EAX, #80t		;Want highest possible frequency?
	JA	10$			;Yes


10$:	MOVB	tdb_vertfreq[ESI], #6
	RET

	.SBTTL	vesagetgvf - Subroutine to get vertical frequency

;Subroutine to set vertical frequence
;	c{ESI} = Offset of TDB
;	CALL	vesagetgvf
;	c{EAX} = Current value

vesagetgvf:
	MOVZBL	EAX, tdb_vertfreq[ESI]

	CLC
	RET
.PAGE
	.SBTTL	vesagetcurpos - Subroutine to get the current cursor postion

vesagetcurpos:
	MOVL	EAX, tdb_gcxpos[ESI]
	IFFAULT	knlRtnAdrEr##
	MOVL	ES:[EBX], EAX
	MOVL	EAX, tdb_gcypos[ESI]
	IFFAULT	knlRtnAdrEr##
	MOVL	ES:4[EBX], EAX
	MOVZBL	EAX, tdb_gcenable[ESI]
	RET

	.SBTTL	vesasetcurpos - Subroutine to set the cursor postion

;Subroutine to set the cursor postion
;	c{EAX} = Function bits
;	c{ECX} = X position
;	c{EDX} = Y position
;	c{ESI} = Offset of TDB
;	CALL	vesasetcurpos
;	C{EAX} = 0 if normal, negative error code if error

vesasetcurpos:


	RET
.PAGE
	.SBTTL	vesasetcurcol - Subroutine to get the cursor colors

;Subroutine to get the cursor colors (only the first two colors are used)
;	c{ECX}    = Number of colors to set
;	c{ES:EBX} = Address of color array
;	c{ESI}    = Offset of TDB
;	CALL	atisetcurcol
;	C{EAX} = 0 if normal, negative error code if error

vesasetcurcol:


	RET
.PAGE
	.SBTTL	vesasetcurpat - Subroutine to set the cursor pattern

;Subroutine to set the graphics cursor pattern - the graphics cursor is
;  left disabled
;	c(AL)  = Width
;	c(AH)  = Height
;	c(CL)  = X hot offset
;	c(CH)  = Y hot offset
;	c{EBX} = Address of pattern map
;	c{EDX} = Address of mask map
;	c{ESI} = Offset of TDB
;	CALL	vesasetcurpat
;	C{EAX} = 0 if normal, negative error code if error

;The bit-maps we are given are single pixel bit-maps with each line starting
;  at a byte boundry.

vesasetcurpat:
	MOVL	EAX, #ER_NIYT
	RET
.PAGE
vesatype:.ASCIZ "VESA VGA"

	DATA

;;ioports:.WORD	100h, 0FEF0h, 0, 0


modetbl:.BLKB	mtbl_SIZE*MODETBLMAX

	.SEG16

realcode:
	INT	10H
	HLT
	HLT
	.WORD	349h
rcsize=!{{$-realcode}+3}/4

	.SEG32

	.MOD	4
realregs:.BLKB	xrr_SIZE

	.MOD	2
iortbl:	.WORD	100, 0000
	.WORD	30 , 03B0
	.WORD	8  , 0CF8
	.WORD	100, 5000
iortblx:.BLKW	13t		;Allow for 6 expansion entires (there are up
				;  to 6 PCI address registers)

	LKEEND
