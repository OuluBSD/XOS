	.TITLE	hdkadev - Hard disk device driver type A

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

	.PROC	80486
	.INCLUD	XOSINC:\XMAC\XOS.PAR
	.INCLUD	XOSINC:\XMAC\XOSX.PAR
	.INCLUD	XOSINC:\XMAC\XOSERR.PAR
	.INCLUD	XOSINC:\XMAC\XOSTIME.PAR
	.INCLUD	XOSINC:\XMAC\PCAT.PAR
	.INCLUD	XOSINC:\XMAC\XOSXDISK.PAR
	.INCLUD	XOSINC:\XMAC\XOSDISK.PAR
	.INCLUD	XOSINC:\XMAC\XOSLKE.PAR
	.INCLUD	XOSINC:\XMAC\XOSXLKE.PAR
;;;;	.INCLUD	XOSINC:\XMAC\XOSXHDK.PAR

;This is the device driver for the standard PC/AT hard disk controller.

$$DSKWRITE=!0		;Set non-zero for write only debug posting
$$CHKLST  =!0		;Set to 1 to include code for checking buffer lists
			;  for debugging

MAJV   =!1t
MINV   =!0t
EDITNUM=!5t

;v1.0.0  17-JuL-94
;	Initial version
;v1.0.1  19-Jan-95
;	Added general support for extended IDE controllers (for > 0.5GB drives)
;	(this version also replaces HDKBDRV which provided temporary support
;	for large drives).  This version should support all combinations of
;	drive and BIOS parameter mapping provided the drive mapping is tight.
;	As far as we know, all large drives use tight mapping!  It will support
;	smaller (also, generally, older) drives which use loose mapping.  This
;	version uses the number of sector and number of head values from the
;	partition table block if they are consistent.
;v1.0.3  8-Jun-97
;	Added support for LBA mode for ATA-3 complient drives.
;v1.0.4  18-Nov-99
;	Removed the BOOT load-time characteristic (not needed since DISKINST
;	can now be executed during startup).
;v1.0.5  28-Dec-99
;	Fixed problem in block2pda, was not clearing C after divide, some CPUs
;	(not all) seem to randomly set C when dividing!

	LKEHEAD	HDKADEV, MAJV, MINV, EDITNUM, LKETYPE_DEVICE

;Determining disk configuration is a major problem due to the confusion between
;  the CMOS and boot partition parameters and due to the gradual shift from
;  using CMOS values to self-configuring IDE drives and eventually to ATA-3
;  complient drives.  This is made much more difficult because it is very
;  difficult to tell exactly what kind of drive we have.  There are basically
;  5 classes of drives in use:
;	ST-506 drives - These are the original PC drives and do not support
;		the get parameters command and cannot be reconfigured.
;	ESDI/fixed IDE drives - These drives do support the get parameters
;		command but cannot be reconfigured.
;	IDE drives with loose reconfiguration - These drives support the get
;		parameters command and can be reconfigured in a limited way.
;		Reconfiguration may result in lost capacity.
;	IDE drives with tight reconfiguration - These drives support the get
;		parameters command and can be fully reconfigured without loss
;		of capacity.
;	ATA-3 complient drives - These drives meet the ATA-3 (extended IDE)
;		specification.  In particular, they support LBA (Linear Block
;		Address) mode which eliminates all of the configuration issues.

;We initially use the CMOS (or the ADDUNIT characteristics values if not a
;  BIOS supported drive).  If we can get the actual drive parameter values,
;  we switch to using them as soon as we obtain them.  If we can read the
;  partition table, we use the sectors and heads value from the partition
;  table.  We calculate a number of cylinders value based on the total size
;  size obtained from the CMOS or the drive parameters.  If the drive reports
;  an LBA mode number of sectors, we assume the drive supports LBA mode and
;  use it.  Otherwise, if the partition table indicates more than 16 heads, we
;  remap the values to match what we can send to the drive.  Note that this
;  should only happen for a very few pre-ATA-3 large IDE drives.  It seems to
;  work in general, but there may be some cases where it will fail!

;Note that even with LBA drives, we still keep track of the drive parameter
;  values, even though they are not used when accessing the drive.  They are
;  reported as DEVCHAR values.  Also note that these values are not very
;  meaningful in this case and usually bear no relationship to the actual
;  phsycial disk configuration.

;In general, the values reported for physical units and partitions may not
;  be consistent, since the values for DOS partitions are updated from the
;  partition's boot block when a valid boot block is present.

;WARNING: Drives which cannot reconfigure will NOT WORK if the CMOS and/or
;  partition table values (whichever we wind up using) do not match the
;  actual physical disk parameters!  We DO NOT check for this, since we
;  have no sure way of knowing if a drive can reconfigure!!

;The initial values (ucb_isects, ucb_iheads, and ucb_icylns) always contain
;  the CMOS or physical (if available) values.  The current values (ucb_csects,
;  ucb_cheads, and ucb_ccylns) contain the values obtained from the partition
;  table.  If mapping is necessary, the mapped values are stored in ucb_hdmsects,
;  ucb_hdmheads, and ucb_hdmcylns.

;When a partition is set up, its initial and current values are both taken from
;  the underlying disk's current values.  Its mapped values (if needed) are
;  taken from the underlying disk's mapped values.

;Define time-out values (in seconds)

TO_RESTORE =!20t	;Restore time-out period
TO_SETPARMS=!2t		;Set drive parameters time-out period
TO_XFER    =!6t		;Data transfer time-out period
TO_RESET   =!20t	;Reset time-out period

	CODE

;Hard disk device driver dispatch table.  Note that kf_xxx entries are for
;  controller functions which require ownership of the controller. They must
;  be called only by passing their index to the xosdskTransfer routine. They
;  are all called with two arguments on the stack. The ks_xxx entires are for
;  general subroutines which do not require controller ownership.  They are
;  called directly with different numbers of arguments. They must NOT be
;  called through xosdskTransfer.

hdkdsp:	.LONG	0		;kf_init     =  0 - Initialize controller
	.LONG	hdkgetparms	;kf_getparms =  4 - Get drive parameters
	.LONG	hdkgetaparms	;kf_getaparms=  8 - Get ATAPI drive parameters
	.LONG	hdksetparms	;kf_setparms = 12 - Set drive parameters
	.LONG	hdkreadraw	;kf_readraw  = 16 - Read raw
	.LONG	hdkreaddata	;kf_readdata = 20 - Read block
	.LONG	hdkreadlist	;kf_readlist = 24 - Read buffer list
	.LONG	0		;kf_readid   = 28 - Read ID field
	.LONG	hdkwritraw	;kf_writraw  = 32 - Write raw
	.LONG	hdkwritdata	;kf_writdata = 36 - Write block
	.LONG	hdkwritlist	;kf_writlist = 40 - Write buffer list
	.LONG	hdkformat	;kf_format   = 44 - Format track
	.LONG	0		;kf_chkwp    = 48 - Check write protect status
	.LONG	hdkchkchgf	;kf_chkchg   = 52 - Check disk change status
	.LONG	hdkgettoc	;kf_gettoc   = 56 - Get CD-ROM TOC data
	.LONG	hdkgettrks	;kf_gettrks  = 60 - Get CD-ROM track data
	.LONG	hdkmedia	;ks_media    = 64 - Determine media type
	.LONG	knlRtnZero##	;ks_chkwp    = 68 - Check write protect status
	.LONG	hdkchkchg	;ks_chkchg   = 72 - Check disk changed status
	.LONG	hdksenchg	;ks_senchg   = 76 - Sense disk change status
	.LONG	hdkaaddunit	;ks_addunit  = 80 - Add disk unit
	.LONG	hdkremovebgn	;ks_removebgn = 84. - Begin removing disk
	.LONG	hdkremovefin	;ks_removefin = 88. - Finish removing disk

;Hard disk type A device characteristics table

	.MOD	4
hdkdchartbl:
 CHARBGN  1, sysIoCharValues##
 CHARENT  CLASS   , TEXT, ,   8, knlDcMsgClass##    , knlDcGetClass##  , knlDcSetClass##   , 0
 CHARENT  TYPE    , TEXT, ,   4, knlDcMsgType##     , knlDcGet4Byte##  , 0                 , dcb_typename
 CHARENT  IOREG   , HEXV, ,   2, knlDcMsgIoReg##    , xosdskGtU2Byte## , 0                 , ucb_ioreg1
 CHARENT  INDEX   , DECV, ,   1, knlDcMsgIndex##    , xosdskGtU1Byte## , 0                 , ucb_index
 CHARENT  INT     , DECV, ,   1, knlDcMsgInt##      , xosdskGtK1Byte## , 0                 , kcb_intlvl
 CHARENT  MODEL   , STR , ,  42, knlDcMsgModel##    , xosdskGtUStr##   , 0                 , ucb_model
 CHARENT  SERIALNO, STR , ,  42, knlDcMsgSerialNm## , xosdskGtUStr##   , 0                 , ucb_serialno
 CHARENT  REVISION, STR , ,  10, knlDcMsgRevision## , xosdskGtUStr##   , 0                 , ucb_revision
 CHARENT  CONFIG  , HEXV, ,   4, msgconfig          , xosdskGtU4Byte## , 0                 , ucb_hdconfig
 CHARENT  SECPINT , DECV, ,   4, msgsecpint         , xosdskGtU4Byte## , 0                 , ucb_hdsecpi
 CHARENT  BUFSIZE , DECV, ,   4, msgbufsize         , xosdskGtU4Byte## , 0                 , ucb_hdbufsz
 CHARENT  UNITTYPE, TEXT, ,   4, knlDcMsgUnitType## , xosdskUnitType## , 0                 , 0
 CHARENT  MSENSOR , TEXT, ,   4, xosdskMsgMSensor## , xosdskGetBits##  , 0                 , UB$MEDIAC
 CHARENT  REMOVE  , TEXT, ,   4, xosdskMsgRemove##  , xosdskGetRemove##, 0                 , 0
 CHARENT  READY   , TEXT, ,   4, xosdskMsgReady##   , getready         , 0                 , 0
 CHARENT  ATAPI   , TEXT, ,   4, msgatapi           , xosdskGetBits##  , 0                 , UB$ATAPI
 CHARENT  CMDRSP  , TEXT, ,   8, msgcmdrsp          , getcmdrsp        , 0                 , 0
 CHARENT  VOLNAME , TEXT, ,  16, xosdskMsgVolName## , xosdskGtU16Byte##, xosdskStU8Byte##  , ucb_volname
 CHARENT  DOSNAME , TEXT, ,  16, xosdskMsgDosName## , xosdskGtU16Byte##, xosdskSetDosName##, ucb_dosname
;;;; DCHARH    dosnmdc , xosdskGetHdDosNm##, xosdskFindDosNm##
;;;; CHARENT  PCCARD  , TEXT, ,  16, msgpccard          , getpccard        , setpccard         , 0
 CHARENT  PARTN   , HEXV, ,   1, xosdskMsgPartn##   , xosdskGtU1Byte## , 0                 , ucb_partnx
 CHARENT  PARTOFF , DECV, ,   4, xosdskMsgPartOff## , xosdskGtU4Byte## , 0                 , ucb_partnoff
 CHARENT  BASEDEV , STR , ,  20, xosdskMsgBaseDev## , xosdskGtBaseDev##, 0                 , 0
 CHARENT  CBLKSZ  , DECV, ,   2, xosdskMsgCBlkSz##  , xosdskGtU4Byte## , 0                 , ucb_csecsz
 CHARENT  CHEADS  , DECV, ,   1, xosdskMsgCHeads##  , xosdskGtU1Byte## , xosdskHdkSetHead##, ucb_cheads
 CHARENT  CSECTS  , DECV, ,   4, xosdskMsgCSects##  , xosdskGtU4Byte## , xosdskHdkSetSec## , ucb_csects
 CHARENT  CCYLNS  , DECV, ,   4, xosdskMsgCCylns##  , xosdskGtU4Byte## , xosdskHdkSetCyln##, ucb_ccylns
 CHARENT  CBLOCKS , DECV, ,   4, xosdskMsgCBlocks## , xosdskGtU4Byte## , 0                 , ucb_cblocks
 CHARENT  IBLKSZ  , DECV, ,   2, xosdskMsgIBlkSz##  , xosdskGtU4Byte## , xosdskStU4Byte##  , ucb_isecsz
 CHARENT  IHEADS  , DECV, ,   1, xosdskMsgIHeads##  , xosdskGtU1Byte## , xosdskStU1Byte##  , ucb_iheads
 CHARENT  ISECTS  , DECV, ,   4, xosdskMsgISects##  , xosdskGtU4Byte## , xosdskStU4Byte##  , ucb_isects
 CHARENT  ICYLNS  , DECV, ,   4, xosdskMsgICylns##  , xosdskGtU4Byte## , xosdskStU4Byte##  , ucb_icylns
 CHARENT  IBLOCKS , DECV, ,   4, xosdskMsgIBlocks## , xosdskGtU4Byte## , 0                 , ucb_iblocks
 CHARENT  LBAMODE , TEXT, ,   4, xosdskMsgLbaMode## , xosdskGetBits##  , 0                 , UB$LBA
 CHARENT  MSECTS  , DECV, ,   4, msgmsects          , xosdskGtU4Byte## , 0                 , ucb_hdmsects
 CHARENT  MHEADS  , DECV, ,   4, msgmheads          , xosdskGtU4Byte## , 0                 , ucb_hdmheads
 CHARENT  MCYLNS  , DECV, ,   4, msgmcylns          , xosdskGtU4Byte## , 0                 , ucb_hdmcylns
 CHARENT  WTMAX   , DECV, ,   4, knlDcMsgWTMax##    , xosdskGtU4Byte## , xosdskSetWTMax##  , ucb_wtmax
 CHARENT  RAMAX   , DECV, ,   4, knlDcMsgRAMax##    , xosdskGtU4Byte## , xosdskSetRAMax##  , ucb_ramax
 CHARENT  DTHLIMIT, DECV, ,   4, knlDcMsgDTHLimit## , xosdskGtU4Byte## , 0                 , ucb_dthlimit
 CHARENT  BLOCKIN , DECV, ,   4, xosdskMsgBlockIn## , xosdskGtU4Byte## , xosdskStU4Byte##  , ucb_blockin
 CHARENT  BLOCKOUT, DECV, ,   4, xosdskMsgBlockOut##, xosdskGtU4Byte## , xosdskStU4Byte##  , ucb_blockout
 CHARENT  BYTEIN  , DECV, ,   4, knlDcMsgByteIn##   , xosdskGtU4Byte## , xosdskStU4Byte##  , ucb_bytein
 CHARENT  BYTEOUT , DECV, ,   4, knlDcMsgByteOut##  , xosdskGtU4Byte## , xosdskStU4Byte##  , ucb_byteout
 CHARENT  SHRDELAY, DECV, ,   4, xosdskMsgShrDelay##, xosdskGtU4Byte## , xosdskStU4Byte##  , ucb_shrdelay
 CHARENT  SHRRETRY, DECV, ,   4, xosdskMsgShrRetry##, xosdskGtU4Byte## , xosdskStU4Byte##  , ucb_shrretry
 CHARENT  SHRFAIL , DECV, ,   4, xosdskMsgShrFail## , xosdskGtU4Byte## , xosdskStU4Byte##  , ucb_shrfail
 CHARENT  TDEVERR , DECV, ,   4, knlDcMsgTDevErr##  , xosdskGtU4Byte## , xosdskStU4Byte##  , ucb_tdeverr
 CHARENT  HDEVERR , DECV, ,   4, knlDcMsgHDevErr##  , xosdskGtU4Byte## , xosdskStU4Byte##  , ucb_hdeverr
 CHARENT  TDATAERR, DECV, ,   4, knlDcMsgTDataErr## , xosdskGtU4Byte## , xosdskStU4Byte##  , ucb_tdataerr
 CHARENT  HDATAERR, DECV, ,   4, knlDcMsgHDataErr## , xosdskGtU4Byte## , xosdskStU4Byte##  , ucb_hdataerr
 CHARENT  TSEEKERR, DECV, ,   4, xosdskMsgTSeekErr##, xosdskGtU4Byte## , xosdskStU4Byte##  , ucb_tseekerr
 CHARENT  HSEEKERR, DECV, ,   4, xosdskMsgHSeekErr##, xosdskGtU4Byte## , xosdskStU4Byte##  , ucb_hseekerr
 CHARENT  TIDFERR , DECV, ,   4, xosdskMsgTIdFErr## , xosdskGtU4Byte## , xosdskStU4Byte##  , ucb_tidferr
 CHARENT  HIDFERR , DECV, ,   4, xosdskMsgHIdFErr## , xosdskGtU4Byte## , xosdskStU4Byte##  , ucb_hidferr
 CHARENT  TRNFERR , DECV, ,   4, xosdskMsgTRNFErr## , xosdskGtU4Byte## , xosdskStU4Byte##  , ucb_trnferr
 CHARENT  HRNFERR , DECV, ,   4, xosdskMsgHRNFErr## , xosdskGtU4Byte## , xosdskStU4Byte##  , ucb_hrnferr
 CHARENT  TOVRNERR, DECV, ,   4, knlDcMsgTOvrnErr## , xosdskGtU4Byte## , xosdskStU4Byte##  , ucb_tovrnerr
 CHARENT  HOVRNERR, DECV, ,   4, knlDcMsgHOvrnErr## , xosdskGtU4Byte## , xosdskStU4Byte##  , ucb_hovrnerr
 CHARENT  HUNGERR , DECV, ,   4, knlDcMsgHungErr##  , xosdskGtU4Byte## , xosdskStU4Byte##  , ucb_hungerr
 CHARENT  UXINTERR, DECV, ,   4, xosdskMsgUnexpInt##, xosdskGtK4Byte## , xosdskStK4Byte##  , kcb_hduxint
 CHARENT  DISKID  , HEXV, ,   4, xosdskMsgDiskID##  , xosdskGtU4Byte## , 0                 , ucb_diskid
 CHARENT  PRTNTYPE, DECV, ,   1, xosdskMsgPrtnType##, xosdskGtU1Byte## , 0                 , ucb_prtntype
 CHARENT  FSTYPE  , TEXT, ,   8, xosdskMsgFSType##  , xosdskGtU8Byte## , 0                 , ucb_fsname
 CHARENT  CLSSZ   , DECV, ,   4, xosdskMsgClsSz##   , xosdskGtU4Byte## , 0                 , ucb_clussize
 CHARENT  CLUSTERS, DECV, ,   4, xosdskMsgClsters## , xosdskGtU4Byte## , 0                 , ucb_total
 CHARENT  AVAIL   , DECV, ,   4, xosdskMsgAvail##   , xosdskGtU4Byte## , 0                 , ucb_avail
 CHARENT  RESERVED, DECV, ,   4, xosdskMsgReserved##, xosdskGtU4Byte## , 0                 , ucb_ffatblk
 CHARENT  FATMODE , HEXV, ,   1, xosdskMsgFatMode## , xosdskGtU1Byte## , 0                 , ucb_fatmode
 CHARENT  DUPFAT  , TEXT, ,   4, xosdskMsgDupFat##  , xosdskGetBits##  , xosdskSetBits##   , UB$DUPFAT
 CHARENT  DEFER   , TEXT, ,   4, xosdskMsgDupFat##  , xosdskGetBits##  , xosdskSetBits##   , UB$DEFER
 CHARENT  FATSIZE , DECV, ,   4, xosdskMsgFatSize## , xosdskGtU4Byte## , 0                 , ucb_satsize
 CHARENT  NUMFATS , DECV, ,   4, xosdskMsgNumFats## , xosdskGtU4Byte## , 0                 , ucb_numsat
 CHARENT  ROOTCLS , DECV, ,   4, xosdskMsgRootBlk## , xosdskGtU4Byte## , 0                 , ucb_rootcls
 CHARENT  ROOTBLK , DECV, ,   4, xosdskMsgRootBlk## , xosdskGtU4Byte## , 0                 , ucb_rootblk
 CHARENT  ROOTSIZE, DECV, ,   4, xosdskMsgRootSize##, xosdskGtU4Byte## , 0                 , ucb_rootsize
 CHAREND

msgconfig: CHARINFO {Disk configuration bits}
msgatapi:  CHARINFO {ATAPI unit}
msgcmdrsp: CHARINFO {ATAPI command response type}
msgsecpint:CHARINFO {Maximum sectors per interrupt}
msgbufsize:CHARINFO {Size of internal disk buffer}
msgpsects: CHARINFO {Number of physical sectors reported by drive}
msgpheads: CHARINFO {Number of physical heads reported by drive}
msgpcylns: CHARINFO {Number of physical cylinders reported by drive}
msgmsects: CHARINFO {Number of mapped sectors reported by drive}
msgmheads: CHARINFO {Number of mapped heads reported by drive}
msgmcylns: CHARINFO {Number of mapped cylinders reported by drive}
;;;msgpccard: CHARINFO {Associated PC-card controller and socket}
.PAGE
	.SBTTL	Initialization

	ONCEDATA

	.MOD	4
hdkinitblk:					;Characteristics description
 CHARBGN  2, 0 					;  block for initialization
 CHARENT  RESULT, STR , , 0, 0, knlGetDcNullS##, 0        , 0
 CHAREND

	ONCE

;Initialization subroutine
;	c{EDX] = Address of characteristics list
;	CALL	inithdka
;	C:set = Error code
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{ECX} = Offset of first code byte to not save
;	  c{EDX} = Offset of first data byte to not save

inithdka:
	PUSHL	#hdkaname
	PUSHL	#hdkaaddunit
	PUSHL	#xosdskCcb##
	CALL	sysIoDriverRegister##
	TESTL	EAX, EAX
	JS	6$
	MOVL	EBX, lkei_pctop-4[ESP]	;OK
	MOVL	[EBX], #codetop
	CLRL	EAX
6$:	RET	lkei_ADJ

hdkaname:.ASCIZ "HDKA"

	CODE
.PAGE
	.SBTTL	hdkaaddunit - Subroutine to add disk unit

;Function to add a disk unit - This function is called from sysIoDriverAddUnit.
;  The following items are passed in TDA locations:
;	c{tdaBuffer1} = Address of the KCB for the unit
;	c{tdaCount}   = Index on the controller
;	long hdkaaddunit(
;	    long unit);		// Unit number
;  Value returned is 0 if normal or a negative XOS error code if error.

$$$=!0
FRM hau_char , 8	;Address of characteristics list
FRM hau_ioreg, 4	;Base IO register number
FRM hau_int  , 4	;Interrupt number
FRM hau_index, 4	;Index on controller
FRM hau_info , 1	;Information about drive
FRM          , 3
FRM hau_wpc  , 4	;Write pre-comp cylinder
FRM hau_head , 4	;Number of heads
FRM hau_sect , 4	;Number of sectors per track
FRM hau_cyln , 4	;Number of cylinders
FRM hau_into , 4	;Address of interrupt routine
FRM hau_kcb  , 4	;Address of KCB
hau_SIZE=!$$$

;Define bits for hau_info

INFO$NEWKCB=!0x01	;New KCB created

	.MOD	4
hdkaublk:					;Characteristics description
 CHARBGN  3, 0					;  block for addunit
 CHARENT  TYPE   , TEXT, , 8, 0, 0, knlRtnZero##, 0
 CHARENT  UNIT   , DECV, , 4, 0, 0, knlRtnZero##, 0
 CHARENT  IOREG  , HEXV, , 4, 0, 0, hdkauioreg  , 0
 CHARENT  INT    , DECV, , 1, 0, 0, hdkauintvec , 0
 CHARENT  INDEX  , DECV, , 4, 0, 0, hdkauindex  , 0
 CHARENT  IHEADS , DECV, , 4, 0, 0, hdkauhead   , 0
 CHARENT  ISECTS , DECV, , 4, 0, 0, hdkautsz    , 0
 CHARENT  ICYLNS , DECV, , 4, 0, 0, hdkaucyln   , 0
 CHARENT  WPCCYLN, DECV, , 4, 0, 0, hdkauwpc    , 0
 CHAREND

hau_unit=!16t		;Unit number

hdkaaddunit:
	PUSHL	EDI
	PUSHL	ESI
	ENTER	hau_SIZE, 0		;Allocate our stack frame
	MOVL	hau_kcb[EBP], EBX	;Store possible KCB offset
	CLRL	EAX
	MOVB	hau_info[EBP], AL
	MOVL	hau_head[EBP], EAX
	MOVL	hau_sect[EBP], EAX
	MOVL	hau_cyln[EBP], EAX
	DECL	EAX
	MOVL	hau_ioreg[EBP], EAX
	MOVL	hau_index[EBP], EAX
	MOVL	hau_int[EBP], EAX
	MOVL	hau_wpc[EBP], EAX
	PUSHL	#0			;Fail if bad name
	PUSHL	#hdkaublk
	CALL	sysIoCharValues##
	TESTL	EAX, EAX
	JS	haudone			;If error
	MOVL	EAX, hau_head[EBP]	;Is the disk configuration completely
	ORL	EAX, hau_sect[EBP]	;  unspecified?
	ORL	EAX, hau_cyln[EBP]
	JNE	6$			;No

;Here if the configuration is completely unspecified.  See if this is for one
;  of the standard PC hard disks, and if so, use the machine's CMOS data to
;  get the required values.

2$:	CMPL	hau_ioreg[EBP], #0x1F0	;Is this the standard controler?
	JNE	6$			;No - go on
	MOVL	ESI, hau_index[EBP]	;Yes - is it disk 1 or 2?
	CMPL	ESI, #2
	JA	6$			;No - go on
	SHLL	ESI, #4t
	ADDL	ESI, #knlHdkDataC##-0x10 ;Yes - point to data for the disk
	MOVZWL	EAX, [ESI]		;Get number of cylinders
	TESTL	EAX, EAX		;If zero, there is no data available
	JE	6$
	MOVL	hau_cyln[EBP], EAX
	MOVZBL	EAX, 2[ESI]		;Get number of heads
	MOVL	hau_head[EBP], EAX
	MOVZWL	EAX, 5[ESI]		;Get write pre-comp cylinder
	MOVL	hau_wpc[EBP], EAX
	MOVZBL	EAX, 0E[ESI]		;Get number of sectors per track
	MOVL	hau_sect[EBP], EAX
6$:	MOVL	EAX, hau_index[EBP]	;Do we have all of the necessary
	ORL	EAX, hau_int[EBP]	;  configuration information?
	ORL	EAX, hau_ioreg[EBP]
	INCL	EAX
	JNE	8$			;Yes
	MOVL	EAX, #ER_CHARM		;No - fail
	JMP	haudone

;Here with complete configuration information - See if the KCB for the unit
;  already exists. The code in dskcls1 has already determined that the
;  unit is not defined.

8$:	MOVL	EBX, hdkakcb		;Point to first HDKA KCB
10$:	MOVL	hau_kcb[EBP], EBX
	TESTL	EBX, EBX
	JE	20$			;If no more KCBs
	MOVL	EDX, hau_ioreg[EBP]	;Get IO register number
	CMPL	EDX, kcb_ioreg1[EBX]	;Yes - for this controller?
	JE	12$			;Yes
	MOVL	EBX, kcb_nexts[EBX]	;No - advance to next KCB
	JMP	10$			;Continue

;Here if found the KCB for our controller

12$:	TESTB	kcb_bits[EBX], #KB$ERROR ;Can we use it?
	JNE	18$			;No - fail

;Make sure we don't already have a unit with the same index

	MOVL	EAX, hau_index[EBP]

	MOVL	ESI, kcb_fucb[EBX]	;Get first UCB
14$:	TESTL	ESI, ESI
	JE	haukcbok		;If no more
	CMPB	ucb_index[ESI], AL
	JE	16$			;Same - fail!
	MOVL	ESI, ucb_next[ESI]	;Advance to next UCB
	JMP	14$

;Here if have a unit with the same index

16$:	MOVL	EAX, #ER_PDADF
	JMP	haudone

;Here if the KCB has had an error and is not usable

18$:	MOVL	EAX, #ER_DEVER
	JMP	haudone

;Here if no KCB now - see if the controller exists

20$:	MOVL	EDX, hau_ioreg[EBP]	;Select the unit we are trying to add
	A2IOP	P_DCHDDH		;  (this makes sure we don't zap the
	MOVB	AL, hau_index[EBP]	;  other unit on the controller and
	SHLB	AL, #4t			;  also re-enables ATAPI units which
	ADDB	AL, #0A0h-10h		;  have gone off-line)
	OUTB	[DX]
	IOPAUSE
	A2IOP	P_DCHDCYL-P_DCHDDH	;Point to the cylinder number register
	MOVB	AL, #25h		;Set it to some value
	OUTB	[DX]
	IOPAUSE
	INCL	EDX			;Write 0 to the next register to be
	MOVB	AL, #0h			;  sure we have discharged the bus
	OUTB	[DX]
	IOPAUSE
	DECL	EDX
	INB	[DX]			;Read it back
	CMPB	AL, #25h		;Is it right?
	JNE	24$			;No
	MOVB	AL, #42			;Yes - now set it to another value
	OUTB	[DX]
	IOPAUSE
	INCL	EDX			;Write 0 to the next register to be
	MOVB	AL, #0h			;  sure we have discharged the bus
	OUTB	[DX]
	IOPAUSE
	DECL	EDX
	INB	[DX]			;Read it back
	CMPB	AL, #42			;Is it right?
	JE	hauxst			;Yes
24$:	MOVL	EAX, #ER_PDNAV		;No - fail
	JMP	haudone
.PAGE
;Here if the controller exits - create and set up the KCB

hauxst:	CALL	knlGetXRes##		;Get the exec memory resource
	PUSHL	#0
	MOVL	EAX, ESP
	PUSHL	#HDKAINTSZ		;Get space for interrupt code
	PUSHL	EAX
	CALL	sysMemGetXCode##
	POPL	EDI
	TESTL	EAX, EAX
	JS	20$
	MOVL	hau_into[EBP], EDI	;Remember where code is going
	MOVL	ECX, EAX
	MOVL	ESI, #hdkaint		;Copy prototype interrupt routine
	SHRL	ECX, #2
	PUSHL	DS
	POPL	ES
	CLD
	RMOVSL	[EDI], [ESI]
	PUSHL	#0			;Make a KCB
	MOVL	EAX, ESP
	PUSHL	#KB$AHEAD+KB$DEFER
	PUSHL	#kcb_hdSIZE
	PUSHL	#hdkdsp
	PUSHL	#'HDKA'
	PUSHL	#hdkakcb
	PUSHL	EAX
	CALL	xosdskMakeKcb##
	POPL	EDI
	TESTL	EAX, EAX
	JS	20$
	MOVL	hau_kcb[EBP], EDI	;Remember where our KCB is
	ORB	hau_info[EBP], #INFO$NEWKCB
	MOVL	EAX, hau_ioreg[EBP]	;Store base IO register number in the
	MOVL	kcb_ioreg1[EDI], EAX	;  KCB
	ADDL	EAX, #0x0E
	CMPL	EAX, #0x1FE		;Is this the primary or secondary
	JE	4$			;  controller?
	CMPL	EAX, #0x17E
	JNE	6$			;No
4$:	ADDL	EAX, #0x206-0x0E	;Yes
6$:	MOVL	kcb_ioreg2[EDI], EAX	;Store second base IO register number
					;  (This is used to access the "control"
					;  register which is shared with the
					;  floppy controller if this is a
					;  primary or secondary controller or
					;  is at offset 0x0E from the first
					;  base IO register otherwise.)
	MOVL	EBX, #hwname+8		;Construct the hardware name
	MOVL	EAX, hau_ioreg[EBP]
	CALL	knlPutHex4Nmbr##
	MOVL	EDX, kcb_ioreg1[EDI]	;Register our IO register addresses
	LEAL	ECX, 0x0F[EDX]
	CMPL	EDX, #0x1F0
	JE	10$
	CMPL	EDX, #0x170
	JNE	12$
10$:	SUBL	ECX, #8
	PUSHL	#hwname
	PUSHL	EDX
	PUSHL	ECX
	CALL	sysIoRegPorts##
	TESTL	EAX, EAX
	JS	20$
	MOVL	EDX, kcb_ioreg2[EDI]	;Register our additional register
	MOVL	ECX, EDX
12$:	PUSHL	#hwname
	PUSHL	EDX
	PUSHL	ECX
	CALL	sysIoRegPorts##
	TESTL	EAX, EAX
	JS	20$
	MOVL	EAX, hau_int[EBP]
	MOVB	kcb_intlvl[EDI], AL
	PUSHL	#hwname			;Set up our interrupt vector
	PUSHL	EAX
	PUSHL	#DT_TRAP
	PUSHL	hau_into[EBP]
	PUSHL	#0
	CALL	sysIoSetInt##
	TESTL	EAX, EAX
	JS	20$
	MOVL	EDX, hau_into[EBP]
	MOVL	EBX, hau_kcb[EBP]
	MOVL	kcb_fdisp[EDI], #hdkfork ;Store fork location
	MOVL	{fix1-hdkaint}+1[EDX], EBX ;Fix up the interrupt code
	MOVL	EAX, #hdkaint
	SUBL	EAX, EDX
	ADDL	{fix2-hdkaint}+1[EDX], EAX
	CMPL	kcb_nexts[EDI], #0	;First time?
	JNE	16$			;Yes
	PUSHL	#hdkaoas		;Yes - setup our once-a-second routine
	CALL	sysSchSetUpOAS##
16$:	MOVL	ECX, hau_int[EBP]	;Enable our interrupt
	CALL	knlEnableInt##
	JMP	haukcbok

;Here if error when have the exec resource

20$:	PUSHL	EAX
	CALL	knlGiveXRes##
	POPL	EAX
	JMP	haudone
.PAGE
;Here with KCB set up or if already have a KCB

haukcbok:
	PUSHL	#0
	MOVL	EAX, ESP
	PUSHL	#'D'			;First letter for device name
	MOVZBL	EDX, hau_unit[EBP]	;Unit number
	PUSHL	EDX
	PUSHL	hau_kcb[EBP]		;Address of KCB
	PUSHL	#ucb_hdSIZE		;Size of the UCB
	PUSHL	EAX
	CALL	xosdskMakeUcb##		;Make a UCB
	POPL	ESI
	TESTL	EAX, EAX
	JNS	6$			;If OK
	PUSHL	EAX
	TESTB	hau_info[EBP], #INFO$NEWKCB ;Did we just create the KCB
	JE	4$			;No - just return the error
	PUSHL	hau_kcb[EBP]		;Yes - give up the new KCB
	PUSHL	#hdkakcb
	CALL	xosdskUnlinkKcb##
	PUSHL	hau_kcb[EBP]
	CALL	sysMemGiveXmb##
4$:	CALL	knlGiveXRes##
	POPL	EAX			;And return the error
	JMP	haudone

;Here with a UCB created

6$:	ORL	ucb_dsp[ESI], #DS$FIXED	;This is a fixed controller
	TESTB	hau_info[EBP], #INFO$NEWKCB ;Did we just create the KCB
	JE	8$			;No
	CALL	knlGiveXRes##		;Yes - give up the exec memory resource
8$:	MOVB	ucb_hdcmdwrt[ESI], #0xFF ;Indicate no packet commands
	MOVB	ucb_hdcmdrd[ESI], #0xFF
	MOVB	ucb_bits[ESI], #UB$DUPFAT ;Store value of ucb_bits
	MOVZBL	EAX, hau_head[EBP]	;Store number of heads
	MOVL	ucb_cheads[ESI], EAX
	MOVL	ucb_iheads[ESI], EAX
	MOVL	EAX, hau_sect[EBP]	;Store number of sectors/track
	MOVL	ucb_csects[ESI], EAX
	MOVL	ucb_isects[ESI], EAX
	MOVL	EAX, #512t		;Store sector size
	MOVL	ucb_csecsz[ESI], EAX
	MOVL	ucb_isecsz[ESI], EAX
	MOVB	ucb_blockshft[ESI], #9
	MOVL	EAX, hau_cyln[EBP]	;Store number of cylinders
	MOVL	ucb_ccylns[ESI], EAX
	MOVL	ucb_icylns[ESI], EAX
	DECL	EAX
	MOVL	ucb_cylmax[ESI], EAX
	INCL	EAX			;Calculate total number of blocks
	IMULL	EAX, ucb_csects[ESI]
	IMULL	EAX, ucb_cheads[ESI]
	MOVL	ucb_cblocks[ESI], EAX
	MOVL	ucb_iblocks[ESI], EAX
	MOVL	EAX, hau_wpc[EBP]	;Store write pre-comp cylinder
	SHRL	EAX, #2
	MOVB	ucb_hdwpc[ESI], AL
	MOVL	EAX, hau_index[EBP]	;Store unit index and select values
	MOVB	ucb_index[ESI], AL
	MOVL	EDX, hau_kcb[EBP]
	MOVL	EAX, kcb_ioreg1[EDX]	;Store base IO register numbers in the
	MOVL	ucb_ioreg1[ESI], EAX	;  UCB
	MOVL	EAX, kcb_ioreg2[EDX]
	MOVL	ucb_ioreg2[ESI], EAX
	MOVB	ucb_sts1[ESI], #U1$RECAL ;Indicate should recalibrate first
	MOVZBL	EAX, ucb_index[ESI]	;Set up the unit select value
	ADDL	EAX, #0x0A-1
	SHLL	EAX, #4
	MOVB	ucb_select[ESI], AL	 ;Store offset of our device
	MOVL	ucb_devchar[ESI], #hdkdchartbl ;  characteristics table
	MOVL	ucb_ramax[ESI], #32t	;Set initial read-ahead maximum
	MOVL	ucb_wtmax[ESI], #32t	;Set initial write transfer maximum
.PAGE
;Initialize the controller

initcon:PUSHL	#0			;Get a disk DCB
	PUSHL	#0
	PUSHL	#'INIT'
	PUSHL	#'HDKA'
	MOVL	EDX, ESP
	PUSHL	#0
	MOVL	EAX, ESP
	PUSHL	EDX
	PUSHL	ESI
	PUSHL	EAX
	CALL	xosdskGetDcb##
	POPL	EDI
	ADDL	ESP, #16t
	TESTL	EAX, EAX
	JS	14$			;If can't get a DCB
	MOVL	EAX, knlTda+tdaAddr##
	MOVL	dcb_outtda[EDI], EAX	;OK - store the thread address
	MOVL	knlTda+tdaDcb##, EDI
	CALL	getdriveinfo
	MOVL	EDX, #DHTS_4K		;Assume want 4K pointers
	TESTL	ucb_dsp[ESI], #DS$REMOVE ;Is this a removeable disk?
	JNE	6$			;Yes - use 4K pointers
	CMPL	ucb_iblocks+4[ESI], #0	;No - very large disk?
	JNE	4$			;Yes - use the biggest hash table
	MOVL	ECX, ucb_iblocks+0[ESI]	;No - get size
	CMPL	ECX, #2000000t		;Less than about 1GB or unknown?
	JB	6$			;Yes - use 4K
	ADDL	EDX, #DHTS_8K-DHTS_4K	;No - assume should use 8K
	CMPL	ECX, #20000000t		;More than about 10GB
	JB	6$			;No - use 8K
4$:	MOVL	EDX, #DHTS_16K		;Yes - use 16K pointers
6$:	PUSHL	ESI
	PUSHL	EDX
	CALL	xosdskMakeHashTbl##	;Create the hash table
	TESTL	EAX, EAX
	JS	10$
	CALL	xosdskClearDcb##	;Give up the DCB we were using
	CLRL	EAX
	MOVL	knlTda+tdaDcb##, EAX
	INCL	EAX
haudone:LEAVE
	POPL	ESI
	POPL	EDI
	RET	4

;Here if error creating the hash table (This really should not crash the
;  system - FIX IT SOMEDAY!)

10$:	CRASH	CCHT

;Here if error creating a disk DCB

14$:	ADDL	ESP, #16t
	JMP	haudone
.PAGE
;Subroutine called by addunitchar for the IOREG parameter

hdkauioreg:
	MOVL	hau_ioreg[EBP], EAX	;Store base IO register
	CLRL	EAX
	RET

;Subroutine called by addunitchar for the INDEX parameter

hdkauindex:
	TESTL	EAX, EAX		;Valid index on controller?
	JE	6$			;No
	CMPL	EAX, #2			;Maybe
	JA	6$			;No
	MOVL	hau_index[EBP], EAX	;Yes - store index
	CLRL	EAX
	RET

;Subroutine called by addunitchar for the "INT" parameter

hdkauintvec:
	CMPL	EAX, #2			;Valid value?
	JB	6$			;No
	JNE	2$			;Maybe
	MOVB	AL, #9t			;Yes - do vector 2 fixup
2$:	CMPL	EAX, #15t		;Maybe
	JA	6$			;No
	MOVL	hau_int[EBP], EAX	;Yes - store value
	CLRL	EAX
	RET

;Subroutine called by addunitchar for the "IHEADS" parameter

hdkauhead:
	TESTL	EAX, EAX		;0?
	JE	6$			;Yes - illegal
	MOVL	hau_head[EBP], EAX	;OK - store number of heads
	CLRL	EAX
	RET

6$:	MOVL	EAX, #ER_CHARV
	STC
	RET

;Subroutine called by addunitchar for the "ISECTS" parameter

hdkautsz:
	MOVL	hau_sect[EBP], EAX
	RET

;Subroutine called by addunitchar for the "ICYLNS" parameter

hdkaucyln:
	MOVL	hau_cyln[EBP], EAX
	RET

;Subroutine called by addunitchar for the "WPCCYLN" parameter

hdkauwpc:
	CWL				;Extend 16 bit value to 32 bits
	CMPL	EAX, #1024t		;Valid value?
	JB	8$			;Yes
	CLRL	EAX			;No - indicate no write pre-comp
	DECL	EAX
8$:	MOVL	hau_wpc[EBP], EAX	;Yes - store value
	CLC
	RET
.PAGE
;Here for the ks_removebgn function - Since this is a fixed controller, this
;  does nothing
;	void hdkremovebgn
;	    UCB *ucb,
;	    long rmv);

hdkremovebgn:
	RET	8

;Here for the ks_removefin function - Since this is a fixed controller, this
;  does nothing
;	void hdkremovefin
;	    UCB *ucb,
;	    long rmv);

hdkremovefin:
	RET	8
.PAGE
;Here to get value for the CMDRSP device characteristic

getcmdrsp:
	MOVL	ESI, dcb_dkucb[EDI]
	MOVB	AL, ucb_sts3[ESI]
	ANDL	EAX, #U3$ATAPIRSP
	MOVL	EAX, cmdrsptbl[EAX*4]
	CLRL	EDX
	RET

	.MOD	4
cmdrsptbl:
	.LONG	'N/A'
	.LONG	'Slow'
	.LONG	'Int'
	.LONG	'Fast'
.PAGE
;Here to get value for the READY device characteristic

getready:
	MOVL	ESI, dcb_dkucb[EDI]
	MOVL	EAX, #'Yes'
	TESTB	ucb_sts2[ESI], #U2$REMOVED
	JE	14$
	MOVL	EAX, #'No'
14$:	RET
.PAGE
;Subroutine to determine media parameters
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of UCB
;	CALL	hdkmedia
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  Z:set = Disk may be file structured
;	  Z:clr = Disk cannot be file structured

hdkmedia:
	CALL	getdriveinfo
	JNC	xosdskHdkMedia##
	RET
.PAGE
getdriveinfo:
	PUSHL	EDI
	PUSHL	ESI
	PUSHL	EBX
	MOVL	EDI, knlTda+tdaDcb##
	MOVL	ESI, dcb_dkucb[EDI]
	CMPL	ucb_baseucb[ESI], ESI	;Is this a partition?
	JNE	40$			;Yes - nothing needed here
	PUSHL	#0
	MOVL	EAX, ESP
	PUSHL	#-XMBX_512
	PUSHL	EAX
	CALL	sysMemGetXmb##
	POPL	EBX
	TESTL	EAX, EAX
	JS	42$
	TESTB	ucb_bits[ESI], #UB$ATAPI ;Is this known to be an ATAPI unit?
	JNE	8$			;Yes
	PUSHL	#kf_getparms		;No - do an identify drive command to
	PUSHL	EBX			;  try to indentify the drive
	PUSHL	#512t
	CALL	xosdskTransfer##
	TESTL	EAX, EAX
	JNS	12$			;Go on if it worked

;Here if the ATA identify drive command failed - check for the ATAPI signature

	MOVL	EDX, ucb_ioreg1[ESI]
	A2IOP	P_DCATAPIBCL
	INB	[DX]
	CMPB	AL, #0x14
	JNE	6$
	A2IOP	P_DCATAPIBCH-P_DCATAPIBCL
	INB	[DX]
	CMPB	AL, #0xEB
6$:	JNE	24$			;Assume this is an old-style IDE unit!

;Here if this is known to be an ATAPI unit - do an ATAPI identify drive command

8$:	PUSHL	#kf_getaparms		;Note that the kf_getaparms routine
	PUSHL	EBX			;  does some additional ATAPI commands
	PUSHL	#512t			;  to obtain additional data about the
	CALL	xosdskTransfer##	;  unit
	TESTL	EAX, EAX
	JNS	info2
	JMP	24$			;This should not fail!

;Here if the ATA identify command worked

12$:	ANDB	1[EBX], #0x3F		;Make sure protocol value is right

;Start of common code for ATA and ATAPI identify commands

info2:	MOVZWL	EAX, 0*2[EBX]		;OK - get configuration bits
	MOVL	ucb_hdconfig[ESI], EAX
	TESTB	AL, #0x80		;Removable unit?
	JE	16$			;No
	ORB	ucb_bits[ESI], #UB$MEDIAC ;Yes
	ORL	ucb_dsp[ESI], #DS$REMOVE
16$:	MOVZBL	EAX, 47t*2[EBX] 	;Get maximum sectors per interrupt
	MOVL	ucb_hdsecpi[ESI], EAX
	MOVZWL	EAX, 21t*2[EBX]		;Get number of buffers
	SHLL	EAX, #9			;Change to bytes
	MOVL	ucb_hdbufsz[ESI], EAX
	TESTB	ucb_bits[ESI], #UB$ATAPI ;ATAPI unit?
	JE	18$
	CMPB	ucb_unittype[ESI], #DT_HARD
	JNE	18$
	CMPL	88t[EBX], #0x6F70466C
	JNE	18$
	CMPL	92t[EBX], #0x7079
	JNE	18$
	MOVB	ucb_unittype[ESI], #DT_UHD3	
18$:	PUSHL	EBX
	ADDL	EBX, #27t*2		;Get model number string
	LEAL	EDX, ucb_model[ESI]
	MOVL	ECX, #20t
	CALL	getidstr
	MOVL	EBX, [ESP]
	ADDL	EBX, #10t*2		;Get serial number string
	LEAL	EDX, ucb_serialno[ESI]
	MOVL	ECX, #10t
	CALL	getidstr
	MOVL	EBX, [ESP]
	ADDL	EBX, #23t*2		;Get firmware version string
	LEAL	EDX, ucb_revision[ESI]
	MOVL	ECX, #4t
	CALL	getidstr
	POPL	EBX
	MOVZWL	EAX, 12t[EBX]		;Get actual number of sectors
	MOVL	ucb_csects[ESI], EAX
	MOVL	ucb_isects[ESI], EAX
	MOVZWL	EAX, 6[EBX]		;Get actual number of heads
	MOVL	ucb_cheads[ESI], EAX
	MOVL	ucb_iheads[ESI], EAX
	MOVZWL	EAX, 2[EBX]		;Get actual number of cylinders
	MOVL	ucb_ccylns[ESI], EAX
	MOVL	ucb_icylns[ESI], EAX
	MOVL	EAX, 120t[EBX]		;Get total number of LBA blocks

;NOTE: For now, we only support 28 bit block numbers so this check is not
;      yet needed! We will add this real soon.

.IF NE 0
	CMPL	EAX, #0x0FFFFFFF	;Maximum value?
	JB	info4			;No
	TESTB	167t[EBX], #0x04 	;Yes - 48-bit addressing supported?
	JE	info4			;No (strange but probably possible)
	MOVL	EAX, 200t[EBX]		;Yes - get low half of number of LBA
					;  blocks
	CMPL	204t[EBX], #0		;Is the high half 0?
	JE	info4			;Yes - use the low half
	MOVL	EAX, #0xFFFFFFFF	;No - make is as big as we can in 32
					;  bits!
.ENDC

info4:	PUSHL	EAX
	TESTB	ucb_bits[ESI], #UB$ATAPI ;ATAPI unit?
	JNE	20$			;Yes - always have LBA mode available
	TESTB	99t[EBX], #0x02		;No - might LBA mode be available?
	JE	22$			;No
	CMPL	120t[EBX], #0		;Maybe
	JE	22$			;No
	ORB	ucb_bits[ESI], #UB$LBA	;Yes - enable LBA mode
	MOVL	ucb_cblocks[ESI], #1	;No - set so we can read block 0!
	CLRL	EAX
	MOVL	dcb_dkdskblk+0[EDI], EAX ;Try to read block 0 using LBA mode
	MOVL	dcb_dkdskblk+4[EDI], EAX
	PUSHL	#kf_readdata
	PUSHL	EBX
	PUSHL	#512t
	CALL	xosdskTransfer##
	TESTL	EAX, EAX
	JS	22$			;If error
20$:	POPL	EAX			;OK - have LBA mode available
	JMP	32$

;Here if LBA mode read failed

22$:	POPL	EAX			;Fix up the stack
24$:	ANDB	ucb_bits[ESI], #~UB$LBA ;Assume this means that LBA mode is
					;  not supported

;Here if don't have LBA mode available - We make sure we have non-zero
;  values for the number of cylinders, heads, and sectors.  This ensures
;  that we will not get a divide error when accessing the disk.  If there
;  is a file structure on the disk, we will use the values from the file
;  structure's boot block.  If not, we will probably not be able to access
;  anything beyond the first track on the disk!

	CMPL	ucb_icylns[ESI], #0	;Have a cylinders value?
	JNE	26$			;Yes
	MOVL	ucb_icylns[ESI], #500t	;No - put in a fake non-zero value
	MOVL	ucb_ccylns[ESI], #500t
26$:	CMPL	ucb_iheads[ESI], #0	;Have a heads value?
	JNE	28$			;Yes
	MOVL	ucb_iheads[ESI], #6t	;No - put in a fake non-zero value
	MOVL	ucb_cheads[ESI], #6t
28$:	CMPL	ucb_isects[ESI], #0	;Have a sectors value?
	JNE	30$			;Yes
	MOVL	ucb_isects[ESI], #17t	;No - put in a fake non-zero value
	MOVL	ucb_csects[ESI], #17t
30$:	MOVL	EAX, ucb_icylns[ESI]	;Calculate total number of blocks
	IMULL	EAX, ucb_cheads[ESI]
	IMULL	EAX, ucb_csects[ESI]
32$:	MOVL	ucb_cblocks+0[ESI], EAX
	MOVL	ucb_cblocks+4[ESI], #0
	MOVL	ucb_iblocks+0[ESI], EAX
	MOVL	ucb_iblocks+4[ESI], #0
	PUSHL	EBX
	CALL	sysMemGiveXmb##		;Give up the buffer we used
	TESTB	ucb_bits[ESI], #UB$LBA
	JNE	40$
	PUSHL	#kf_setparms		;Set the drive parameters
	PUSHL	#0
	PUSHL	#0
	CALL	xosdskTransfer##
40$:	CLRL	EAX
42$:	POPL	EBX
	POPL	ESI
	POPL	EDI
	RET
.PAGE
;Subroutine to copy string for the disk unit identify data - these strings are
;  stored as a list of words with reverse byte order - a string may be null
;  terminated or space filled to its maximum length - this routine fixes up
;  the byte order and removes any trailing or leading spaces and replaces all
;  multiple spaces with a single space character
;	c{EBX} = Offset of start of string
;	c{EDX} = Offset to receive string
;	c{ECX} = Maximum length of string (in words)
;	CALL	getidstr

getidstr:
	PUSHL	ECX			;First, fix up the byte order
	PUSHL	EBX
2$:	RORW	[EBX], #8
	ADDL	EBX, #2
	LOOP	ECX, 2$
	POPL	EBX			;Restore pointer
	POPL	ECX			;Restore count
	ADDL	ECX, ECX		;Change to byte count
4$:	CMPB	[EBX], #' '		;Leading space?
	JNE	6$			;No
	INCL	EBX			;Yes - skip it
	LOOP	ECX, 4$
	JMP	16$			;If null string (all spaces)

;Here with non-space character

6$:	PUSHL	EDX
8$:	MOVB	AL, [EBX]		;Get byte
	INCL	EBX			;Bump pointer
	CMPB	AL, #' '		;Space?
	JNE	10$			;No
	CMPB	-1[EDX], #' '		;Was previous character a space?
	JE	12$			;Yes - skip this one
10$:	MOVB	[EDX], AL		;No - store byte
	INCL	EDX			;Bump pointer
	CMPB	AL, #0			;End of string?
	JE	14$			;Yes
	CMPB	AL, #' '		;Space?
	JE	12$			;Yes
	MOVL	[ESP], EDX		;No - remember this as end
12$:	LOOP	ECX, 8$			;Continue if more to copy
14$:	POPL	EDX			;Restore offset of end of string
16$:	MOVB	[EDX], #0		;Put null at end
	RET
.PAGE
	.SBTTL	ks_senchg - Sense disk change

;Subroutine to sense if a disk has changed - This function is called to
;  determine if a disk has been changed when obtaining a block from the
;  cache.  If there has been disk activity within the last second, it
;  assumes the disk has not been changed.  Otherwise it sends a command
;  to the disk which will give a disk changed error if the disk has been
;  changed since the last IO operation.
;	long hdksenchg(void);
;  Value returned is:
;	<0 - Error, value is XOS error code
;	 0 - Disk not changed
;	 1 - Disk might be changed (no media sensor - never returned here)

hdksenchg:
	PUSHL	EDI
	PUSHL	ESI
	MOVL	EDI, knlTda+tdaDcb##
	MOVL	ESI, dcb_dkucb[EDI]
	TESTL	ucb_dsp[ESI], #DS$REMOVE ;Is this disk removable?
	JE	2$			;No - it can't be changed!
	TESTB	ucb_sts2[ESI], #U2$MCHG ;Yes - do we know it is changed?
	JNE	6$			;Yes
	MOVL	EAX, knlSchCounts##	;No - do we need to do this now?
	SUBL	EAX, ucb_acstime[ESI]
	JS	2$			;No
	CMPL	EAX, #SPPERSEC		;Maybe
	JAE	4$			;Yes - must check
2$:	CLRL	EAX			;No - indicate not changed
chgdone:POPL	ESI
	POPL	EDI
	RET

;Function to check if a disk has changed - This function is called to
;  determine if a disk has been changed when mounting a disk. This always
;  sends a command to the disk which will fail if the media has been chagned.
;	long hdkchkchg(void);
;  Value returned is:
;	<0 - Error, value is XOS error code
;	 0 - Disk not changed
;	 1 - Disk might be changed (no media sensor - never returned here)
;	 2 - Disk changed

hdkchkchg:
	PUSHL	EDI
	PUSHL	ESI
	MOVL	EDI, knlTda+tdaDcb##
	MOVL	ESI, dcb_dkucb[EDI]
	TESTL	ucb_dsp[ESI], #DS$REMOVE ;Is this disk removable?
	JE	2$			;No - it can't be changed!
	TESTB	ucb_sts2[ESI], #U2$MCHG
	JNE	6$

;Here to execute command to get the media change status

4$:	PUSHL	#kf_chkchg		;See if the disk has been changed
	PUSHL	#0
	PUSHL	#0
	CALL	xosdskTransfer##
	TESTL	EAX, EAX
	JNS	2$
	JMP	chgdone

6$:	MOVL	EAX, #ER_MDCHG
	JMP	chgdone
.PAGE
;Here for the set drive parameters (kf_setparms) function - This command
;  issues an initialize drive parameters command using the values from
;  ucb_csects and ucb_cheads, scaled if necessary to bring the value into
;  range.  The number of heads cannot be greater than 16.  If the ucb_cheads
;  value is greater than 16, the actual value from the drive is used if it
;  is 16 or less.  If it is more than 16, a value of 16 is used for the
;  number of heads and the number of sectors value is increased to compensate
;  as much as possible.  In any case, the values used here are stored in
;  ucb_hdmheads and ucb_hdmsects.  This command should never be issued for
;  an LBA drive.
;	long hdksetparms(
;	    char *buffer,	// Not used for this function
;	    long  length);	// Not used for this function

stpms_buffer=!16t
stpms_length=!12t

hdksetparms:
	PUSHL	EDI
	PUSHL	ESI
	MOVL	EDI, knlTda+tdaDcb##
	MOVL	ESI, dcb_dkucb[EDI]
	TESTB	ucb_sts2[ESI], #U2$REMOVED ;Still have a controller?
	JNE	12$			;No
	CLRL	EAX			;Assume no mapping needed
	MOVL	ucb_hdmsects[ESI], EAX
	MOVL	ucb_hdmheads[ESI], EAX
	MOVL	ucb_hdmcylns[ESI], EAX
	MOVL	ECX, ucb_csects[ESI]	;Get number of sectors
	MOVL	EAX, ucb_cheads[ESI]	;Get number of heads
	CMPL	EAX, #16t		;Too many heads?
	JBE	8$			;No - use it
	MOVL	ECX, ucb_isects[ESI]	;Yes - get actual values from drive
	MOVL	EAX, ucb_iheads[ESI]
	CMPL	EAX, #16t		;Usable head value?
	JBE	6$			;Yes
4$:	IMULL	ECX, EAX		;No - calculate adjusted number of
	ADDL	ECX, #15t		;  sectors
	SHRL	ECX, #4t
	MOVL	EAX, #16t		;Use 16 heads
	CMPL	ECX, #63t		;Too many sectors?
	JBE	6$			;No
	MOVL	ECX, #63t		;Yes - use 63
6$:	MOVL	ucb_hdmsects[ESI], ECX	;Store mapped values
	MOVL	ucb_hdmheads[ESI], EAX
	IMULL	ECX, EAX
	CLRL	EDX			;Calculate adjusted number of cylinders
	MOVL	EAX, ucb_iblocks[ESI]
	DIVL	ECX
	MOVL	ucb_hdmcylns[ESI], EAX	;Calcualte adjusted number of total
	IMULL	EAX, ucb_hdmheads[ESI]	;  blocks
	IMULL	EAX, ucb_hdmsects[ESI]
	MOVL	ucb_cblocks[ESI], EAX
	MOVL	ECX, ucb_hdmsects[ESI]
	MOVL	EAX, ucb_hdmheads[ESI]
8$:	MOVL	EDX, ucb_ioreg1[ESI]
	A2IOP	P_DCHDDH
	DECL	EAX
	ORB	AL, ucb_select[ESI]	;Merge in drive select bit
	OUTB	[DX]			;Store number of heads and drive select
	IOPAUSE
	A2IOP	P_DCHDSCN-P_DCHDDH	;Store number of sectors
	MOVL	EAX, ECX
	OUTB	[DX]
	IOPAUSE
	TOFORK
	MOVL	ECX, ucb_kcb[ESI]
	MOVB	kcb_sts1[ECX], #0
	A2IOP	P_DCHDCMD-P_DCHDSCN	;Store command
	MOVB	AL, #0x91
	OUTB	[DX]
	MOVB	kcb_itimer[EBX], #TO_SETPARMS
	PUSHL	#-1
	PUSHL	#-1
	PUSHL	#THDS_DW2
	CALL	sysIoWait##		;Wait until finished
10$:	POPL	ESI
	POPL	EDI
	RET	8

12$:	MOVL	EAX, #ER_NTRDY
	JMP	10$
.PAGE
	.SBTTL	kf_getparms - Get drive parameters

;Here for the get drive parameters function
;	c{EBX} = Address of buffer
;	c{ECX} = Byte count
;	c{ESI} = Offset of UCB
;	c{EDI} = Offset of DCB
;	CALL	hdkgetparms
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = 0

hdkgetparms:
	MOVL	ECX, #1
	MOVL	EAX, #0xEC00FF00|K1$INPUT ;Get ATA identify drive command
	JMP	hdkxfer			;Go handle it just like a read command!

	.SBTTL	kf_getaparms - Get ATAPI drive parameters

;Here for the get ATAPI drive parameters function - This function also
;  does an ATAPI read capacity command and a mode sense command to obtain
;  the inactivity time value and fills in the data from these commands in
;  the "normal" ATA items in the parameter block.
;	c{EBX} = Address of buffer
;	c{ECX} = Byte count
;	c{ESI} = Offset of UCB
;	c{EDI} = Offset of DCB
;	CALL	hdkgetaparms
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = 0

$$$=!0
FRM kfgap_cnt, 4
kfgap_SIZE=!$$$

kfgap_buffer=!20t
kfgap_length=!16t

hdkgetaparms:
	PUSHL	ESI
	PUSHL	EBX
	ENTER	kfgap_SIZE
	MOVL	ESI, knlTda+tdaDcb##
	MOVL	ESI, dcb_dkucb[ESI]
	MOVL	EBX, kfgap_buffer[EBP]
	PUSHL	EBX
	PUSHL	kfgap_length[EBP]
	MOVL	ECX, #1
	MOVL	EAX, #0xA100FF00|K1$INPUT ;Get ATAPI identify drive command
	CALL	hdkxfer			;Do it
	TESTL	EAX, EAX
	JS	gapdn			;If error
	MOVB	ucb_hdcmdwrt[ESI], #0x2A ;Store the ATAPI packet command values
	MOVB	ucb_hdcmdrd[ESI], #0x28
	ORB	ucb_bits[ESI], #UB$ATAPI|UB$LBA ;Indicate ATAPI drive
	MOVL	EAX, [EBX]
	TESTB	AH, #0x80		;Is the protocol type right?
	JE	2$			;No
	TESTB	AH, #0x40		;Maybe
	JNE	2$			;No
	SHRB	AL, #5			;Yes - get the command response type
	ANDB	AL, #0x03
	CMPB	AL, #3			;Is it valid?
	JB	4$
2$:	MOVL	EAX, #ER_DEVER		;No - fail!
	JMP	gapdn

4$:	INCL	EAX			;Yes - store the value
	ANDB	ucb_sts3[ESI], #~{U3$ATAPIRSP|U3$CMDINT}
	CMPB	AL, #ACR_INT
	JNE	8$
	ORB	AL, #U3$CMDINT
8$:	ORB	ucb_sts3[ESI], AL
	ANDB	AH, #0x1F		;Get the device type
	MOVB	AL, #DT_HARD		;Assume hard disk
	CMPB	AH, #0			;Right?
	JE	10$			;Yes
	MOVB	AL, #DT_CDRM		;No - assume CD-ROM
	CMPB	AH, #5			;Right?
	JE	10$			;Yes
	MOVB	AL, #DT_OPTD		;No - assume optical disk
	CMPB	AH, #7			;Right?
	JNE	2$			;No - fail!
10$:	MOVB	ucb_unittype[ESI], AL	;Yes - store unit type

;Now do a Read Capacity command to get the size of the unit

	MOVL	kfgap_cnt[EBP], #6t

12$:	LEAL	EAX, 504t[EBX]
	PUSHL	EAX
	PUSHL	#8
	MOVL	ECX, #1
	MOVL	EAX, #002500|K1$INPUT
	CALL	hdkxfer
	TESTL	EAX, EAX
	JS	14$
	MOVL	EAX, 504t[EBX]
	XCHGB	AL, AH
	RORL	EAX, #16t
	XCHGB	AL, AH
	INCL	EAX
	JMP	20$

14$:	CMPL	EAX, #ER_NTRDY	;Not ready?
	JNE	16$			;No
	ADDL	ESP, #4t		;Yes - assume we have 512 byte blocks
	MOVL	ucb_pblksz[ESI], #1
	CLRL	EAX
	MOVL	120t[EBX], EAX
	JMP	gapdn

;Here if error on the Read Capacity command other than not ready

16$:	CMPL	EAX, #ER_MDCHG		;Media change?
	JNE	18$			;No
	DECL	[ESP]			;Yes - have we tried enough?
	JNE	12$			;No - try it again

;Here if the Read Capacity command failed - try to do a Read Format Capacity
;  command

18$:	LEAL	EAX, 500t[EBX]
	PUSHL	EAX
	PUSHL	#12t
	MOVL	ECX, #1
	MOVL	EAX, #002300|K1$INPUT
	CALL	hdkxfer
	TESTL	EAX, EAX
	JS	gapdn
	MOVL	EAX, 504t[EBX]
	XCHGB	AL, AH
	RORL	EAX, #16t
	XCHGB	AL, AH
20$:	MOVL	EDX, 508t[EBX]		;Get the block size
	MOVB	DL, DH
	MOVB	DH, #0
	RORL	EDX, #16t
	XCHGB	DL, DH
	SHRL	EDX, #9t
	CMPL	EDX, #1
	JL	22$
	CMPL	EDX, #4
	JBE	24$
22$:	MOVL	EDX, #1
24$:	MOVL	ucb_pblksz[ESI], EDX
	IMULL	EAX, EDX
	MOVL	120t[EBX], EAX
	CLRL	EAX
gapdn:	LEAVE
	POPL	EBX
	POPL	ESI
	RET	8
.PAGE
;Here for the get CD-ROM session list (kf_sessions) function
;	long hdkgettoc(
;	    char *bufr,
;	    long  cnt);
;  Value returned is 0 if normal or a negative XOS error code if error. The
;    amount transfered is stored in kcb_amount. Data returned in the buffer
;    is the raw data received from the drive

hdkgettoc:
	MOVL	ECX, #2
	MOVL	EAX, #0x00024300|K1$INPUT
	JMP	hdkxfer

;Here for the get CD-ROM track list (kf_tracks) function
;	long hdkgettrks(
;	    char *bufr,
;	    long  cnt);
;  Value returned is 0 if normal or a negative XOS error code if error. The
;    amount transfered is stored in kcb_amount. Data returned in the buffer
;    is the raw data received from the drive

hdkgettrks:
	MOVL	ECX, #2
	MOVL	EAX, #0x00004300|K1$INPUT
	JMP	hdkxfer
.PAGE
;Here for the format track function
;	long hdkformat(
;	    char *bufr,
;	    long  cnt);
;  Value returned is 0 if normal or a negative XOS error code if error. The
;    amount transfered is stored in kcb_amount.

hdkformat:
	CLRL	ECX
	MOVL	EAX, #0x0050FF00|K1$OUTPUT ;Get ATA format command
	JMP	hdkxfer
.PAGE
	.SBTTL	kf_chkchg - Check for possible disk change at fork level

;Here for the check for disk change (kf_chkchg) function - This function is
;  only used for ATAPI disks.  It issues a test unit ready function which
;  will fail with an ER_MDCHG error if the media might have been changed.

;;;; THIS MAY BE WRONG FOR ATAPI!!

hdkchkchgf:
	MOVL	ECX, #1
	MOVL	EAX, #0xDF00FF00	;No - get ATA unlock door command
	JMP	hdkxfer
.PAGE
;Here for the read raw block (kf_readraw) function
;	long hdkreadraw(
;	    char *bufr,
;	    long  cnt);
;  Value returned is 0 if normal or a negative XOS error code if error. The
;    amount transfered is stored in kcb_amount.

hdkreadraw:
	MOVL	ECX, #1
	JMP	2$

;Here for the read buffer list (kf_readlist) function
;	long hdkreadlist(
;	    char *buffer,
;	    long  length);
;  Value returned is 0 if normal or a negative XOS error code if error.  The
;    amount transfered has been added to tdaDevAmnt.

hdkreadlist:
.IF NE $$CHKLST
	CALL	checklist
.ENDC
	CLRL	ECX
2$:	MOVL	EAX, #0x2000FF00|K1$INPUT|K1$LIST|K1$BLKCNT
	JMP	4$			;Get ATA read cmd and kcb_sts1 value

;Here for the read block function
;	long hdkreaddata(
;	    char *bufr,
;	    long  cnt);
;  Value returned is 0 if normal or a negative XOS error code if error. The
;    amount transfered is stored in kcb_amount.

hdkreaddata:
	CLRL	ECX
	MOVL	EAX, #0x2000FF00|K1$INPUT|K1$BLKCNT ;Get ATA read cmd and
						    ;  kcb_sts1 value
4$:	MOVB	AH, ucb_hdcmdrd[ESI]	;Get ATAPI packet read command
	JMP	hdkxfer

;Here for the write raw block function
;	long hdkwritraw(
;	    char *bufr,
;	    long  cnt);
;  Value returned is 0 if normal or a negative XOS error code if error. The
;    amount transfered is stored in kcb_amount.

hdkwritraw:
	MOVL	ECX, #1
	JMP	8$

;Here for the write buffer list function
;	long hdkwritlist(
;	    char *bufr,
;	    long  cnt);
;  Value returned is 0 if normal or a negative XOS error code if error. The
;    amount transfered is stored in kcb_amount.

hdkwritlist:
.IF NE $$CHKLST
	CALL	checklist
.ENDC
	CLRL	ECX
	MOVL	EAX, #0x3000FF00|K1$OUTPUT||K1$LIST|K1$BLKCNT
	JMP	10$			;Get ATA write and kcb_sts1 value

;Here for the write block function
;	long hdkwritdata(
;	    char *bufr,
;	    long  cnt);
;  Value returned is 0 if normal or a negative XOS error code if error. The
;    amount transfered is stored in kcb_amount.

hdkwritdata:
	CLRL	ECX
8$:	MOVL	EAX, #0x3000FF00|K1$OUTPUT|K1$BLKCNT
					;Get ATA write and kcb_sts1 value
10$:	MOVB	AH, ucb_hdcmdwrt[ESI]	;Get ATAPI packet write command
					;Fall into hdkxfer on next page
.PAGE
;Here to actually do the transfer
;	c{EAX} = (bits 7 -0 ) Value for kbc_sts1
;		 (bits 23-8 ) ATAPI packet command
;		 (bits 31-24) ATA command
;	c{ECX} = 0 if normal access (address translation is done), 1 if no
;		 address translation is wanted

$$$=!0				;The next 3 items MUST be in this order!
FRM xfr_func   , 1		;Function value for interface
FRM xfr_pktcmd2, 1		;Second byte of packet command
FRM xfr_pktcmd1, 1		;First byte of packet command
FRM xfr_sts1   , 1		;Value for kcb_sts1
FRM            , 3
FRM xfr_changed, 1
FRM xfr_daddr  , 8		;Disk block number
FRM xfr_bfrleft, 4
FRM xfr_ttlleft, 4
xfr_SIZE=!$$$

xfr_buffer=!24t
xfr_length=!20t

hdkxfer:PUSHL	EDI
	PUSHL	ESI
	PUSHL	EBX
	ENTER	xfr_SIZE		;Set up a stack frame
	MOVL	EDI, knlTda+tdaDcb##
	MOVL	ESI, dcb_dkucb[EDI]
	MOVL	EBX, ucb_kcb[ESI]
	TESTB	ucb_sts2[ESI], #U2$REMOVED ;Still have a controller?
	JNE	xfernrd			;No
	MOVL	xfr_sts1[EBP], EAX	;Save functions
	CLRL	EAX
	MOVB	xfr_changed[EBP], AL
	DECL	ECX			;Do we need to translate the disk block?
	JS	2$			;Yes
	MOVL	xfr_daddr+0[EBP], EAX	;No
	MOVL	xfr_daddr+4[EBP], EAX
	JMP	30$

;Here to translate the disk block number. If the disk uses CHS addressing,
;  the address is encoded as:
;	00000000 0hccccss
;  If the disk uses 28 bit LBA addressing, the address is placed in the low
;  28 bits of the block number and bits 31-29 are set to 0xE. Bits 63-32 are
;  set to 0. If the disk uses 48 bit LBA addressing, the low oder 24 bits are
;  placed in the low order 24 bits of the block number and 0xE0 is placed in
;  bits 31-24. The high order 24 bits are placed in bits 55-32. Bits 63-56
;  are set to 0. This allows the device registers to be written with minimal
;  additional checking for the disk address type. For an ATAPI drive, the
;  address is stored directly.

2$:	MOVL	EAX, dcb_dkdskblk+0[EDI] ;Get block number on disk
	MOVL	EDX, dcb_dkdskblk+4[EDI]
	CMPL	EDX, ucb_cblocks+4[ESI]	;Valid value?
	JA	4$			;No - fail
	JNE	6$
	CMPL	EAX, ucb_cblocks+0[ESI]
	JB	6$
4$:	MOVL	EAX, #ER_BDDBK		;Get error code
	JMP	xferdn

6$:	CMPB	dcb_dkdskblk+7[EDI], #0
	JE	8$
	CRASH	BDDA			;[BaD Disk Address]

8$:	ADDL	EAX, ucb_partnoff+0[ESI] ;Add in position of start of partition
	ADDL	EDX, ucb_partnoff+4[ESI]
	TESTB	ucb_bits[ESI], #UB$LBA	;Can we use LBA mode?
	JNE	20$			;Yes
	CLRL	EDX			;No
	CMPL	ucb_hdmsects[ESI], #0	;Is this disk mapped?
	JE	10$			;No
	DIVL	ucb_hdmsects[ESI]	;Yes - use right values
	INCL	EDX			;Get sector number
	PUSHL	EDX			;Save sector number
	CLRL	EDX
	DIVL	ucb_hdmheads[ESI]	;Get head and cylinder numbers
	JMP	12$

;Here if drive is not mapped

10$:	CMPL	ucb_csects[ESI], #0
	JE	14$
	CMPL	ucb_cheads[ESI], #0
	JE	14$
	DIVL	ucb_csects[ESI]		;Get sector number
	INCL	EDX
	MOVB	xfr_daddr+0[EBP], DL	;Store sector number
	CLRL	EDX
	DIVL	ucb_cheads[ESI]		;Get head and cylinder numbers
12$:	MOVW	xfr_daddr+1[EBP], AX	;Store cylinder number
	MOVB	xfr_daddr+3[EBP], DL	;Store head number
	JMP	hdkxfer2

;Here if disk configuration is not known - return a sector number equal to
;  the block+1 with head and track = 0.  This will allow access to the first
;  track on a disk even when the configuration is not known.

14$:	INCL	EAX
	CLRL	EDX
	JMP	30$

;Here for LBA mode drive

20$:	TESTB	ucb_bits[ESI], #UB$ATAPI ;ATAPI unit?
	JNE	26$			;Yes - go handle that
	TESTB	ucb_bits[ESI], #UB$48BIT ;Can it use 48-bit LBA?
	JNE	22$			;Yes
	JMP	24$

;Here for 48-bit LBA mode drive

22$:	SHLDL	EDX, EAX, #8		;Get the high bits in the right places
	ANDL	EAX, #0x00FFFFFF	;Remove extra low bits
24$:	ORL	EAX, #0xE0000000	;Set the extra bits we need
	JMP	30$

;Here if ATAPI drive

26$:	MOVL	ECX, ucb_blockshft[ESI]	;Adjust the value if large block
	SUBL	ECX, #9			;  drive
	JE	24$
	SHRDL	EAX, EDX, CL
	SHRL	EDX, CL
30$:	MOVL	xfr_daddr+0[EBP], EAX
	MOVL	xfr_daddr+4[EBP], EDX
.PAGE
hdkxfer2:
	MOVL	EBX, ucb_kcb[ESI]
	CLRL	EAX			;Clear amount transfered
	MOVL	kcb_amount[EBX], EAX
	MOVL	EAX, xfr_buffer[EBP]	;Store buffer pointers
	MOVL	kcb_buffer[EBX], EAX
	MOVL	EAX, xfr_length[EBP]	;Store amount left to transfer
	MOVL	xfr_ttlleft[EBP], EAX
	MOVL	kcb_left[EBX], EAX
	MOVB	DL, xfr_sts1[EBP]
	MOVB	kcb_sts1[EBX], DL
	TESTB	DL, #K1$LIST		;Using a buffer list?
	JE	2$			;No
	MOVL	EAX, #512t		;Yes - get size of one buffer
2$:	MOVL	xfr_bfrleft[EBP], EAX	;Initialize amount left in first buffer
	MOVB	AL, ucb_select[ESI]	;Get drive select value
	MOVL	EDX, ucb_ioreg1[ESI]	;Point to the drive/head register
	A2IOP	P_DCHDDH
	CMPB	xfr_pktcmd1[EBP], #0xFF	;Want a packet command?
	JNE	xferatapi		;Yes
	ORB	AL, xfr_daddr+3[EBP]	;No - merge in head bits
	OUTB	[DX]
	MOVB	AL, #08h		;Get value for the fixed disk
	MOVL	EDX, ucb_ioreg2[ESI]	;  register
	OUTB	[DX]
	MOVB	AL, ucb_hdwpc[ESI]	;Get write precomp value
	MOVL	EDX, ucb_ioreg1[ESI]
	A2IOP	P_DCHDWP
	OUTB	[DX]
	TESTB	ucb_sts1[ESI], #U1$RECAL ;Need to recalibrate now?
	JE	4$			;No - go do transfer

;Here if need to do a restore

xferrst:TOFORK
	MOVB	kcb_itimer[EBX], #TO_RESTORE ;Yes
	MOVB	AL, #10h		;Start a restore operation
	A2IOP	P_DCHDCMD-P_DCHDWP
	OUTB	[DX]
	PUSHL	#-1
	PUSHL	#-1
	PUSHL	#THDS_DW2
	CALL	sysIoWait##		;Wait until done
	TESTL	EAX, EAX
	JS	xferdn			;If error
	MOVL	EBX, ucb_kcb[ESI]
	ANDB	ucb_sts1[ESI], #~U1$RECAL ;OK - indicate restore done
4$:	TESTB	ucb_sts2[ESI], #U2$REMOVED ;Still have a controller?
	JNE	xfernrd			;No
	MOVB	AL, xfr_daddr+0[EBP]	;Give sector number to the controller
	MOVL	EDX, ucb_ioreg1[ESI]
	A2IOP	P_DCHDSEC
	OUTB	[DX]
	IOPAUSE
	MOVB	AL, xfr_daddr+1[EBP]	;Give cylinder number to the controller
	INCL	EDX
	OUTB	[DX]
	IOPAUSE
	MOVB	AL, xfr_daddr+2[EBP]
	INCL	EDX
	OUTB	[DX]
	IOPAUSE
	MOVL	EAX, xfr_length[EBP]	;Assume not format, get sector count
	SHRL	EAX, #9t
	CMPB	xfr_func[EBP], #50h	;Format function?
	JNE	6$			;No
	MOVZBL	EAX, ucb_csects[ESI]	;Yes - fix up the sector count value
6$:	MOVL	ECX, EAX
	A2IOP	P_DCHDSCN-P_DCHDCYH
	OUTB	[DX]			;Give sector count to the controller
	IOPAUSE
	MOVB	kcb_intstate[EBX], #HDIS_ATA ;Set interrupt state
.PAGE
;Here to start the controller doing the transfer

xfergo:	TOFORK
	MOVB	AL, xfr_func[EBP]	;Get function
	A2IOP	P_DCHDCMD-P_DCHDSCN	;Give it to the controller
	OUTB	[DX]
	IMULL	EAX, ECX, #512t		;Get number of bytes to transfer
	TESTB	kcb_sts1[EBX], #K1$OUTPUT ;Output function?
	JE	6$			;No
	ADDL	ucb_blockout[ESI], ECX	;Yes
	ADDL	ucb_byteout[ESI], EAX
	MOVL	ECX, #0x100000		;Don't wait too long here
	A2IOP	P_DCHDSTS-P_DCHDCMD
	IOPAUSE
2$:	INB	[DX]			;Is controller ready for data?
	TESTB	AL, #08
	LOOPE	ECX, 2$			;Wait until ready
	JE	hdknorsp		;Fail if didn't come ready
	PUSHL	ESI			;OK
	MOVL	ESI, kcb_buffer[EBX]	;Get address
	TESTB	kcb_sts1[EBX], #K1$LIST	;Using a buffer list?
	JE	4$
	ADDL	ESI, #bfr_data		;Yes - fix up the data address
4$:	A2IOP	P_DCHDDATA-P_DCHDSTS	;Point to data register
	MOVL	ECX, #256t
	CLD
	ROUTSW	[ESI]			;Output data to controller
	POPL	ESI
	ADDL	kcb_amount[EBX], #512t
	JMP	8$

;Here if doing input

6$:	ADDL	ucb_blockin[ESI], ECX
	ADDL	ucb_bytein[ESI], EAX
8$:	PUSHL	#-1
	PUSHL	#-1
	PUSHL	#THDS_DW2
	CALL	sysIoWait##		;Wait until finished
	MOVL	EBX, ucb_kcb[ESI]

;NEED TO FIX ERROR HANDLING HERE!!!!!!!

	TESTB	ucb_sts2[ESI], #U2$REMOVED ;Still have a controller?
	JNE	xfernrd			;No - fail!
	CMPL	EAX, #ER_NORSP		;Time-out error?
	JE	xferdn			;Yes
	TESTB	kcb_sts1[EBX], #K1$INPUT ;No - doing input?
	JE	14$			;No
	PUSHL	EDI			;Yes
	MOVL	EDI, kcb_buffer[EBX]	;Get address of the buffer
	PUSHL	DS
	POPL	ES
	TESTB	kcb_sts1[EBX], #K1$LIST	;Using a buffer list?
	JE	10$			;No
	ORB	bfr_status[EDI], #BS$FULL ;Yes - indicate buffer is full now
	MOVL	ECX, #256t
	ADDL	EDI, #bfr_data		;Adjust the data address
	JMP	12$

;Here if not transfering a cache buffer

10$:	MOVL	ECX, xfr_length[EBP]	;Get amount to transfer
	SHRL	ECX, #1
12$:	MOVL	EDX, ucb_ioreg1[ESI]
	A2IOP	P_DCHDDATA		;Point to the data register
	CLD
	RINSW	[EDI]			;Input data from controller
	POPL	EDI
	ADDL	kcb_amount[EBX], #512t
14$:	MOVL	EDX, ucb_ioreg1[ESI]
	A2IOP	P_DCHDSTS		;Get controller status
	INB	[DX]
	TESTB	AL, #01h		;Any hard errors?
	JNE	hdkerr			;Yes
	BTL	EAX, #2t		;No - did we have a corrected error?
	ADCL	ucb_tdataerr[ESI], #0
	MOVL	EAX, knlSchCounts##	;Remember when we did this
	MOVL	ucb_acstime[ESI], EAX
	CLRL	EAX
	JMP	xferdn

xfernrd:MOVL	EAX, #ER_NTRDY
	JMP	xferdn

;Here if have time-out waiting for the output buffer

hdknorsp:
	MOVL	EAX, #ER_NORSP
	JMP	xferdn

;Here if have error

hdkerr:	MOVL	EDX, ucb_ioreg1[ESI]
	A2IOP	P_DCHDERR		;Get error byte
	INB	[DX]
	PUSHL	EBX
	MOVL	EBX, #ataerrtbl		;Point to our error table
	MOVL	ECX, #ERRNUM
26$:	TESTB	AL, [EBX]		;This error?
	JNE	28$			;Yes
	ADDL	EBX, #4			;No
	LOOP	ECX, 26$
28$:	MOVXBL	EAX, 1[EBX]		;Get error code
	MOVZWL	EBX, 2[EBX]		;Get offset of error count value
	ADDL	EBX, ESI
	INCL	[EBX]			;Bump both the total and hard
	INCL	4[EBX]			;  error counts
	POPL	EBX
xferdn:	MOVL	ECX, knlSchCounts##	;Remember when we did this
	MOVL	ucb_acstime[ESI], ECX
	LEAVE
	POPL	EBX
	POPL	ESI
	POPL	EDI
	RET	8
.PAGE
;Here to transfer data for an ATAPI drive
;	c(AL) = Drive select value
;	c[DX] = P_DCATAPIDS

xferatapi:
	OUTB	[DX]
	LEAL	EDX, kcb_cmdpkt[EBX]
	MOVZWL	EAX, xfr_pktcmd1[EBP]	;Get the command bytes
	MOVL	[EDX], EAX
	CMPB	AL, #0x43		;Is it a Read TOC command?
	JNE	2$			;No
	MOVL	4[EDX], #0x02000000	;Yes
	MOVL	8[EDX], #0
	TESTB	AH, #0x02		;Want session data?
	JE	8$			;No
	MOVB	2[EDX], #0x02		;Yes - indicate that
	MOVB	9[EDX], #0x80
	JMP	8$

;Here if not a Read TOC command

2$:	MOVL	ECX, xfr_daddr[EBP]	;Get the device address (4 bytes, MSB
	XCHGB	CL, CH			;  first)
	RORL	ECX, #16t
	XCHGB	CL, CH
	MOVL	2[EDX], ECX
	MOVB	6[EDX], #0
	MOVL	ECX, xfr_length[EBP]	;Get the byte count
	CMPB	AL, #0x25		;Is it a Read Capacity command?
	JNE	4$			;No
	CLRL	ECX			;Yes - no count in packet!
4$:	TESTB	kcb_sts1[EBX], #K1$BLKCNT ;Want block count?
	JE	6$			;No
	SHRL	ECX, #9			;Yes
	CMPL	ucb_pblksz[ESI], #1	;Large block device?
	JE	6$			;No
	PUSHL	EDX			;Yes - fix up the block count
	CLRL	EDX
	MOVL	EAX, ECX
	IDIVL	ucb_pblksz[ESI]
	POPL	EDX
	MOVL	ECX, EAX
6$:	XCHGB	CL, CH			;Store count (2 bytes, MSB first)
	MOVW	7[EDX], CX
	MOVB	9[EDX], #0
	MOVW	10t[EDX], #0		;Store the last 2 unused bytes
8$:	CALL	doatapi			;Do the packet command
	JC	12$			;If error
	CLRL	EAX			;OK - all finished
	JMP	xferdn

;Here if error

12$:	CMPL	EAX, #ER_DEVER		;Device error?
	JE	14$			;Yes
	STC				;No - just return this error
	JMP	xferdn

;Here with a device error - Note that since all we use here is the sense code
;  to determine our error code, we don't really need to do a request sense
;  command, but we do one anyway just in case some devices will be unhappy if
;  we don't!  Currently, we ignore almost everything except the sense code
;  (which was actually avaliable from the error register anyway!)

14$:	CALL	dosense
	JC	xferdn			;If error here, just return the error
	MOVB	AL, kcb_sense+0[EBX]	;Get the error code
	ANDB	AL, #0x7F
	CMPB	AL, #0x70		;Normal error?
	JNE	16$			;No - report device driver error (we
					;  should never see a defered error
					;  since we don't use any immediate
					;  commands)
	MOVB	AL, kcb_sense+2[EBX]	;Get the sense key value
	TESTB	AL, #0x20		;Allocation length error?
	JE	18$			;No
16$:	CLRL	EAX			;Yes - this should not be possible!
18$:	ANDL	EAX, #0x0F
	MOVXWL	EAX, atapierrtbl[EAX*2] ;Get our correspnding error code
	CMPL	EAX, #ER_MDCHG		;No - is the error "media changed"?
	JNE	22$			;No
	CMPB	xfr_changed[EBP], #1	;Yes - have we already done this twice?
	JG	22$			;Yes - fail now
	INCB	xfr_changed[EBP]	;No
	TESTB	ucb_sts1[ESI], #U1$MOUNT ;Is the disk mounted now?
	JE	hdkxfer2		;No - don't care about this - try again
22$:	BTL	EAX, #31t
	JMP	xferdn
.PAGE
dosense:LEAL	EAX, kcb_sense[EBX]
	MOVL	kcb_buffer[EBX], EAX
	MOVL	kcb_left[EBX], #18t
	MOVL	xfr_ttlleft[EBP], #18t
	MOVL	xfr_bfrleft[EBP], #18t
	MOVB	kcb_sts1[EBX], #K1$INPUT
	PUSHL	kcb_amount[EBX]
	MOVL	kcb_amount[EBX], #0
	MOVL	EDX, #sensepkt
	CALL	doatapi
	POPL	kcb_amount[EBX]
	RET
.PAGE
;Subroutine to do ATAPI packet command
;	c{EBX} = Offset of KCB
;	c{EDX} = Offset of command packet
;	c{ESI} = Offset of UCB
;	CALL	doatapi
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

doatapi:MOVL	kcb_pktpnt[EBX], EDX	;Save offset of the command packet
	MOVL	EDX, ucb_ioreg1[ESI]
	A2IOP	P_DCATAPIFEAT
	MOVB	AL, #0
	OUTB	[DX]
	IOPAUSE
	A2IOP	P_DCATAPISTS-P_DCATAPIFEAT
	MOVL	ECX, #0x100000
2$:	INB	[DX]
	TESTB	AL, #80h
	JNE	4$
	TESTB	AL, #40h
	JNE	6$
4$:	LOOP	ECX, 2$
	JMP	hdknorsp

;Here with the controller ready for a command

6$:	MOVB	AL, #08h		;Set the disk control register
	MOVL	EDX, ucb_ioreg2[ESI]
	OUTB	[DX]
	MOVL	EDX, ucb_ioreg1[ESI]
	A2IOP	P_DCATAPIFEAT		;Set the features registers
	MOVB	AL, #0
	OUTB	[DX]
	A2IOP	P_DCATAPIDS-P_DCATAPIFEAT ;Set device select register
	MOVB	AL, ucb_select[ESI]
	OUTB	[DX]
	A2IOP	P_DCATAPIBCL-P_DCATAPIDS ;Set the byte count register
	MOVB	AL, xfr_ttlleft+0[EBP]
	OUTB	[DX]
	A2IOP	P_DCATAPIBCH-P_DCATAPIBCL
	MOVB	AL, xfr_ttlleft+1[EBP]
	OUTB	[DX]
	TOFORK
	MOVB	kcb_intstate[EBX], #HDIS_DATA ;Set interrupt state
	A2IOP	P_DCATAPICMD-P_DCATAPIBCH ;Start the packet command
	MOVB	AL, #0A0h
	TESTB	ucb_sts3[ESI], #U3$CMDINT ;Have interrupt command response?
	JE	8$			;No
	MOVB	kcb_intstate[EBX], #HDIS_PKT ;Yes - set interrupt state
	OUTB	[DX]
	JMP	atapiwait		;Continue

;Here if have to poll to see when ready for the command packet

8$:	OUTB	[DX]
	MOVL	ECX, #0x100000
	A2IOP	P_DCATAPISTS-P_DCATAPICMD ;Wait until ready for the packet
10$:	INB	[DX]
	TESTB	AL, #0x08
	LOOPE	ECX, 10$
	JE	hdknorsp
	A2IOP	P_DCATAPIDATA-P_DCATAPISTS
	PUSHL	ESI
	MOVL	ESI, kcb_pktpnt[EBX]
	MOVL	ECX, #6
	CLD
	ROUTSW	[ESI]			;Output the packet
	POPL	ESI			;Restore ESI
					;Fall into atapiwait on next page
.PAGE
;Here to transfer data at fork level

atapiwait:
	PUSHL	#0
	PUSHL	#15t*ST_SECOND
	PUSHL	#THDS_DW2
	CALL	sysIoWait##		;Wait for an interrupt
	TESTL	EAX, EAX
	JS	4$			;If error (can only be ER_NORSP)
	MOVL	EBX, ucb_kcb[ESI]
	TESTB	kcb_ists[EBX], #0x01	;Error indicated?
	JNE	atapierror		;Yes
	TESTB	kcb_ists[EBX], #0x08	;No - need to transfer data now?
	JNE	10$			;Yes
4$:	RET				;No - all finished

;Here if error indicated by the device

atapierror:
	MOVL	EDX, kcb_ioreg1[EBX]	;Make sure unit is selected
	A2IOP	P_DCATAPIDS
	MOVB	AL, ucb_select[ESI]
	OUTB	[DX]
	MOVL	EAX, #ER_DEVER
	STC
	RET

;Here if have impossible condition or device state

atapidvderfk:
	FROMFORK
atapidvder:
	MOVL	EAX, #ER_DVDER		;Report this as a "device driver" error
	STC
	RET

;Here if need to transfer some data

10$:	MOVL	EDX, kcb_ioreg1[EBX]
	A2IOP	P_DCATAPIBCL		;Get amount of data device wants to
	INB	[DX]			;  transfer now
	MOVZBL	ECX, AL
	A2IOP	P_DCATAPIBCH-P_DCATAPIBCL
	INB	[DX]
	MOVB	CH, AL
	CMPL	ECX, xfr_ttlleft[EBP]	;Too much?
	JA	atapidvder		;Yes - fail
	A2IOP	P_DCATAPIDATA-P_DCATAPIBCH ;OK - point to the data register
	CLD
	TOFORK
	TESTB	kcb_ireason[EBX], #0x02	;Does device want to do input?
	JE	atapioutput		;No
					;Yes - fall into atapiinput on next page
.PAGE
;Here if device wants to do input

atapiinput:
	TESTB	kcb_sts1[EBX], #K1$INPUT ;Do we agree?
	JE	atapidvderfk		;No - error!
	PUSHL	DS
	POPL	ES
	PUSHL	EDI
2$:	PUSHL	ECX
	CMPL	ECX, xfr_bfrleft[EBP]	;More than one buffer?
	JBE	4$			;No
	MOVL	ECX, xfr_bfrleft[EBP]	;Yes
4$:	MOVL	EDI, kcb_buffer[EBX]	;Point to the data
	TESTB	kcb_sts1[EBX], #K1$LIST
	JE	6$
	ADDL	EDI, #bfr_data
6$:	MOVL	EAX, ECX
	SHRL	ECX, #1t
	RINSW	[EDI]			;Input data from the controller
	ADDL	kcb_amount[EBX], EAX	;Increase amount done
	SUBL	xfr_ttlleft[EBP], EAX	;Decreate amount left to do
	SUBL	xfr_bfrleft[EBP], EAX
	JG	10$			;If something left in the buffer

	TESTB	kcb_sts1[EBX], #K1$LIST ;Do we have a buffer list?
	JE	10$			;No
	MOVL	EDI, kcb_buffer[EBX]	;Yes
	ORB	bfr_status[EDI], #BS$FULL ;Indicate buffer is full
	MOVL	ECX, bfr_nextxfr[EDI]	;Get offset of next buffer
	MOVL	kcb_buffer[EBX], ECX
	MOVL	xfr_bfrleft[EBP], #512t
10$:	POPL	ECX
	SUBL	ECX, EAX
	JG	2$
	POPL	EDI
	JMP	atapiwait
.PAGE
;Here if device wants to do output

atapioutput:
	TESTB	kcb_sts1[EBX], #K1$INPUT ;Do we agree?
	JNE	atapidvderfk		;No - error!	;;;;;;;;;;;;;
	PUSHL	ESI
2$:	PUSHL	ECX
	CMPL	ECX, xfr_bfrleft[EBP]	;More than one buffer?

	JBE	4$			;No
	MOVL	ECX, xfr_bfrleft[EBP]	;Yes
4$:	MOVL	ESI, kcb_buffer[EBX]	;Point to the data
	TESTB	kcb_sts1[EBX], #K1$LIST
	JE	6$
	ADDL	ESI, #bfr_data
6$:	MOVL	EAX, ECX
	SHRL	ECX, #1t
	ROUTSW	[ESI]			;Input data from the controller
	ADDL	kcb_amount[EBX], EAX	;Increase amount done
	SUBL	xfr_ttlleft[EBP], EAX	;Decreate amount left to do
	SUBL	xfr_bfrleft[EBP], EAX
	JG	10$			;If something left in the buffer
	TESTB	kcb_sts1[EBX], #K1$LIST ;Do we have a buffer list?
	JE	10$			;No
	MOVL	ESI, kcb_buffer[EBX]	;Yes
	MOVL	ECX, bfr_nextxfr[ESI]	;Get offset of next buffer
	MOVL	kcb_buffer[EBX], ECX
	MOVL	xfr_bfrleft[EBP], #512t
10$:	POPL	ECX
	SUBL	ECX, EAX
	JG	2$
	POPL	ESI
	JMP	atapiwait
.PAGE
	.SBTTL	hdkfork - Device fork level routine

;Here at device fork level after operation is complete
;	c{EDI} = Offset of KCB

hdkfork:MOVL	EBX, EDI
	MOVL	EDI, kcb_curdcb[EBX]
	TESTL	EDI, EDI
	JE	4$
	MOVL	ESI, dcb_dkucb[EDI]
	TESTL	ESI, ESI
	JE	6$
	TESTB	ucb_sts2[ESI], #U2$REMOVED
	JNE	6$
	TESTB	kcb_sts1[EBX], #K1$TIMEOUT ;Have a time-out?
	JNE	10$			;Yes
2$:	PUSHL	EDI			;No
	PUSHL	#0
	CALL	sysIoResumeOutput##
4$:	RET

;Here if we have lost the controller

6$:	MOVL	EAX, #ER_NTRDY
	JMP	2$

;Here if have a time-out

10$:	INCL	ucb_hungerr[ESI]
	MOVL	EAX, #ER_NORSP
	JMP	2$
.PAGE
	.SBTTL	hdkaint - Hard disk interrupt routine

;Prototype hard disk interrupt routine - this routine is copied to allocated
;  code segment memory to create a seperate interrupt entry for each controller

hdkaint:PUSHAL				;Save all registers
	PUSHL	DS
	PUSHL	ES
	PUSHL	FS
	PUSHL	GS
	PUSHL	#GS_XDATA
	POPL	DS
fix1:	MOVL	EDI, #0			;Get our KCB
fix2:	JMP	hdkaintcom.L		;Go to common code
HDKAINTSZ=!$-hdkaint

;Common interrupt routine - get here after all registers have been saved on the
;  stack and the offset of the KCB for the controller has been placed in EDI

hdkaintcom:
	MOVL	EAX, kcb_curdcb[EDI]	;Are we expecting this?
	TESTL	EAX, EAX
	JE	12$			;No
	MOVL	EBX, dcb_dkucb[EAX]	;Yes - make sure we still have a
	TESTL	EBX, EBX		;  controller
	JE	14$
	TESTB	ucb_sts2[EBX], #U2$REMOVED
	JNE	14$
	MOVZBL	EAX, kcb_intstate[EDI] ;Dispatch on the interrupt state
	JMPIL	intdsp[EAX*4]

	.MOD	4
intdsp:	.LONG	intata		; HDIS_ATA  = 0 - ATA interrupt
	.LONG	intatapipkt	; HDIS_PKT  = 1 - Ready for ATAPI command packet
	.LONG	intatapidata	; HDIS_DATA = 2 - Ready for ATAPI data transfer

;Here for an ATA mode transfer

intata:	TESTB	kcb_sts1[EDI], #K1$LIST ;Should we transfer data here?
	JE	14$			;No

;Here if doing a buffer list transfer - We do most of these transfers here.
;  The first output transfer and the last input transfer are done at main
;  program level.

	TESTB	kcb_sts1[EDI], #K1$TIMEOUT ;Yes - time-out interrupt?
	JNE	14$			;Yes
	MOVL	EDX, kcb_ioreg1[EDI]	;No - get controller status
	A2IOP	P_DCHDSTS
	INB	[DX]
	TESTB	AL, #01h		;Any hard errors?
	JNE	14$			;Yes - stop now
	TESTB	kcb_sts1[EDI], #K1$INPUT ;Input?
	JE	20$			;No - output
	MOVL	ESI, kcb_buffer[EDI]	;Yes - point to the buffer
	MOVL	ECX, bfr_nextxfr[ESI]	;Get offset of next buffer
	TESTL	ECX, ECX		;Have another one?
	JE	14$			;No - don't transfer any data here
	MOVL	kcb_buffer[EDI], ECX	;Yes
	XCHGL	EDI, ESI
	ORB	bfr_status[EDI], #BS$FULL ;Indicate buffer is full
	ADDL	EDI, #bfr_data
	PUSHL	DS
	POPL	ES
	MOVL	ECX, #256t
	A2IOP	P_DCHDDATA-P_DCHDSTS	;Point to the data register
	CLD
	RINSW	[EDI]			;Input data from the controller
	MOVL	EDI, ESI
	ADDL	kcb_amount[EDI], #512t	;Increase amount done
	JMP	intdone			;Thats all for now

;Here if have an unexpected interrupt

12$:	INCL	kcb_hduxint[EDI]	;Count it
	JMP	intdone

;Here to stop transfer

14$:	MOVB	kcb_itimer[EDI], #0	;Stop the interrupt timer
intfin:	CALL	knlReqFork#
intdone:MOVB	AL, #INT_EOI		;Release interrupt controllers
	CMPB	kcb_intlvl[EDI], #7
	CLI
	JBE	18$
	OUTB	P_INC2P0
18$:	OUTB	P_INC1P0
	JMP	knlDismissInt##		;And dismiss interrupt

;Here if doing output

20$:	MOVL	ESI, kcb_buffer[EDI]	;Get address of this buffer
	MOVL	ESI, bfr_nextxfr[ESI]	;Get address of next buffer
	TESTL	ESI, ESI		;Was this the last one?
	JE	14$			;Yes - finished here
	MOVL	kcb_buffer[EDI], ESI	;No - advance to next buffer
	ADDL	ESI, #bfr_data
	MOVL	ECX, #256t
	A2IOP	P_DCHDDATA-P_DCHDSTS	;Point to the data register
	CLD
	ROUTSW	[ESI]			;Output data to the controller
	ADDL	kcb_amount[EDI], #512t	;Increase amount done
	JMP	intdone
.PAGE
;Here for interrupt for ATAPI unit which is ready to transfer the command
;  packet - Since this is fairly quick, we just do it here.

intatapipkt:
	MOVL	EDX, kcb_ioreg1[EDI]
	A2IOP	P_DCATAPISTS
	INB	[DX]
	TESTB	AL, #01h		;Error indicated by device?
	JNE	intaerr			;Yes
	TESTB	AL, #08h		;No - ready for data?
	JE	intadvder		;No - this should not happen here!
	A2IOP	P_DCATAPIIR-P_DCATAPISTS
	INB	[DX]			;Get interrupt reason value
	TESTB	AL, #01h		;Ready for command?
	JE	intadvder		;No
	TESTB	AL, #02h		;Maybe
	JNE	intadvder		;No
	A2IOP	P_DCATAPIDATA-P_DCATAPIIR ;Yes - output the command packet
	MOVL	ESI, kcb_pktpnt[EDI]
	MOVL	ECX, #6
	CLD
	ROUTSW	[ESI]
	MOVB	kcb_intstate[EDI], #HDIS_DATA ;Update interrupt state
	JMP	intdone			;Finished for now
.PAGE
;Here for interrupt for ATAPI unit which is ready to transfer data - all
;  data transfers are done at fork level

intatapidata:
	MOVL	EDX, kcb_ioreg1[EDI]
	A2IOP	P_DCATAPISTS
	INB	[DX]
	MOVB	kcb_ists[EDI], AL	;Store the status bits
	TESTB	AL, #01h		;Error?
	JNE	6$			;Yes
	A2IOP	P_DCATAPIIR-P_DCATAPISTS ;Yes
	TESTB	AL, #08h		;No - ready for data?
	JE	4$			;No
	INB	[DX]			;Yes - get the interrupt reason byte
	TESTB	AL, #01h		;Expecting data transfer?
	JNE	intadvder		;No
	MOVB	kcb_ireason[EDI], AL	;Yes - store the interrupt reason byte
	JMP	intfin			;Request fork and dismiss interrupt

4$:	INB	[DX]			;Get the interrupt reason byte
	MOVB	kcb_ireason[EDI], AL
	NOTB	AL			;Completion indication?
	TESTB	AL, #03h
	JE	intfin			;Yes
	JMP	intadvder		;No - fail

intaerr:MOVB	kcb_ists[EDI], AL
6$:	A2IOP	P_DCATAPIERR-P_DCATAPISTS
	INB	[DX]
	MOVB	kcb_ierror[EDI], AL
	JMP	intfin			;All finished here

;Here if have impossible condition or device state

intadvder:
	MOVB	kcb_ists[EDI], #0FEh	;Indicate have impossible condition
	JMP	intfin
.PAGE
	.SBTTL	hdkaoas - Once-a-second routine

;Here once each second

hdkaoas:MOVL	EDI, hdkakcb		;Get first HDKA KCB
2$:	CLI
	CMPB	kcb_itimer[EDI], #0	;Is our timer running?
	JE	4$			;No - go on
	DECB	kcb_itimer[EDI]		;Yes - count it down
	JE	8$
4$:	STI
6$:	MOVL	EDI, kcb_nexts[EDI]	;Advance to next KCB
	TESTL	EDI, EDI		;Continue if have another
	JNE	2$
	RET				;Finished

;Here if have hung disk

8$:	ORB	kcb_sts1[EDI], #K1$TIMEOUT ;Indicate time-out error
	TESTB	kcb_sts1[EDI], #K1$RESET ;Already doing reset?
	JNE	10$			;Yes
	ORB	kcb_sts1[EDI], #K1$RESET ;No - indicate doing reset now
	MOVB	kcb_itimer[EDI], #TO_RESET ;Restart interrupt timer
	MOVL	EDX, kcb_ioreg2[EDI]
	MOVB	AL, #0x0C		;Reset the disks
	OUTB	[DX]
	STI
	MOVL	ECX, #20t
	CALL	knlSDelay##
	MOVB	AL, #0Ah
	OUTB	[DX]
	JMP	6$			;Go on

;Here if reset attempt timed out

10$:	CMPL	kcb_curdcb[EDI], #0
	JE	6$
	CLI
	CALL	knlReqFork##		;Force a fork here
	JMP	4$
.PAGE
.IF NE $$CHKLST
checklist:
	PUSHL	EAX
	PUSHL	EBX
	MOVL	EAX, #512t
4$:	MOVL	EBX, bfr_nextxfr[EBX]
	TESTL	EBX, EBX
	JE	6$
	ADDL	EAX, #512t
	JMP	4$

6$:	CMPL	EAX, ECX
	JE	8$
	CRASH	LIST

8$:	POPL	EBX
	POPL	EAX
	RET
.ENDC
.PAGE
	.SBTTL	Data

;ATA error code table

	.MOD	2
ataerrtbl:
	.BYTE	011h, ER_IDFER
	.WORD	ucb_tidferr
	.BYTE	002h, ER_SEKER
	.WORD	ucb_tseekerr
	.BYTE	0C0h, ER_DATER
	.WORD	ucb_tdataerr
	.BYTE	000h, ER_DEVER
	.WORD	ucb_tdeverr
ERRNUM=!{$-ataerrtbl}/4-1

;ATAPI error code table

atapierrtbl:
	.WORD	ER_DVDER	; 0 - No error
	.WORD	0		; 1 - Recovered error (not reported)
	.WORD	ER_NTRDY	; 2 - Not ready
	.WORD	ER_DATER	; 3 - Data error
	.WORD	ER_DEVER	; 4 - Device error
	.WORD	ER_DVDER	; 5 - Illegal request
	.WORD	ER_MDCHG	; 6 - Medial changed or unit reset
	.WORD	ER_WPRER	; 7 - Data protect error
	.WORD	ER_DEVER	; 8 - Reserved
	.WORD	ER_DEVER	; 9 - Reserved
	.WORD	ER_DEVER	;10 - Reserved
	.WORD	ER_DEVER	;11 - Aborted command
	.WORD	ER_DEVER	;12 - Reserved
	.WORD	ER_DEVER	;13 - Reserved
	.WORD	ER_DEVER	;14 - Miscompare (compare is not used)
	.WORD	ER_DEVER	;15 - Reserved

	DATA

	.MOD	4

hdkakcb:.LONG	0		;Offset of first hard disk KCB
temp:	.BLKB	16t		;Temp for getpccard
hwname: .LONG	'DISK', 'hdka'	;IRQ name for sysIoSetInt
	.LONG	0, 0

sensepkt:.LONG	0x03		;Request sense command packet
	 .LONG	18t
	 .LONG	0


blkblk:	.BYTE	0, 0, 0, 8
	.LONG	1
	.BYTE	00, 00, 02, 00

	LKEEND
