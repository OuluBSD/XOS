	.TITLE	usrspace - Routines to access user space for C code

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

	.PROC	80486
	.INCLUD	XOSINC:\xmac\xos.par
	.INCLUD	XOSINC:\xmac\xosx.par
	.INCLUD	XOSINC:\xmac\xostime.par
	.INCLUD	XOSINC:\xmac\xoserr.par
	.INCLUD	XOSINC:\xmac\xosdisk.par
	.INCLUD	XOSINC:\xmac\xosxdisk.par

	CODE

;Function to do ANDB to user space address
;	long XOSFNC sysUSAndByte(
;	    char *addr,
;	    long  data);
;  Value returned is 0 if normal or a negative XOS error code if error

us_addr=!8
us_data=!4

sysUSAndByte::
	MOVL	EDX, us_addr[ESP]
	MOVL	EAX, us_data[ESP]
	IFFAULT	error
	ANDB	[EDX], AL
	CLRL	EAX
	RET	8

;Function to do ORB to user space address
;	long XOSFNC sysUSOrBbyte(
;	    char *addr,
;	    long  data);
;  Value returned is 0 if normal or a negative XOS error code if error

us_addr=!8
us_data=!4

sysUSOrByte::
	MOVL	EDX, us_addr[ESP]
	MOVL	EAX, us_data[ESP]
	IFFAULT	error
	ORB	[EDX], AL
	CLRL	EAX
	RET	8

;Function to add a short to user space location
;	long XOSFNC sysUSAddShort(
;	    short *addr,
;	    long   data);
;  Value returned is 0 if normal or a negative XOS error code if error

us_addr=!8
us_data=!4

sysUSAddShort::
	MOVL	EDX, us_addr[ESP]
	MOVL	EAX, us_data[ESP]
	IFFAULT	error
	ADDW	[EDX], AX
	CLRL	EAX
	RET	8
.PAGE
;Function to get long value from user space address
;	long XOSFNC sysUSGetLLong(
;	    char  *addr,
;	    llong *data);
;  Value returned is 0 if normal or a negative XOS error code if error

us_addr=!8
us_data=!4

sysUSGetLLong::
	MOVL	ECX, us_addr[ESP]
	IFFAULT	error
	MOVL	EAX, [ECX]
	IFFAULT	error
	MOVL	EDX, 4[ECX]
	MOVL	ECX, us_data[ESP]
	MOVL	[ECX], EAX
	MOVL	4[ECX], EDX
	CLRL	EAX
	RET	8

;Function to get long value from user space address
;	long XOSFNC sysUSGetLong(
;	    char *addr,
;	    long *data);
;  Value returned is 0 if normal or a negative XOS error code if error

us_addr=!8
us_data=!4

sysUSGetLong::
	MOVL	EDX, us_addr[ESP]
	IFFAULT	error
	MOVL	EAX, [EDX]
	MOVL	EDX, us_data[ESP]
	MOVL	[EDX], EAX
	CLRL	EAX
	RET	8

;Function to get unsigned short value from user space address
;	long XOSFNC sysUSGetUShort(
;	    char *addr,
;	    long *data);
;  Value returned is 0 if normal or a negative XOS error code if error

us_addr=!8
us_data=!4

sysUSGetUShort::
	MOVL	EDX, us_addr[ESP]
	IFFAULT	error
	MOVZWL	EAX, [EDX]
	MOVL	EDX, us_data[ESP]
	MOVL	[EDX], EAX
	CLRL	EAX
	RET	8

;Function to get signed short value from user space address
;	long XOSFNC sysUSGetSShort(
;	    char *addr,
;	    long *data);
;  Value returned is 0 if normal or a negative XOS error code if error

us_addr=!8
us_data=!4

sysUSGetSShort::
	MOVL	EDX, us_addr[ESP]
	IFFAULT	error
	MOVXWL	EAX, [EDX]
	MOVL	EDX, us_data[ESP]
	MOVL	[EDX], EAX
	CLRL	EAX
	RET	8

;Function to get unsigned byte value from user space address
;	long XOSFNC sysUSGetUByte(
;	    char *addr,
;	    long *data);
;  Value returned is 0 if normal or a negative XOS error code if error

us_addr=!8
us_data=!4

sysUSGetUByte::
	MOVL	EDX, us_addr[ESP]
	IFFAULT	error
	MOVZBL	EAX, [EDX]
	MOVL	EDX, us_data[ESP]
	MOVL	[EDX], EAX
	CLRL	EAX
	RET	8

;Function to get signed byte value from user space address
;	long XOSFNC sysUSGetSByte(
;	    char *addr,
;	    long *data);
;  Value returned is 0 if normal or a negative XOS error code if error

us_addr=!8
us_data=!4

sysUSGetSByte::
	MOVL	EDX, us_addr[ESP]
	IFFAULT	error
	MOVXBL	EAX, [EDX]
	MOVL	EDX, us_data[ESP]
	MOVL	[EDX], EAX
	CLRL	EAX
	RET	8

;Function to store long long value to user space address
;	long XOSFNC sysUSPutLLong(
;	    char  *addr,
;	    llong  data);
;  Value returned is 8 if normal or a negative XOS error code if error

us_addr=!12t
us_data=!4

sysUSPutLLong::
	MOVL	ECX, us_addr[ESP]
	MOVL	EAX, us_data+0[ESP]
	MOVL	EDX, us_data+4[ESP]
	IFFAULT	error
	MOVL	[ECX], EAX
	IFFAULT	error
	MOVL	4[ECX], EDX
	MOVL	EAX, #8
	RET	12t

;Function to store long value to user space address
;	long XOSFNC sysUSPutLong(
;	    char *addr,
;	    long  data);
;  Value returned is 4 if normal or a negative XOS error code if error

us_addr=!8
us_data=!4

sysUSPutLong::
	MOVL	EDX, us_addr[ESP]
	MOVL	EAX, us_data[ESP]
	IFFAULT	error
	MOVL	[EDX], EAX
	MOVL	EAX, #4
	RET	8

;Function to store short value to user space address
;	long XOSFNC sysUSPutShort(
;	    char *addr,
;	    long  data);
;  Value returned is 2 if normal or a negative XOS error code if error

us_addr=!8
us_data=!4

sysUSPutShort::
	MOVL	EDX, us_addr[ESP]
	MOVL	EAX, us_data[ESP]
	IFFAULT	error
	MOVW	[EDX], AX
	MOVL	EAX, #2
	RET	8

;Function to store byte value to user space address
;	long XOSFNC sysUSPutByte(
;	    char *addr,
;	    long  data);
;  Value returned is 1 if normal or a negative XOS error code if error

us_addr=!8
us_data=!4

sysUSPutByte::
	MOVL	EDX, us_addr[ESP]
	MOVL	EAX, us_data[ESP]
	IFFAULT	error
	MOVB	[EDX], AL
	MOVL	EAX, #1
	RET	8

	FAULTHDR
error:	MOVL	EAX, #ER_ADRER
	RET	8
.PAGE
;Function to get unsigned long long value from a varialble length buffer in
;  user space
;	long XOSFNC sysUSGetULLongV(
;	    char  *addr,
;	    llong *data,
;	    long   cnt);
;  Value returned is 0 if normal or a negative XOS error code if error

ugllv_addr=!12t
ugllv_data=!8
ugllv_cnt =!4

sysUSGetULLongV::
	MOVL	EDX, ugllv_data[ESP]
	MOVL	ECX, ugllv_cnt[ESP]
	CMPL	ECX, #8			;Have 8 or more user bytes?
	JBE	4$			;No
	MOVL	ECX, #8			;Yes - just get 8
	JMP	6$

4$:	CLRL	EAX			;Less than 8 - zero our value
	MOVL	[EDX], EAX
	MOVL	4[EDX], EAX
6$:	PUSHL	EDX			;Copy the bytes
	PUSHL	ugllv_addr+4[ESP]
	PUSHL	ECX
	CALL	sysLibMemCpy#
	RET	12t


;Function to get signed long long value from a varialble length buffer in
;  user space
;	long XOSFNC sysUSGetSLLongV(
;	    char  *addr,
;	    llong *data,
;	    long   cnt);
;  Value returned is 0 if normal or a negative XOS error code if error


sgllv_addr=!16t
sgllv_data=!12t
sgllv_cnt =!8

sysUSGetSLLongV::
	PUSHL	EBX
	MOVL	EDX, sgllv_data[ESP]
	MOVL	ECX, sgllv_cnt[ESP]
	CMPL	EBX, #8			;Have 8 or more user bytes?
	JBE	14$			;No
	MOVL	EBX, #8			;Yes - just get 8
	JMP	16$

14$:	CLRL	EAX			;Less than 8 - zero our value
	MOVL	[EDX], EAX
	MOVL	4[EDX], EAX
16$:	TESTL	EBX, EBX
	JE	20$
	PUSHL	EDX			;Copy the bytes
	PUSHL	sgllv_addr+4[ESP]
	PUSHL	EBX
	CALL	sysLibMemCpy#
	TESTL	EAX, EAX
	JS	20$
	MOVL	EDX, sgllv_data[ESP]
	TESTB	-1[EDX+EBX], #0x80	;Is it negative?
	JE	20$			;No
	MOVL	EAX, uvaltbl+4[EBX*4]	;Yes - extend the sign bit
	ORL	[EDX], EAX
	MOVL	EAX, uvaltbl+0[EBX*4]
	ORL	4[EDX], EAX
	CLRL	EAX
20$:	POPL	EBX
	RET	12t


;Function to get unsigned long value from a varialble length buffer in
;  user space
;	long XOSFNC sysUSGetULongV(
;	    char  *addr,
;	    llong *data,
;	    long   cnt);
;  Value returned is 0 if normal or a negative XOS error code if error

uglv_addr=!12t
uglv_data=!8
uglv_cnt =!4

sysUSGetULongV::
	MOVL	EDX, uglv_data[ESP]
	MOVL	ECX, uglv_cnt[ESP]
	CMPL	ECX, #4			;Have 4 or more user bytes?
	JBE	24$			;No
	MOVL	ECX, #4			;Yes - just get 4
	JMP	26$

24$:	MOVL	[EDX], #0		;Less than 4 - zero our value
26$:	PUSHL	EDX			;Copy the bytes
	PUSHL	ugllv_addr+4[ESP]
	PUSHL	ECX
	CALL	sysLibMemCpy#
	RET	12t
.PAGE
;Function to store unsigned long long value to a varialble length buffer in
;  user space
;	long XOSFNC sysUSPutULLongV(
;	    char *addr,
;	    llong data,
;	    long  cnt);
;  Value returned number of bytes stored if normal or a negative XOS error
;    code if error

pllv_addr=!16t
pllv_data=!8
pllv_cnt =!4

sysUSPutULLongV::
	MOVL	ECX, pllv_cnt[ESP]
	CMPL	ECX, #8
	JBE	2$
	MOVL	ECX, #8
2$:	MOVL	EAX, pllv_data+0[ESP]
	MOVL	EDX, pllv_data+4[ESP]	;Get the llong value to store
	TESTL	EAX, uvaltbl+4[ECX*8]	;Will it fit?
	JNE	18$
	TESTL	EDX, uvaltbl+0[ECX*8]
	JNE	18$			;No!
4$:	LEAL	EAX, pllv_data[ESP]
	PUSHL	pllv_addr[ESP]
	PUSHL	EAX
	PUSHL	ECX
	CALL	sysLibMemCpy#
6$:	RET	16t


;Function to store signed long long value to a varialble length buffer in
;  user space
;	long XOSFNC sysUSPutSLLongV(
;	    char *addr,
;	    llong data,
;	    long  cnt);
;  Value returned number of bytes stored if normal or a negative XOS error
;    code if error

sysUSPutSLLongV::
	MOVL	ECX, pllv_cnt[ESP]
	CMPL	ECX, #8
	JBE	10$
	MOVL	ECX, #8
10$:	MOVL	EAX, pllv_data+0[ESP]
	MOVL	EDX, pllv_data+4[ESP]
	ANDL	EAX, svaltbl+4[ECX*8]	;Will it fit?
	JE	12$
	CMPL	EAX, svaltbl+4[ECX*8]
	JNE	18$
12$:	ANDL	EDX, svaltbl+0[ECX*8]
	JE	4$
	CMPL	EDX, svaltbl+0[ECX*8]
	JE	4$
18$:	MOVL	EAX, #ER_PARMS
	JMP	6$
.PAGE
;Function to store unsigned long value to a varialble length buffer in
;  user space
;	long XOSFNC sysUSPutULongV(
;	    char *addr,
;	    long  data,
;	    long  cnt);
;  Value returned number of bytes stored if normal or a negative XOS error
;    code if error

plv_addr=!12t
plv_data=!8
plv_cnt =!4

sysUSPutULongV::
	MOVL	ECX, plv_cnt[ESP]
	CMPL	ECX, #4
	JBE	4$
	MOVL	ECX, #4
4$:	MOVL	EAX, plv_data[ESP]
	TESTL	EAX, uvaltbl+4[ECX*8]	;Will it fit?
	JNE	10$			;No - fail
	PUSHL	plv_addr[ESP]		;Yes - store it
	LEAL	EAX, plv_data+4[ESP]
	PUSHL	EAX
	PUSHL	ECX
	CALL	sysLibMemCpy#
6$:	RET	12t

10$:	MOVL	EAX, #ER_PARMS
	JMP	6$


	.MOD	8
uvaltbl:.LONG	0xFFFFFFFF,0xFFFFFFFF	; 0
	.LONG	0xFFFFFFFF,0xFFFFFF00	; 1
	.LONG	0xFFFFFFFF,0xFFFF0000	; 2
	.LONG	0xFFFFFFFF,0xFF000000	; 3
	.LONG	0xFFFFFFFF,0x00000000	; 4
	.LONG	0xFFFFFF00,0x00000000	; 5
	.LONG	0xFFFF0000,0x00000000	; 6
	.LONG	0xFF000000,0x00000000	; 7
	.LONG	0x00000000,0x00000000	; 8

svaltbl:.LONG	0xFFFFFFFF,0xFFFFFFFF	; 0
	.LONG	0xFFFFFFFF,0xFFFFFF80	; 1
	.LONG	0xFFFFFFFF,0xFFFF8000	; 2
	.LONG	0xFFFFFFFF,0xFF800000	; 3
	.LONG	0xFFFFFFFF,0x80000000	; 4
	.LONG	0xFFFFFF80,0x00000000	; 5
	.LONG	0xFFFF8000,0x00000000	; 6
	.LONG	0xFF800000,0x00000000	; 7
	.LONG	0x80000000,0x00000000	; 8


	END
