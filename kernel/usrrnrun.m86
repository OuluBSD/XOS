	.TITLE	usrrnrun - Routine to load XOS RUN images for execution

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

	.PROC	80486
	.INCLUD	XOSINC:\XMAC\XOS.PAR
	.INCLUD	XOSINC:\XMAC\XOSX.PAR
	.INCLUD	XOSINC:\XMAC\XOSERR.PAR
	.INCLUD	XOSINC:\XMAC\XOSDISK.PAR
	.INCLUD	XOSINC:\XMAC\XOSXDISK.PAR
	.INCLUD	XOSINC:\XMAC\XOSRUN.PAR
	.INCLUD	XOSINC:\XMAC\XOSXRUN.PAR

	CODE
	USERCODE

;When the program to be run is loaded, the registers are setup as follows:
;	c[DS]  = GS_UCODE (0x20)
;	c[SS]  = GS_UCODE (0x20)
;	c[ES]  = GS_UCODE (0x20)
;	c[FS]  = 0
;	c[GS]  = 0
;	c{EAX} = 0
;	c{EBX} = Actual starting address of program (not debugger)
;	c{EDX} = 0
;	c{ECX} = 0
;	c{EDI} = Address of argument area (0xBFFF1000)
;	c{ESI} = 0
;	c{ESP} = Initial user stack pointer
;	c{EIP} = Address of first instruction to execute
;	c{EFR} = 0x00000000
;For a debug load, these values are stored in the returned debug data structure.
.PAGE
	.SBTTL	usrloadrun - Load XOS RUN file as overlay (single msect)

;Here to load single msect from an XOS RUN file as an overlay

usrloadrun::
	MOVL	EAX, #ER_IRFT
	STC
	RET
.PAGE
	.SBTTL	usrrnrun - Load XOS RUN file for execution

;Here if have a XOS RUN file to load - This function is called in the context
;  of the process executing the svcIoRun SVC. It reads and verifies the file
;  header blocks and looks up any imported symbols referenced by the file.
;  Assuming this is all correct, it calls usrrncontext which creates a child
;  process if necessary. If a child process is created, this function returns
;  immediately to the caller. If a child process was not created, this process
;  continues execution in the context of the orginal process and loads the
;  program into that process. If a debug load was indicated, this is non-
;  destructive. (The original memory contains is retained - In this case the
;  loaded program must not attempt to load anything on top of existing memory.)
;  Once the new program is loaded, this function returns to the caller. If a
;  debug load all current memory is given up.

usrrnrun::
	CMPB	run_itype#, #0		;Is the image type known yet?
	JNE	2$			;Yes
	MOVB	run_itype#, #IT_RUN386	;No - store image type now
2$:	BTL	run_option#, #R%DOSEXEC	;Is this a DOS EXEC?
	JNC	6$			;No
	BTL	run_option#, #R%DEBUG	;Yes - is it a debug load?
	JNC	6$			;No
	MOVL	EAX, #ER_FUNC		;Yes - fail!
	STC
4$:	RET

6$:	MOVL	ECX, #6t		;Read next part of file header
	MOVL	EBX, #run_header#+2
	CALL	usrrnrdbytes#
	JC	4$
	MOVZBL	ECX, run_header+ih_hdrsize
	SUBL	ECX, #2
	MOVL	EBX, #run_header+8
	MOVB	AL, run_header#+ih_ver	;Get file version
	CMPB	AL, #1			;Version 1 file?
	JNE	8$			;No
	CMPL	ECX, #18t		;Yes - is the header the right size?
	JNE	badrunf			;No
	CALL	usrrnrdbytes#		;Yes - read rest of header
	JC	4$
	MOVB	AL, run_header#+24t
	MOVB	run_header#+ih_stackms, AL
	MOVL	EAX, run_header#+20t
	MOVL	run_header#+ih_stack, EAX
	MOVB	AL, run_header#+18t
	MOVB	run_header#+ih_debugms, AL
	MOVL	EAX, run_header#+14t
	MOVL	run_header#+ih_debug, EAX
	JMP	14$

;Here if do not have a version 1 file

8$:	CMPB	AL, #2			;Version 2 file?
	JNE	badrunf
	CMPL	ECX, #56t		;Is the header the right size?
	JE	10$			;Yes
	JB	badrunf			;No - fail if too small
	MOVB	CL, #56t
10$:	CALL	usrrnrdbytes#		;Yes - read rest of header
	JC	18$
	MOVZBL	ECX, run_header#+ih_hdrsize ;Need to skip any excess header?
	SUBL	ECX, #58t
	JLE	14$			;No
	CALL	usrrnrdskip#		;Yes
	JC	18$
14$:	MOVB	AL, run_header#+ih_startms ;Do we have someplace to start?
	ORB	AL, run_header#+ih_debugms
	JNE	16$			;Yes - go on
	MOVL	EAX, #ER_NOSAD		;Error = NO Starting ADdress
	STC
	RET

;Here with start address

16$:	CMPB	run_header#+ih_stackms, #0 ;Do we have a stack specified?
	JNE	20$			;Yes
	MOVL	EAX, #ER_NOSTK		;Error = NO STacK
	STC
18$:	RET

;Here with stack specified

20$:	MOVL	run_segpnt#, #run_segtbl# ;Store initial offsets for segment
	MOVL	run_mscpnt#, #run_msctbl# ;  and msect tables
	MOVB	AL, run_header#+ih_numseg ;Store number of segments
	MOVB	run_segcnt#, AL
	CMPB	run_header#+ih_type, #2	;XOS user mode image?
	JE	xosrun			;Yes
badrunf:MOVL	EAX, #ER_IRFF
	STC
ret006:	RET
.PAGE
;Here if have XOS user mode image to load

xosrun:	MOVL	run_nummsc#, #0
2$:	MOVL	ECX, #sh_SIZE		;Get header for segment
	MOVL	EBX, #run_seghdr#
	CALL	usrrnrdbytes#
	JC	ret006
	MOVZBL	ECX, run_seghdr#+sh_hdrsize ;Need to skip any extra bytes?
	SUBL	ECX, #sh_SIZE
	JBE	4$			;No
	CALL	usrrnrdskip#
	JC	ret006
4$:	MOVZBL	EAX, run_seghdr#+sh_nummsc ;Get number of msects
	TESTL	EAX, EAX		;Can't be 0!
5$:	JE	badrunf
	ADDL	run_nummsc#, EAX	;Add into total number of msects
	CMPL	run_nummsc#, #MAXNUMMSC	;Too many?
6$:	JA	badrunf			;Yes - fail
	MOVB	run_msccnt#, AL		;No - store count
	MOVL	ESI, run_segpnt#	;Point to segment data block
	MOVL	rs_nummsc[ESI], EAX
	MOVW	AX, run_seghdr#+sh_select ;Store selector
	CMPW	AX, #0xFFFFFFF8
	JB	7$
	MOVL	EAX, #0xFFF8
7$:	MOVW	rs_select[ESI], AX
	MOVW	rs_spec[ESI], AX
	MOVB	AL, run_seghdr#+sh_type	;Store segment type
	MOVB	rs_type[ESI], AL
	MOVB	AL, run_seghdr#+sh_status ;Store segment status byte
	MOVB	rs_sts[ESI], AL
	MOVB	AL, run_header#+ih_numseg ;Store segment number
	SUBB	AL, run_segcnt#
	INCL	EAX
	MOVB	rs_number[ESI], AL
	MOVZBL	EAX, run_seghdr#+sh_linked ;Get number of linked segment
	TESTL	EAX, EAX		;If none
	JE	8$
	CMPB	AL, rs_number[ESI]	;Really a different segment?
	JE	5$			;No - fail
	CMPB	AL, run_header#+ih_numseg ;Yes - valid value?
	JA	6$			;No - fail
	DECL	EAX			;Yes - get pointer to linked segment
	IMULL	EAX, #rs_SIZE
	ADDL	EAX, #run_segtbl#
8$:	MOVL	rs_linked[ESI], EAX	;Store it
	LEAL	EAX, rs_firstrm[ESI]	;Initialize msect list pointers
	MOVL	run_prevrm#, EAX
10$:	MOVL	ECX, #6			;Get first part of the msect header
	CMPB	run_header#+ih_ver, #1
	JE	11$
	ADDL	ECX, #2
11$:	MOVL	EBX, #run_mschdr#
	PUSHL	ECX
	CALL	usrrnrdbytes#
	POPL	EDX
12$:	JC	ret006
	MOVZBL	ECX, run_mschdr#+mh_hdrsize ;Get size of header
	SUBL	ECX, EDX		;Minus amount already read
	JS	badrunf
	PUSHL	ECX
	CMPL	ECX, #36t-8t
	JBE	13$
	MOVB	CL, #36t-8t
13$:	MOVL	EBX, #run_mschdr#+8
	CALL	usrrnrdbytes#
	POPL	ECX
	JC	12$
	SUBL	ECX, #36t-8t		;Need to skip any extra bytes?
	JBE	14$			;No
	CALL	usrrnrdskip#
	JC	12$
14$:	MOVL	EBX, run_mscpnt#	;Get pointer to our buffer
	MOVL	EAX, run_prevrm#	;Link into msect list for segment
	MOVL	[EAX], EBX
	CLRL	EAX
	MOVL	rm_next[EBX], EAX
	LEAL	EAX, rm_next[EBX]
	MOVL	run_prevrm#, EAX
	MOVL	EAX, run_segpnt#	;Store pointer to segment data
	MOVL	rm_seg[EBX], EAX
	INCL	run_msnum#		;Store msect number
	MOVL	EAX, run_msnum#
	MOVL	rm_num[EBX], EAX
	MOVL	EAX, run_mschdr#+mh_addr ;Get offset or modulus
	TESTB	run_mschdr#+mh_status, #MS$ABS ;Absolute msect?
	JNE	20$			;Yes
	CMPL	EAX, #0xFFFFFFFF
	JE	16$
	ANDL	EAX, #0xFFE00000	;No - make sure modulus value is
					;  reasonable
	JNE	18$			;Is modulus value 0?
16$:	MOVL	EAX, #1			;Yes - make it 1
18$:	MOVL	rm_mod[EBX], EAX	;Store modulus value
	MOVL	rm_base[EBX], #0xFFFFFFFF
	JMP	22$

;Here if offset specified for msect

20$:	ADDL	EAX, #0FFFh		;Round up to page boundry
	ANDL	EAX, #0FFFFF000h
	MOVL	rm_base[EBX], EAX	;Store offset value
	MOVL	rm_mod[EBX], #1		;Make the modulus 1
22$:	MOVL	EAX, run_mschdr#+mh_alloc ;Store amount to allocate
	ADDL	EAX, #0FFFh
	ANDL	EAX, #0FFFFF000h
	MOVL	rm_alloc[EBX], EAX
	MOVL	EAX, run_mschdr#+mh_avail ;Get amount to reserve
	ADDL	EAX, #0FFFh
	ANDL	EAX, #0FFFFF000h
	CMPL	EAX, rm_alloc[EBX]	;Is it big enough?
	JAE	24$			;Yes
	MOVL	EAX, rm_alloc[EBX]	;No
24$:	MOVL	rm_space[EBX], EAX
	MOVL	EAX, run_mschdr#+mh_dataos ;Get offset in file for data
	MOVL	rm_dataos[EBX], EAX
	MOVL	EAX, run_mschdr#+mh_datasz ;Get amount to load
	MOVL	rm_datasz[EBX], EAX
	MOVL	EAX, run_mschdr#+mh_relos ;Get offset in file for relocation
	MOVL	rm_relos[EBX], EAX	  ;  information
	MOVL	EAX, run_mschdr#+mh_relsz ;Get size of relocation information
	MOVL	rm_relsz[EBX], EAX
	ADDL	run_mscpnt#, #rm_SIZE	;Bump msect data pointer
	DECB	run_msccnt#		;More msects for this segment?
	JNE	10$			;Yes - continue
	ADDL	run_segpnt#, #rs_SIZE	;Bump segment data pointer
	DECB	run_segcnt#		;Have another segment to load?
	JNE	2$			;Yes - continue
					;Fall into runrun4 on next page
.PAGE
;Here after finished reading the RUN file header information. We collapse the
;  segmented image into a flat address space. We do this by ignoring any
;  values specified for segment selectors. All code segments are assigned
;  a selector value of GS_UCODE (0x18) and all data segments are assigned
;  a selector value of GS_UDATA (0x20).

runrun4:MOVL	ESI, #run_segtbl#	;Get pointer to segment data
	MOVZBL	ECX, run_header#+ih_numseg ;Get number of segments
	MOVB	run_segcnt#, AL
4$:	CMPB	rs_type[ESI], #ST_CODE	;Is this a code segment?
	JNE	6$			;No
	MOVL	rs_select[ESI], #GS_UCODE|0x03 ;Yes
	JMP	8$

6$:	MOVL	rs_select[ESI], #GS_UDATA|0x03 ;No
8$:	ADDL	ESI, #rs_SIZE		;Bump pointer to the segment data
	LOOP	ECX, 4$			;Conintue if more segments

;Now check and allocate offsets for msects.  Msects for all segments are linked
;  into a single list which is sorted in order of increasing offsets. Then any
;  msects which did not specify an address are assigned addresses above any of
;  the assigned msects.

	MOVL	ESI, #run_segtbl#	;Reset segment data pointer
	MOVZBL	ECX, run_header#+ih_numseg ;Reset segment count
	MOVL	EDX, #run_mscpnt#
14$:	MOVL	EBX, rs_firstrm[ESI]
16$:	TESTL	EBX, EBX
	JE	18$
	MOVL	[EDX], EBX
	LEAL	EDX, rm_next[EBX]
	MOVL	EBX, rm_next[EBX]
	JMP	16$

18$:	ADDL	ESI, #rs_SIZE
	LOOP	ECX, 14$

;Here with all msects linked into a single list - Now sort this list in order
;  of the addresses.

20$:	MOVL	EDX, #run_mscpnt#	;Get address of pointer to first msect
	MOVL	EDI, [EDX]
	CLRL	ECX			;Clear swapped indicator
22$:	MOVL	EBX, rm_next[EDI]	;Anything left to compare?
	TESTL	EBX, EBX
	JE	28$			;No - go see if more sorting needed
	MOVL	EAX, rm_base[EDI]	;Yes - need to swap here?
	CMPL	rm_base[EBX], EAX
	JAE	26$			;No
	MOVL	EAX, rm_next[EBX]	;Yes - do it
	MOVL	rm_next[EDI], EAX
	MOVL	rm_next[EBX], EDI
	MOVL	[EDX], EBX
	MOVL	EDI, EBX
	INCL	ECX			;Indicate swap done
26$:	MOVL	EDI, rm_next[EDI]	;Advance to next block
	JMP	22$			;And continue

;Here when finished with scan of the msects

28$:	TESTL	ECX, ECX		;Did we do any swaps this time?
	JNE	20$			;Yes - go do it all again

;Here with the msects sorted - now check for conflicts

	MOVL	EDI, run_mscpnt#
	MOVL	EDX, #0x1000		;Start allocating at the second page if
					;  no offsets at all specified
30$:	MOVL	EAX, rm_base[EDI]	;Was an offset specified?
	CMPL	EAX, #0xFFFFFFFF
	JNE	32$			;Yes - use it
	MOVL	EAX, EDX		;No - use next available offset
	ADDL	EAX, rm_mod[EDI]	;Round up to modulus
	DECL	EAX
	CLRL	EDX
	DIVL	rm_mod[EDI]
	IMULL	EAX, rm_mod[EDI]
	MOVL	rm_base[EDI], EAX	;Store as base offset for msect
32$:	ADDL	EAX, rm_space[EDI]	;Get highest offset needed here
	CMPL	EAX, #humrundata	;Is it too big?
	JA	memcnflt		;Yes - fail
	MOVL	EDX, EAX		;Remember it for allocation
	MOVL	EAX, rm_base[EDI]	;Get actual top for overlap check
	ADDL	EAX, rm_alloc[EDI]
	MOVL	EDI, rm_next[EDI]	;No - advance to next msect
	TESTL	EDI, EDI		;More to check?
	JE	loadrdy			;No
	CMPL	EAX, rm_base[EDI]	;Yes - does next msect conflict?
	JBE	30$			;No - continue
memcnflt:				;Here if have memory conflict
	MOVL	EAX, #ER_MACFT
retsc8:	STC
ret008:	RET
.PAGE
;Here when ready to actually load data from the RUN file.  All segment and
;  msect headers have been read.

loadrdy:MOVL	EDX, run_header#+ih_importos ;Have any imported symbols?
	TESTL	EDX, EDX
2$:	JE	loadrd2			;No - go on
	MOVL	EAX, run_header#+ih_importno ;Yes - get number of symbols
	TESTL	EAX, EAX		;(just to be safe!)
	JE	2$
	MOVL	run_relitem#, EAX
	MOVL	EAX, run_free#		;Store offset of symbol table we will
	MOVL	run_symtbl#, EAX	;  construct here
	CALL	usrrnrdbyte1r#		;Read the first header byte
	JC	8$			;If error
4$:	CALL	usrrnrdname#		;Get symbol name
	JC	8$			;If error
	CMPL	run_symsize#, #4t	;Is the name long enough?
	JB	undfsym			;No - fail
	MOVL	EAX, run_symname#	;Yes - get the prefix part
	ANDL	EAX, #0xFFFFFF
	MOVL	EDX, #knlExportTable	;Set up to search the prefix table
6$:	CMPL	EAX, 4[EDX]		;This one?
	JE	10$			;Yes
	MOVL	EDX, [EDX]		;No - advance to next entry
	TESTL	EDX, EDX
	JNE	6$			;Continue if more to check
undfsym::				;Can put a breakpoint here for debugging
	MOVL	EAX, #ER_IRFSU
	STC
8$:	RET

;Here with match on the symbol prefix

10$:	MOVL	EAX, 12t[EDX]		;Get number of entries in table
	MOVL	run_relcnt#, EAX
	ADDL	EDX, #16t		;Get offset of table
	MOVZBL	EAX, run_symsize#	;Get length of the symbol
	SUBL	EAX, #4t		;Minus 4
	CLD
12$:	MOVB	CL, 1[EDX]		;Might it be this one?
	ANDL	ECX, #0x1F
	CMPB	AL, CL
	JNE	14$			;No
	LEAL	EDI, 2[EDX]		;Yes
	MOVL	ESI, #run_symname#+3
	INCL	ECX
	RECMPSB	[EDI], [ESI]		;Compare names
	JE	20$			;If match
14$:	MOVZBL	ECX, [EDX]		;Not this one - advance to next
	ADDL	EDX, ECX
	DECL	run_relcnt#		;More to check?
	JNE	12$			;Yes - continue
	JMP	undfsym			;No - fail

;Here with match on symbol name

20$:	MOVZBL	EAX, 1[EDX]		;Get length of symbol - 1
	ANDL	EAX, #0x1F
	MOVZBL	ECX, [EDX]		;Get total length
	SUBL	ECX, EAX
	SUBL	ECX, #3
	CMPL	ECX, #4			;Is the length valid?
	JA	24$			;No - fail
	JMPIL	symosd[ECX*4]

	.MOD	4
symosd:	.LONG	osf0
	.LONG	osf1
	.LONG	osf2
	.LONG	osf3
	.LONG	osf4

24$:	MOVL	EAX, #ER_IFXST
	STC
	RET

osf0:	CLRL	EAX
	TESTB	1[EDX], #20h
	JE	26$
	DECL	EAX
	JMP	26$

osf1:	MOVZBL	EAX, [EDI]
	INCL	EDI
	TESTB	1[EDX], #0x20
	JE	26$
	ORL	EAX, #0xFFFFFF00
	JMP	26$

osf2:	MOVZWL	EAX, [EDI]
	ADDL	EDI, #2
	TESTB	1[EDX], #0x20
	JE	26$
	ORL	EAX, #0xFFFF0000
	JMP	26$

osf3:	MOVZWL	EAX, 1[EDI]
	SHLL	EAX, #8
	MOVB	AL, [EDI]
	ADDL	EDI, #3
	TESTB	1[EDX], #0x20
	JE	26$
	ORL	EAX, #0xFF000000
	JMP	26$

osf4:	MOVL	EAX, [EDI]
	ADDL	EDI, #4
26$:
	PUSHL	EAX
	MOVL	ECX, #4
	CALL	usrrngetmem#		;Allocate memory for table entry
	JC	30$			;If error
	POPL	[EDI]			;Store symbol value in table
	DECL	run_relitem#		;More symbols?
	JE	loadrd2			;No - all done with this
	CALL	usrrnrdbyte1s#		;Yes - discard next header byte
	JNC	4$			;Continue if OK
ret012:	RET				;If error

;Here if error allocating memory for symbol table entry

30$:	POPL	EDX			;Fix up the stack
	POPL	EDX
	RET
.PAGE
loadrd2:CALL	usrrncontext#		;Get into correct context to finish
	TESTL	EAX, EAX
	JNE	ret012			;If finished or error

;Here in correct context to load program - There are three possible situations:
;  1) Normal load to the same process - In this case all user memory has been
;     given up. ESP now points to a stack in the run data area. If the load is
;     successful, the loaded program is started. If there is an error, the
;     process is terminated with the error code as the termination status.
;  2) Debug load to the same process - In this case existing user memory is
;     unchanged. ESP is unchanged. If the load is successful, a normal return
;     from usrrnrun is given. If an error, an error return from usrrnrun is
;     given.
;  3) Normal load to a child process - In this case we are executing in a
;     new process. ESP now points to a stack in the run data area. If the load
;     is successful, the loaded program is started. if there is an error, the
;     process is terminated with the error code as the termination status. In
;     either case, the parent process is notified if necessary.

2$:	MOVL	EAX, #run_msctbl# ;Reset data block pointer
	MOVL	run_mscpnt#, EAX
	MOVB	AL, run_nummsc#
	MOVB	run_msccnt#, AL
loadmsc:MOVL	EBX, run_mscpnt#
	CMPL	rm_alloc[EBX], #0	;Anything to allocate for this one?
	JE	6$			;No - skip it!
	PUSHL	rm_base[EBX]		;Yes - get address for msect
	PUSHL	#PG$WRITE|PG$READ	;Make it a read/write msect
	PUSHL	rm_alloc[EBX]		;Get number of memory blocks needed
	CALL	svcMemChange#		;Allocate memory for the msect
	TESTL	EAX, EAX
	JS	runfail			;If error
	MOVL	EBX, run_mscpnt#	;Get pointers again
	MOVL	EDX, rm_dataos[EBX]	;Get offset in file for data
	MOVL	ECX, rm_datasz[EBX]	;Get amount to load
	MOVL	EBX, rm_base[EBX]	;Get address to load into
	CALL	usrrnrdblkr#		;Read the data for the msect
	JC	runfail			;If error
6$:	ADDL	run_mscpnt#, #rm_SIZE	;Bump buffer pointer
	DECB	run_msccnt#		;Have another msect to load?
	JNE	loadmsc			;Yes - go load load it
					;No - continue on next page
.PAGE
	MOVL	run_mscpnt#, #run_msctbl ;Reset data block pointer
	MOVB	AL, run_nummsc#		;And count
	MOVB	run_msccnt#, AL
relmsc:	MOVL	EBX, run_mscpnt#	;Get pointer to msect data
	MOVL	EAX, rm_relsz[EBX]	;Have any relocation information?
	TESTL	EAX, EAX
	JE	reldone			;No - go on
	MOVL	run_relcnt#, EAX	;Yes - store count
	MOVL	EAX, rm_base[EBX]	;Initialize offset for relocation
	MOVL	run_apply#+0, EAX
	MOVL	EDX, rm_relos[EBX]	;Get offset in file for relocation
	CALL	usrrnrdbyte1r#		;Read the first header byte
	JC	runfail
relloop:MOVB	run_reltype#, AL	;Save the byte
	MOVB	run_temp#, AL		;Save size of offset field
	ANDB	run_temp#, #3
	CMPB	run_header#+ih_ver, #1	;Version 1 file?
	JNE	10$			;No - must be version 2
	SHRB	AL, #2			;Get item number
	ANDB	AL, #7
	CMPB	AL, #7			;Need more than 3 bits?
	JNE	2$			;No
	CALL	usrrnrdbyte1s#		;Yes - read another byte
	JC	runfail			;If error
2$:	TESTB	AL, AL			;Make sure not 0
	JE	badreloc
	CALL	getdelta		;Get delta value
	JC	runfail
	SHRB	DL, #5
	JE	badreloc
	TESTL	EAX, EAX
	JE	badreloc
	CMPL	EAX, run_nummsc#
	JA	badreloc
	IMULL	EAX, #rm_SIZE		;Change to index into data table
	JMPIL	relcdsp-4[EDX*4]

;Dispatch table for version 1 relocation type

	.MOD	4
relcdsp:.LONG	relam16ofs	; 1 - 16 bit absolute msect offset
	.LONG	relam32ofs	; 2 - 32 bit absolute msect offset
	.LONG	relrm16ofs	; 3 - 16 bit relative msect offset
	.LONG	relrm32ofs	; 4 - 32 bit absolute msect offset
	.LONG	badreloc	; 5 - Illegal
	.LONG	badreloc	; 6 - Illegal
	.LONG	badreloc	; 7 - Illegal

;Here for version 2 relocation

10$:	CALL	getvarval		;Get item number
	JC	runfail			;If error
	CALL	getdelta		;Get the delta value
	JC	runfail
	MOVL	ECX, EDX
	SHRL	EDX, #2t
	ANDL	EDX, #03h
	JMPIL	kinddsp[EDX*4]		;Dispatch on the relocation kind

	.MOD	4
kinddsp:.LONG	badreloc	; 0 - Segment
	.LONG	rel2msect	; 1 - Msect
	.LONG	rel2sym		; 2 - Symbol
	.LONG	badreloc	; 3 - Illegal

;Here if relocation specified with an msect

rel2msect:
	TESTL	EAX, EAX		;Valid msect number?
	JE	badreloc		;No
	CMPL	EAX, run_nummsc#	;Maybe
	JA	badreloc		;No
	IMULL	EAX, #rm_SIZE		;Yes - change to index into data table
	SHRL	ECX, #4			;Get relocation type
	ANDL	ECX, #0x0F
	JMPIL	typemsdsp[ECX*4]	;Dispatch on the type

typemsdsp:
	.LONG	badreloc	; 0 - Selector
	.LONG	badreloc	; 1 - Illegal
	.LONG	badreloc	; 2 - Illegal
	.LONG	badreloc	; 3 - Illegal
	.LONG	relam8ofs	; 4 - 8-bit absolute offset
	.LONG	relrm8ofs	; 5 - 8-bit relative offset
	.LONG	relam16ofs	; 6 - 16-bit absolute offset
	.LONG	relrm16ofs	; 7 - 16-bit relative offset
	.LONG	relam32ofs	; 8 - 32-bit absolute offset
	.LONG	relrm32ofs	; 9 - 32-bit relative offset
	.LONG	relam16adr	;10 - 16-bit address
	.LONG	relam32adr	;11 - 32-bit address
	.LONG	relam16adr	;12 - 16-bit address
	.LONG	badreloc	;13 - Illegal
	.LONG	relam32adr	;14 - 32-bit address
	.LONG	badreloc	;15 - Illegal

;Here if relocation is specified with a symbol value

rel2sym:
	TESTL	EAX, EAX		;Valid symbol number?
	JE	badreloc		;No
	CMPL	EAX, run_header+ih_importno ;Maybe
	JA	badreloc		;No - fail
	MOVL	EDX, run_symtbl#	;Yes
	SHRL	ECX, #4
	ANDL	ECX, #0x0F
	JMPIL	typesymdsp[ECX*4]

typesymdsp:
	.LONG	badreloc	; 0 - Selector
	.LONG	badreloc	; 1 - Illegal
	.LONG	badreloc	; 2 - Illegal
	.LONG	badreloc	; 3 - Illegal
	.LONG	relasym8ofs	; 4 - 8-bit absolute offset
	.LONG	relrsym8ofs	; 5 - 8-bit relative offset
	.LONG	relasym16ofs	; 6 - 16-bit absolute offset
	.LONG	relrsym16ofs	; 7 - 16-bit relative offset
	.LONG	relasym32ofs	; 8 - 32-bit absolute offset
	.LONG	relrsym32ofs	; 9 - 32-bit relative offset
	.LONG	badreloc	;10 - 16-bit address
	.LONG	badreloc	;11 - 32-bit address
	.LONG	badreloc	;12 - 16-bit absolute address
	.LONG	badreloc	;13 - Illegal
	.LONG	badreloc	;14 - 32-bit absolute address
	.LONG	badreloc	;15 - Illegal

;Here to relocate using absolute 8-bit offset value for symbol

relasym8ofs:
	MOVL	EAX, 0-4[EDX+EAX*4]	;Get offset
	JMP	rel8			;Go relocate it

;Here to relocate using absolute 16-bit offset value for symbol

relasym16ofs:
	MOVL	EAX, 0-4[EDX+EAX*4]	;Get offset
	JMP	rel16			;Go relocate it


;Here to relocate using absolute 32-bit offset value for symbol

relasym32ofs:
	MOVL	EAX, 0-4[EDX+EAX*4]	;Get offset
	JMP	rel32			;Go relocate it

;Here to relocate using relative 8-bit offset value for symbol

relrsym8ofs:
	MOVL	EAX, 0-4[EDX+EAX*4]	;Get offset
	JMP	rel8r			;Go relocate it

;Here to relocate using relative 16-bit offset value for symbol

relrsym16ofs:
	MOVL	EAX, 0-4[EDX+EAX*4]	;Get offset
	JMP	rel16r			;Go relocate it

;Here to relocate using relative 32-bit offset value for symbol

relrsym32ofs:
	MOVL	EAX, 0-4[EDX+EAX*4]	;Get offset
	JMP	rel32r			;Go relocate it
.PAGE
;Here to relocate 8-bit absolute msect offset

relam8ofs:
	MOVL	EAX, run_msctbl#+rm_base-rm_SIZE[EAX] ;Get base of msect
	JMP	rel8

;Here to relocate 16-bit absolute msect address

relam16adr:
	MOVL	ECX, run_msctbl#+rm_seg-rm_SIZE[EAX]
	MOVL	ECX, rs_select[ECX] ;Get selector
	ADDW	2[ESI], CX		;Relocate it
					;Fall into relam16ofs

;Here to relocate 16-bit absolute msect offset

relam16ofs:
	MOVL	EAX, run_msctbl#+rm_base-rm_SIZE[EAX] ;Get base of msect
	JMP	rel16

;Here to relocate 32-bit absolute msect address

relam32adr:
	MOVL	ECX, run_msctbl#+rm_seg-rm_SIZE[EAX]
	MOVL	ECX, rs_select[ECX] ;Get selector
	ADDW	4[ESI], CX		;Relocate it
					;Fall into relam32ofs

;Here to relocate 32-bit absolute msect offset

relam32ofs:
	MOVL	EAX, run_msctbl#+rm_base-rm_SIZE[EAX] ;Get base of msect
	JMP	rel32

;Here to relocate 8-bit relative msect offset

relrm8ofs:
	MOVL	EAX, run_msctbl#+rm_base-rm_SIZE[EAX] ;Get base of msect
rel8r:
	SUBL	EAX, ESI
;;;;;	SUBL	EAX, rm_base[EBX]	;Minus base of msect being relocated

rel8:
;;;;;	MOVB	DL, [ESI]
;;;;;	MOVB	CL, #8t

	ADDB	[ESI], AL		;Do the relocation
	JMP	relnext			;Done with this item

;Here to relocate 16-bit relative msect offset

relrm16ofs:
	MOVL	EAX, run_msctbl#+rm_base-rm_SIZE[EAX] ;Get base of msect
rel16r:
	SUBL	EAX, ESI
;;;;;	SUBL	EAX, rm_base[EBX]	;Minus base of msect being relocated

rel16:	MOVW	DX, [ESI]
	MOVB	CL, #16t
	ADDW	[ESI], AX		;Do the relocation
	JMP	relnext			;Done with this item

;Here to relocate 32-bit relative msect offset

relrm32ofs:
	MOVL	EAX, run_msctbl#+rm_base-rm_SIZE[EAX] ;Get base of msect
rel32r:
	SUBL	EAX, ESI
;;;;;	SUBL	EAX, rm_base[EBX]	;Minus base of msect being relocated

rel32:
;;;;;	MOVL	EDX, [ESI]
;;;;;	MOVB	CL, #32t

	ADDL	[ESI], EAX		;Do the relocation
relnext:JNO	8$			;Go on if no overflow
	MOVL	EAX, #ER_DATTR		;Indicate relocation truncation
	JMP	runfail

8$:	DECL	run_relcnt#		;More relocation to do here?
	JE	reldone			;No
	CALL	usrrnrdbyte1s#		;Read one byte (sequential)
	JNC	relloop			;OK - continue
	JMP	runfail			;If error

;Here with invalid relocation data

badreloc:
	MOVL	EAX, #ER_IRFRD		;Indicate relocation error

;Here if have error - return from usrrnrun or terminate this process depending
;  on the type of load being done
;	c{EAX} = Error code

runfail:BTL	run_option#, #R%DEBUG	;Is this a debug load?
	JC	4$			;Yes - just return from usrrnrun
	BTL	run_option#, #R%SAMEPROC ;No - is this a child process?
	JC	2$			;No
	PUSHL	EAX
	PUSHL	EAX
	CALL	usrrnfinish#
	POPL	EAX
2$:	ANDL	EAX, #0FFFFFFh		;No - put the termination code in the
	ORL	EAX, #TC_RUNFAIL<24t	;  high eight bits
	PUSHL	EAX			;Terminate this process
	CALL	svcSchExit#

4$:	RET
.PAGE
;Here when finished doing relocation for an msect - if this is the last msect
;  in its segment we now make sure the segment is set up correctly

reldone:ADDL	run_mscpnt#, #rm_SIZE	;Bump buffer pointer
	DECB	run_msccnt#		;Have another msect to relocate?
	JNE	relmsc			;Yes - go relocate it

;Here with program loaded without any errors

loadok:	MOVL	EAX, run_loadhndl#	;Get device handle
	CALL	usrrnclose#		;Close the file
	BTL	run_option#, #R%DEBUG	;Is this a debug load?
	JC	rundebg			;Yes
	MOVL	EBX, #run_header#+ih_stack
	CALL	reladdr			;Relocate user stack address
	MOVL	ESP, EAX		;Switch to the program's stack
	MOVL	EBX, #run_header#+ih_debug ;Assume have debugger address
	CMPB	4[EBX], #0		;Right?
	JNE	6$			;Yes
	MOVL	EBX, #run_header#+ih_start ;No - use program start address
6$:	CALL	reladdr			;Relocate the address
	CLRL	ECX
	PUSHL	ECX			;Store item count and vector number
	PUSHL	ECX			;Store EFR value
	PUSHL	CS			;Stack the intial CS value
	PUSHL	EAX			;Stack the inital EIP value
	PUSHL	DS			;Store DS value
	PUSHL	DS			;Store ES value
	PUSHL	ECX			;Store FS value
	PUSHL	ECX			;Store GS value
	MOVL	EBX, #run_header#+ih_start
	CALL	reladdr			;Relocate actual program start address
	PUSHL	EAX
	PUSHL	#0
	CALL	usrrnfinish#
	PUSHL	#humrundata		;Give up our data page
	PUSHL	#0
	PUSHL	#0
	CALL	svcMemChange#
	POPL	EBX			;Get program start address in the
					;  right register
	MOVL	EDI, #humarea		;Get address of the HUM msect
	CLRL	EAX			;Clear unused registers
	CLRL	ECX			;Start the program (we must use an
	CLRL	EDX
	CLRL	ESI			;  svcSchDismiss call here instead
	CLRL	EBP			;  of a simple RETF to clear the
	INT	knl_DISMISS#		;  set-up state of this process)
.PAGE
;Here for debug load of protected mode RUN file

rundebg:CALL	strdebg			;Store relocation data
	JC	rel014
	MOVL	rd_ES[EDI], DS		;Put address of argument msect in EDI
	MOVL	rd_DS[EDI], DS
	MOVL	rd_SS[EDI], DS
	MOVL	rd_CS[EDI], CS
	MOVL	rd_EDI[EDI], #humarea
	MOVL	EBX, #run_header#+ih_stack
	CALL	reladdr			;Relocate user stack address
	MOVL	rd_ESP[EDI], EAX
	MOVL	EBX, #run_header#+ih_start
	CALL	reladdr			;Relocate program start address
	MOVL	rd_EBX[EDI], EAX
	MOVL	EBX, #run_header#+ih_debug ;Assume have debugger address
	CMPB	run_header#+ih_debug+4, #0 ;Right?
	JNE	6$			;Yes
	MOVL	EBX, #run_header#+ih_start ;No - use program start address
6$:	CALL	reladdr			;Relocate the address
	MOVL	rd_EFR[EDI], #0x0200	;Store initial EFR value
	MOVL	rd_EIP[EDI], EAX
debgdn:	PUSHL	#0
	CALL	usrrnfinish#		;Finish up
	PUSHL	#humrundata		;Give up our data page
	PUSHL	#0
	PUSHL	#0
	CALL	svcMemChange#
	CLRL	EAX
rel014:	RET
.PAGE
;Subroutine to get delta value for relocation
;	c(AL) = Item number
;	CALL	getdelta
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Item number
;	  c{EDX} = Header byte value
;	  c{ESI} = Offset for relocation

getdelta:
	MOVL	run_relitem#, EAX	;Save item number
	CLRL	EAX
	MOVL	run_delta#, EAX
	CALL	usrrnrdbyte1s#		;Get byte for delta value
	JC	4$			;If error
	MOVB	run_delta#+0, AL
	DECB	run_temp#		;Need more?
	JS	2$			;No
	CALL	usrrnrdbyte1s#		;Yes - get next byte for delta value
	JC	4$			;If error
	MOVB	run_delta#+1, AL
	DECB	run_temp#		;Need more?
	JS	2$			;No
	CALL	usrrnrdbyte1s#		;Yes - get next byte for delta value
	JC	4$			;If error
	MOVB	run_delta#+2, AL
	DECB	run_temp#		;Need more?
	JS	2$			;No
	CALL	usrrnrdbyte1s#		;Yes - get next byte for delta value
	JC	4$			;If error
	MOVB	run_delta#+3, AL
2$:	MOVL	EAX, run_delta#
	ADDL	run_apply#, EAX
	MOVL	EBX, run_mscpnt#	;Point to data for msect being relocated
	MOVL	ESI, rm_seg[EBX]	;Point to data for its segment
	MOVW	FS, rs_select[ESI]	;Get its selector
	MOVL	ESI, run_apply#		;Get offset for relocation
	MOVZBL	EDX, run_reltype#	;Get relocation type
	MOVL	EAX, run_relitem#
	CLC
4$:	RET
.PAGE
getvarval:
	CALL	usrrnrdbyte1s#		;Get first byte
	JC	2$
	TESTB	AL, #80h		;Single byte value?
	JE	2$			;Yes
	SHLL	EAX, #8t		;No
	PUSHL	EAX
	CALL	usrrnrdbyte1s#
	JC	4$
	MOVB	[ESP], AL
	TESTB	1[ESP], #40h		;Two byte value?
	JE	6$			;Yes
	SHLL	[ESP], #8t		;No
	CALL	usrrnrdbyte1s#
	JC	4$
	MOVB	[ESP], AL
	TESTB	2[ESP], #20h		;Three byte value?
	JE	8$			;Yes
	SHLL	[ESP], #8t		;No
	CALL	usrrnrdbyte1s#
	JC	4$
	MOVB	[ESP], AL
	POPL	EAX
2$:	RET

;Here if error

4$:	POPL	EDX
	RET

;Here if have a two byte value

6$:	POPL	EAX
	ANDL	EAX, #3FFFh
	RET

;Here if have a three byte value

8$:	POPL	EAX
	ANDL	EAX, #1FFFFFFFh
	RET
.PAGE
;Subroutine to get relocated address for protected mode
;	c{EBX} = Address of address to fix
;	CALL	reladdr
;	c{EAX} = Relocated offset value

reladdr:MOVZBL	EAX, 4[EBX]		;Get msect number
	IMULL	EAX, #rm_SIZE		;Change to index
	MOVL	EAX, run_msctbl#+rm_base-rm_SIZE[EAX] ;Get base of msect
	ADDL	EAX, [EBX]		;Get relocated value
	RET
.PAGE
;Subroutine to store relocation data in the user's relocation buffer
;	CALL	strdebg
;	c{EDI} = Address of relocation data buffer

;The rd_data part of the relocation buffer consists of a list of longs giving
;  the selector for each segment followed by a list of msect data items as
;  follows:
;	long  segment_number;
;	long  base_offset;
;	long  offset;
;	long  not_used;

strdebg:SUBL	run_rlbsize#, #rd_data	;Is there enough room for the data?
	JB	14$			;No - fail
	MOVL	EDI, run_rlbaddr#	;Yes - point to his relocation data
					;  block
	MOVL	EDX, run_nummsc#	;Get number of msects
	MOVW	rd_nmsect[EDI], DX
	MOVZBL	ECX, run_header#+ih_numseg ;Get number of segments
	MOVW	rd_nseg[EDI], CX
	ADDL	EDI, #rd_data		;Point to start of data area
	MOVL	EBX, #run_segtbl#	;Point to start of segment table
	PUSHL	DS
	POPL	ES
	CLD
4$:	SUBL	run_rlbsize#, #4	;Have room for next entry?
	JB	14$			;No - fail
	MOVZWL	EAX, rs_spec[EBX]	;Get selector for segment
	STOSL	[EDI]			;Store it in his data block
	ADDL	EBX, #rs_SIZE		;Bump pointer
	LOOP	ECX, 4$			;Continue if more segments
	MOVL	EBX, #run_msctbl#	;Point to start of msect table
	MOVL	ECX, EDX		;Get number of msects
	CLRL	EDX
10$:	PUSHL	EDI
	MOVL	EAX, rm_num[EBX]	;Get msect number
	SHLL	EAX, #4t		;Calculate offset for data
	LEAL	EDI, -16t[EDI+EAX]
	CMPL	EAX, run_rlbsize#	;Have enough room?
	JA	12$			;No - fail!
	MOVL	EAX, rm_seg[EBX]	;Yes - get segment number
	MOVZBL	EAX, rs_number[EAX]
	STOSL	[EDI]
	MOVL	EAX, rm_base[EBX]	;Get offset for msect
	STOSL	[EDI]
	MOVL	EAX, rm_alloc[EBX]	;Get size of msect
	ADDL	EDX, EAX
	STOSL	[EDI]
	CLRL	EAX			;Final byte is not used now
	STOSL	[EDI]
	POPL	EDI
	ADDL	EBX, #rm_SIZE		;Bump pointer
	LOOP	ECX, 10$		;Continue if more msects
	MOVL	EDI, run_rlbaddr#+0	;Store total size for program
	MOVL	rd_size[EDI], EDX
	RET

;Here if relocation data buffer is too small

12$:	POPL	EDI
14$:	MOVL	EAX, #ER_VALUE
	RET				;Give error return from usrrnrun
.PAGE
;Table which maps segment type from the RUN file header into the argument value
;  for the svcMemSegType system call.  Index value is constructed as follows:
;	Bit 4	 - SS$READ bit from segment status byte in segment header
;	Bit 3	 - SS$WRITE bit from segment status byte in segment header
;	Bit 2	 - Set if 32 bit segment, clear if 16 bit segment
;	Bits 1-0 - Low 2 bits of segment type byte from the segment header:
;			00 - Illegal
;			01 - Data segment
;			10 - Code segment
;			11 - Stack segment

	.MOD	4
segtype:.BYTE	0		;00000
	.BYTE	ST_16RODATA	;00001 -      ,      , 16-bit, Data
	.BYTE	ST_16NXOCODE	;00010 -      ,      , 16-bit, Code
	.BYTE	ST_16STACK	;00011 -      ,      , 16-bit, Stack
	.BYTE	0		;00100
	.BYTE	ST_32RODATA	;00101 -      ,      , 32-bit, Data
	.BYTE	ST_32NXOCODE	;00110 -      ,      , 32-bit, Code
	.BYTE	ST_32STACK	;00111 -      ,      , 32-bit, Stack
	.BYTE	0		;01000
	.BYTE	ST_16RWDATA	;01001 -      ,Write , 16-bit, Data
	.BYTE	ST_16NXOCODE	;01010 -      ,Write , 16-bit, Code
	.BYTE	ST_16STACK	;01011 -      ,Write , 16-bit, Stack
	.BYTE	0		;01100
	.BYTE	ST_32RWDATA	;01101 -      ,Write , 32-bit, Data
	.BYTE	ST_32NXRCODE	;01110 -      ,Write , 32-bit, Code
	.BYTE	ST_32STACK	;01111 -      ,Write , 32-bit, Stack
	.BYTE	0		;10000
	.BYTE	ST_16RODATA	;10001 - Read ,      , 16-bit, Data
	.BYTE	ST_16NXRCODE	;10010 - Read ,      , 16-bit, Code
	.BYTE	ST_16STACK	;10011 - Read ,      , 16-bit, Stack
	.BYTE	0		;10100
	.BYTE	ST_32RODATA	;10101 - Read ,      , 32-bit, Data
	.BYTE	ST_32NXRCODE	;10110 - Read ,      , 32-bit, Code
	.BYTE	ST_32STACK	;10111 - Read ,      , 32-bit, Stack
	.BYTE	0		;11000
	.BYTE	ST_16RWDATA	;11001 - Read ,Write , 16-bit, Data
	.BYTE	ST_16NXRCODE	;11010 - Read ,Write , 16-bit, Code
	.BYTE	ST_16STACK	;11011 - Read ,Write , 16-bit, Stack
	.BYTE	0		;11100
	.BYTE	ST_32RWDATA	;11101 - Read ,Write , 32-bit, Data
	.BYTE	ST_32NXRCODE	;11110 - Read ,Write , 32-bit, Code
	.BYTE	ST_32STACK	;11111 - Read ,Write , 32-bit, Stack

	END
