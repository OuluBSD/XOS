	.TITLE	error - XOS error handling routines

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

	.PROC	80486
	.INCLUD	XOSINC:\XMAC\XOS.PAR
	.INCLUD	XOSINC:\XMAC\XOSX.PAR
	.INCLUD	XOSINC:\XMAC\XOSTRM.PAR
	.INCLUD	XOSINC:\XMAC\XOSXTRM.PAR
	.INCLUD XOSINC:\XMAC\XOSDOS.PAR
	.INCLUD	XOSINC:\XMAC\XOSERR.PAR
	.INCLUD	XOSINC:\XMAC\PCAT.PAR

	DATA

;Define special characters used in the fatal error display

BTR =!0xBB		;Top right border corner
BBR =!0xBC		;Bottom right border corner
BVL =!0xBA		;Vertical border line
BBL =!0xC8		;Bottom left border corner
BTL =!0xC9		;Top left border corner
BHL =!0xCD		;Horizontal border line

BOXPSN=!27t		;Position on screen for crash message

;Define attributes for the fatal error display

A_CNORM=!0x47		;(color) Normal characters (white on red)
A_CBLNK=!0xF1		;(color) Blinking characters (blue on white)
A_CINVR=!0x70		;(color) Inverse characters (black on white)
A_MNORM=!0x07		;(monochrome) Normal characters (white on black)
A_MBLNK=!0xF0		;(monochrome) Blinking characters (black on white)
A_MINVR=!0x70		;(monochrome) Inverse characters (black on white)

crshEIP==crshdata+pg0_crshEIP
crshCS ==crshdata+pg0_crshCS

	ONCE

;Subroutine to initialize error vectors
;	CALL	vectorinit

vectorinit::
	MOVL	EBX, #vecttbl
	MOVL	ECX, #VECTTBLSZ
2$:	MOVZBL	EDX, [EBX]
	SHLL	EDX, #3t
	MOVL	EAX, 4[EBX]		;Get offset
	MOVL	knlIDTable#+0[EDX], EAX	;Store low 16 bits at 0
	MOVL	knlIDTable#+4[EDX], EAX	;Store high 16 bits at 6
	MOVZWL	EAX, 2[EBX]
	MOVW	knlIDTable#+2[EDX], AX	;Store selector
	CLRL	EAX
	MOVB	AH, 1[EBX]
	MOVW	knlIDTable#+4[EDX], AX	;Store 0 byte and type byte
	ADDL	EBX, #8t
	LOOP	ECX, 2$
	RET

;Table which gives initial vector contents

	.MACRO	IV  vect, seg, offst, type, lvl
	.BYTE	vect/8
	.BYTE	DT_'type+PL_'lvl
	.WORD	GS_'seg
	.LONG	offst
	.ENDM

	.MOD	4
vecttbl:IV	ID_DIVERR , XCODE    , diverr    , TRAP, 0	;INT 00
	IV	ID_DEBUG  , XCODE    , debugtrp  , INT , 0 	;INT 01
	IV	ID_NMI    , XCODE    , nmierr    , TRAP, 0	;INT 02
	IV	ID_BRKPNT , XCODE    , int3trp   , TRAP, 3	;INT 03
	IV	ID_INTO   , XCODE    , intoerr   , TRAP, 0	;INT 04
	IV	ID_BOUND  , XCODE    , bnderr    , TRAP, 0	;INT 05
	IV	ID_ILLINS , XCODE    , illerr    , TRAP, 0	;INT 06
	IV	ID_FPUNAVL, XCODE    , fpunavl   , TRAP, 0	;INT 07
	IV	ID_DBLEXP , DBLERRTSS, 0         , TASK, 0	;INT 08
	IV	ID_FPUSOVR, XCODE    , proter0   , TRAP, 0	;INT 09
	IV	ID_ITSS   , XCODE    , itsserr   , INT , 0	;INT 0A
	IV	ID_SEGNP  , XCODE    , snperr    , TRAP, 0	;INT 0B
	IV	ID_STKERR , STKERRTSS, 0         , TASK, 0	;INT 0C
	IV	ID_PROT   , XCODE    , proterr   , TRAP, 0	;INT 0D
	IV	ID_PAGEFLT, XCODE    , pgferr    , INT , 0	;INT 0E
	IV	0Fh*8     , XCODE    , illint0F  , TRAP, 0	;INT 0F
	IV	ID_FPUERR , XCODE    , fpuerr    , TRAP, 0	;INT 10
	IV	11h*8     , XCODE    , illint11  , TRAP, 0	;INT 11
	IV	12h*8     , XCODE    , illint12  , TRAP, 0	;INT 12
	IV	13h*8     , XCODE    , illint13  , TRAP, 0	;INT 13
	IV	14h*8     , XCODE    , illint14  , TRAP, 0	;INT 14
	IV	15h*8     , XCODE    , illint15  , TRAP, 0	;INT 15
	IV	16h*8     , XCODE    , illint16  , TRAP, 0	;INT 16
	IV	17h*8     , XCODE    , illint16  , TRAP, 0	;INT 17
	IV	18h*8     , XCODE    , illint18  , TRAP, 0	;INT 18
	IV	19h*8     , XCODE    , illint19  , TRAP, 0	;INT 19
	IV	1Ah*8     , XCODE    , illint1A  , TRAP, 0	;INT 1A
;;;;	IV	ID_IRET   , XCODE    , svciret#  , TRAP, 3	;INT 1B
	IV	ID_CRASH  , XCODE    , syscrash  , INT , 0	;INT 1F
	IV	ID_TIMER0 , XCODE    , timer0int#, INT , 0	;INT 70 (IRQ0)
	IV	ID_KEYBRD , XCODE    , illint71  , TRAP, 0	;INT 71 (IRQ1)
	IV	ID_CASCADE, XCODE    , illint72  , TRAP, 0	;INT 72 (IRQ2)
	IV	ID_SPORT2 , XCODE    , illint73  , TRAP, 0	;INT 73 (IRQ3)
	IV	ID_SPORT1 , XCODE    , illint74  , TRAP, 0	;INT 74 (IRQ4)
	IV	ID_PPORT2 , XCODE    , illint75  , TRAP, 0	;INT 76 (IRQ5)
	IV	ID_FDISK  , XCODE    , illint76  , TRAP, 0	;INT 76 (IRQ6)
	IV	ID_PPORT1 , XCODE    , sprintm   , TRAP, 0	;INT 77 (IRQ7)
	IV	ID_RTC    , XCODE    , illint78  , TRAP, 0	;INT 78 (IRQ8)
	IV	ID_IRQ9   , XCODE    , illint79  , TRAP, 0	;INT 79 (IRQ9)
	IV	ID_IRQ10  , XCODE    , illint7A  , TRAP, 0	;INT 7A (IRQ10)
	IV	ID_IRQ11  , XCODE    , illint7B  , TRAP, 0	;INT 7B (IRQ11)
	IV	ID_IRQ12  , XCODE    , illint7C  , TRAP, 0	;INT 7C (IRQ12)
	IV	ID_IRQ13  , XCODE    , illint7D  , TRAP, 0	;INT 7D (IRQ13)
	IV	ID_HDISK  , XCODE    , illint7E  , TRAP, 0	;INT 7E (IRQ14)
	IV	ID_IRQ15  , XCODE    , sprints   , TRAP, 0	;INT 7F (IRQ15)
	IV	ID_DSVC   , XCODE    , dsvcint#  , TRAP, 3	;INT 82
	IV	ID_SSVC   , XCODE    , ssvcint#  , TRAP, 3	;INT 83
	IV	ID_DISMISS, XCODE    , dismiss#  , TRAP, 3	;INT 84
VECTTBLSZ=!{$-vecttbl}/8

	CODE

;Table which gives default vector values for the hardware interrupt vectors

dftirq::.LONG	timer0int#
	.LONG	illint71
	.LONG	illint72
	.LONG	illint73
	.LONG	illint74
	.LONG	illint75
	.LONG	illint76
	.LONG	sprintm
	.LONG	illint78
	.LONG	illint79
	.LONG	illint7A
	.LONG	illint7B
	.LONG	illint7C
	.LONG	fpuint
	.LONG	illint7E
	.LONG	sprints
.PAGE
;Here on the FPU not available exception. Get here when FPU instructions
;  executed if do not have an FPU (ME is set) or if TS is set.

fpunavl:PUSHAL				;Save registers
	PUSHL	DS			;Save segment registers
	PUSHL	ES
	PUSHL	FS
	PUSHL	GS
	PUSHL	#GS_XDATA
	POPL	DS
	CMPB	knlForkLvl#, #FORK_MFORK
	JA	10$
	MOVL	EAX, CR0		;Do we have an FPU?
	TESTB	AL, #0x04
	JE	12$			;Yes - must have been a task switch
	POPL	GS			;No - treat it as an illegal instruction
	POPL	FS
	POPL	ES
	POPL	DS
	POPAL
	PUSHL	#0
	PUSHL	#0
	PUSHL	#VECT_ILLINS
	JMP	usertrap

10$:	CRASH	FPUT

;Here with FPU trap due to an FPU instruction executed after a task switch

12$:	CLTS				;Clear the TS bit
	MOVL	EBX, fputda#		;Get current FPU owner
	TESTL	EBX, EBX		;Is it owned by the kernel?
	JG	knlSignalChk#		;Yes - nothing to do here other than
					;  clear TS
	MOVL	fputda#, #1		;Indicate FPU being used by the kernel

	CMPL	EBX, knlTda+tdaAddr#	;No - is the FPU owned by the current
					;  thread?
	JE	24$			;Yes - nothing is needed here (Should
					;  not happen since we don't set TS
					;  unless we need to.)
	CMPB	fputype#, #FPUTYPE_INTM	;No - can we use FXSAVE/FXRSTOR?
	JE	16$			;Yes

	TESTL	EBX, EBX		;Is the FPU unowned?
	JE	14$			;Yes - no state to save
	FNSAVE	tdaFpuState#[EBX]	;No - save current FPU state in the old
					;  way
14$:	CMPB	knlTda+tdaFpuUsed#, #0	;Has this thread ever used the FPU?
	JE	22$			;No - no state to restore (the FNSAVE
					;  reset the FPU state)
	FRSTOR	knlTda+tdaFpuState#	;Restore the FPU state for this thread
	MOVB	knlTda+tdaFpuUsed#, #1
	JMP	22$

;Here if can use FXSAVE/FXRSTOR

ffff::
16$:	TESTL	EBX, EBX		;Is the FPU unowned?
	JE	18$			;Yes - no state to save
	FXSAVE	tdaFpuState#[EBX]	;No - save the current FPU state
18$:	CMPB	knlTda+tdaFpuUsed#, #0	;Has this thread ever used the FPU?
	JE	20$			;No - no state to restore
	FXRSTOR	knlTda+tdaFpuState#	;Yes - restore his FPU state
	JMP	24$

;Here if no state to restore

20$:	FNINIT				;Reset the CPU (FXSAVE does not do this)
22$:	MOVB	knlTda+tdaFpuUsed#, #1
24$:	MOVL	EAX, knlTda+tdaAddr#	;The current thread now owns the FPU
	MOVL	fputda#, EAX
	JMP	knlSignalChk#
.PAGE
;Here on divide error exception

diverr:	PUSHL	#0			;Fake up error data
	PUSHL	#0
	TESTB	18t[ESP], #02		;From virtual DOS mode?
	JNE	2$			;Yes
	TESTB	12t[ESP], #03		;No - from user mode?
	JNE	4$			;Yes
	PUSHL	#'DIVE'
	JMP	savcom

;Here if trap is from real mode

2$:	PUSHL	#VECT_DIVERR
	JMP	usertrap

;Here if trap is from protected user mode

4$:	PUSHL	#VECT_DIVERR
	JMP	usertrap
.PAGE
;Here on a FPU error interrupt (IRQ13) - This is really a floating point
;  exception, but most machines with an external FPU (or an internal FPU
;  operating in DOS emulation mode) have this hooked up to cause this
;  interrupt. It has been observed that even some machines with an internal
;  FPU operating in native mode will generate this interrupt in addition to
;  trapping through vector 16! If we get this interrupt when we have
;  determined that the FPU generates a vector 16 trap we simply ignore this
;  interrupt. We have no assurance that the BIOS will not assign this
;  interrupt to other devices, so we make it sharable. This implies that we
;  have to check for unmasked exceptions here and do nothing for the FPU if
;  there are none. Since this interrupt routine may be chained to routines
;  for "real" devices, we cannot simply treat this as a user trap and go
;  directly to user code. Instead we queue a signal request for user
;  vector 16.

fpuint::INTENTR
	CMPB	fputype, #FPUTYPE_EXTI	;Should we use this?
	JE	4$			;Yes
	MOVB	AL, #0			;No - clear the FPU busy latch (This
	OUTB	P_MATHCBSY		;  might cause us to drop an FPU
					;  interrupt but we don't care since
					;  we are ignoring them!)
	JMP	fpuintexit		;That all

;Here if have an external FPU connected for DOS compatibility

4$:	PUSHL	#0			;Get the status word
	FNSTSW	[ESP]
	POPL	EAX
	TESTB	AL, #0x80		;Is there an unmasked exception?
	JE	fpuintexit		;No
	MOVB	AL, #0			;Yes - first clear the FPU busy latch
	OUTB	P_MATHCBSY
	CMPL	fputda#, #0		;Is the FPU owned by a thread?
	JNS	fpuintexit		;No - ignore this

	ORB	knlTda+tdaSigReq#, #01
	ORB	knlTda+tdaSSigType#, #SSIG$FPUX
	MOVB	knlSchedReq#, #1

fpuintexit::
	JMP	knlIntDoneHigh#

;Here on a floating point error exception

fpuerr::PUSHAL				;Save all registers
	PUSHL	DS
	PUSHL	ES
	PUSHL	FS
	PUSHL	GS
	PUSHL	#GS_XDATA		;Make our data addressable
	POPL	DS
	CMPL	fputda#, #0		;Is the FPU owned by a thread?
	JNS	10$			;No - ignore this
	ORB	knlTda+tdaSigReq#, #01
	ORB	knlTda+tdaSSigType#, #SSIG$FPUX
	MOVB	knlSchedReq#, #1
10$:	CLI
	JMP	knlDismissInt#
.PAGE
;Here on NMI exception

nmierr:	PUSHL	EAX			;See if this is IOCHK interrupt
	MOVB	AL, #0x80
	OUTB	0x90
	IOPAUSE
	INB	0x61
	TESTB	AL, #0x40
	JE	2$			;No
	MOVB	AL, #0xC0		;Yes - reset IOCHK latch
	OUTB	0x61
	IOPAUSE
	IOPAUSE
	MOVB	AL, #0x40
	OUTB	0x61
	POPL	EAX
nmiint::INT3				;Go to GECKO
	NOP
	IRET				;Dismiss interrupt

;Here if NMI is not due to IOCHK

2$:	POPL	EAX
	PUSHL	#0
	PUSHL	#0
	PUSHL	#'NMIE'
	JMP	savcom
.PAGE
;Here on INTO instruction trap

intoerr:PUSHL	#0
	PUSHL	#0
	TESTB	18t[ESP], #02		;From real mode?
	JNE	2$			;Yes
	TESTB	12t[ESP], #03		;No - from user mode?
	JNE	4$			;Yes
	PUSHL	#'INTO'			;No
	JMP	savcom

;Here if trap is from real mode

2$:	PUSHL	#VECT_INTO
	JMP	usertrap

;Here if trap is from protected user mode

4$:	PUSHL	#VECT_INTO
	JMP	usertrap
.PAGE
;Here on BOUND instruction trap

bnderr:	PUSHL	#0
	PUSHL	#0
	TESTB	18t[ESP], #02		;From virtual DOS mode?
	JNE	2$			;Yes
	TESTB	12t[ESP], #03		;No - from user mode?
	JNE	4$			;Yes
	PUSHL	#'BNDE'			;No
	JMP	savcom

;Here if trap is from real mode

2$:	PUSHL	#VECT_BOUND
	JMP	usertrap

;Here if trap is from protected user mode

4$:	PUSHL	#VECT_BOUND
	JMP	usertrap
.PAGE
;Here on illegal instruction trap

illerr:	PUSHL	#0
	PUSHL	#0
	TESTB	18t[ESP], #02		;From real mode?
	JNE	2$			;Yes
	TESTB	12t[ESP], #03		;No - from user mode?
	JNE	4$			;Yes
	PUSHL	#'IINS'			;No
	JMP	savcom

;Here if trap is from real mode

2$:	PUSHL	#VECT_ILLINS
	JMP	usertrap

;Here if trap is from protected user mode

4$:	PUSHL	#VECT_ILLINS
	JMP	usertrap
.PAGE
;Here on double exception trap (unlikely we will ever get here!)

dblerr::PUSHL	#0
	PUSHL	#-1
	PUSHL	#-1
	PUSHL	#-1
	PUSHL	#0
	PUSHL	#0
	PUSHL	#'DBLX'
	JMP	savcom

;Here on invalid task state segment trap

itsserr:PUSHL	#0
	PUSHL	#'ITSS'
	JMP	savcom
.PAGE
;INT3 trap handler

int3trp:CMPB	CS:userint3, #2		;Want all traps in exec mode?
	JAE	2$			;Yes
	TESTB	10t[ESP], #02		;No - from real mode?
	JNE	14$			;Yes
	TESTB	4[ESP], #03		;No - from user mode?
	JNE	18$			;Yes
2$:	PUSHL	#geckoxdispatch#	;No - is GECKOX present?
	CMPL	[ESP], #0
	JE	4$			;No!
	ADDL	ESP, #4			;Yes
	JMPF	geckoxdispatch#+4	;Go directly to GECKOX

4$:	MOVL	[ESP], #geckotdispatch#	;Is GECKOT present?
	CMPL	[ESP], #0
	JE	6$
	ADDL	ESP, #4
	JMPF	geckotdispatch#+4

;Here with exec INT3 with no debugger loaded - crash!

6$:	DECL	4[ESP]			;Point to the INT3
	PUSHL	#0
	PUSHL	#'INT3'
	JMP	savcom

;Here if trap is from real mode

14$:	CMPW	4[ESP], #0xED00		;From the user code segment?
	JNE	16$			;No
	CMPB	CS:userint3, #1		;Yes - want this trap?
	JE	2$			;Yes
16$:	PUSHL	EAX			;No - send it to user mode
	MOVL	EAX, DR6
	ORL	SS:knlTda+tdaURegDR6#, EAX
	POPL	EAX
	PUSHL	SS:knlTda+tdaURegDR6#
	PUSHL	#0
	PUSHL	#VECT_BRKPNT
	JMP	usertrap

;Here if trap is from protected user mode

18$:	CMPL	[ESP], #usercodebase	;From the user code segment?
	JL	20$			;No
	CMPL	[ESP], #usercodetop#	;Maybe
	JAE	20$			;No
	CMPB	CS:userint3, #1		;Yes - want this trap?
	JE	2$			;Yes
20$:	PUSHL	EAX			;No - send it to user mode
	MOVL	EAX, DR6
	ORL	SS:knlTda+tdaURegDR6#, EAX
	POPL	EAX
	PUSHL	SS:knlTda+tdaURegDR6#
	PUSHL	#0
	PUSHL	#VECT_BRKPNT
	JMP	usertrap

userint3::.BYTE 0		;0 = All user mode INT3 and debug traps to
				;      user mode
				;1 = User mode INT3 and debug traps from
				;      user code msect to exec mode,
				;      others to user mode
				;2 = All user mode INT3 and debug traps to
				;      exec mode
userwp::  .BYTE 0		;0 = All user mode watch point traps to user
				;      mode
				;1 = User mode watch point traps from
				;      user code msect to exec mode,
				;      others to user mode
				;2 = All user mode watch point traps to exec
				;      mode
tracetrp::.BYTE 0		;0 = All trace traps to user mode
				;1 = All trace traps to GeckoX
				;2 = All trace traps to GeckoT
.PAGE
;Debug trap handler

debugtrp:
	PUSHL	EAX			;Free up a register

	MOVL	EAX, DR6		;Get DR6
	MOVL	SS:xxxxDR6v, EAX

	TESTB	AH, #0x80		;Task switch trap?
	JNE	tsktrp			;Yes
	TESTB	AH, #0x40		;No - trace trap?
	JNE	trctrp			;Yes - go handle it
					;No - assume its just a watchpoint trap
	CMPB	CS:userwp, #2		;Want all traps in exec mode?
	JAE	14$			;Yes
	PUSHL	EDX			;No - see if we have a hit on a global
	MOVL	EDX, DR7		;  watchpoint
	TESTB	AL, #0x01
	JE	2$
	TESTB	DL, #0x02
	JNE	12$
2$:	TESTB	AL, #0x02
	JE	4$
	TESTB	DL, #0x08
	JNE	12$
4$:	TESTB	AL, #0x04
	JE	6$
	TESTB	DL, #0x20
	JNE	12$
6$:	TESTB	AL, #0x08
	JE	8$
	TESTB	DL, #0x80
	JNE	12$
8$:	TESTB	AL, #0x55		;No global hits - have any local hits?
	JE	12$			;No - let exec debugger handle it
	POPL	EDX
	TESTB	14t[ESP], #0x02		;Have local hit(s) - from real mode?
	JNE	dbgreal			;Yes
	TESTB	8t[ESP], #0x03		;No - from user mode?
	JNE	wplcluser		;Yes

;Here if have a local watchpoint hit from exec mode - This means that the
;  kernal referenced a user location on which a local watchpoint was set.
;  This is messy, since we have no idea what state (main program level,
;  extended fork context, device fork level, or interrupt level) we are in!
;  Generally, device fork or interrupt level code does not directly reference
;  user memory (it can, but this is not common).  If we do get a watchpoint
;  hit from device fork or interrupt level we just ignore it since it is too
;  complex to figure out which process is responsible! The main program level
;  case is fairly simple to handle since the memory environment is well
;  defined.  In this case we buffer the hits and fake up the debug trap the
;  next time we go back to user mode.

wplclexec::
	PUSHL	EAX
	MOVB	AL, #0x0B		;At interrupt level?
	OUTB	P_INC1P0
	IOPAUSE
	INB	P_INC1P0
	CMPB	AL, #0
	JNE	wpignore		;Yes - ignore the watchpoint hit(s)
	CMPB	CS:knlForkLvl#, #FORK_MAIN
	JNE	wpignore		;Ignore this if not at main program
	POPL	EAX			;  level
	ANDL	EAX, #0x0F
	ORL	SS:knlPda+pdaWPHits#, EAX ;Set his buffered hit bit(s)
	JMP	28$			;Otherwise ignore this

;Here to report the debug trap to the exec debugger

12$:	POPL	EDX
14$:	MOVL	EAX, #geckoxdispatch#
	TESTL	EAX, EAX
	JE	16$
	POPL	EAX
	JMPF	geckoxdispatch#+2	;Go directly to local exec GECKO

16$:	MOVL	EAX, #geckotdispatch#
	TESTL	EAX, EAX
	JE	wpnodebug
	POPL	EAX
	JMPF	geckotdispatch#+2	;Go directly to remote exec GECKO

;Here with a watchpoint trap and no debugger (should not be possible!)

wpnodebug:
	POPL	EAX
	CRASH	WPNT

;Here to ignore a watchpoint hit

wpignore:
	POPL	EAX
28$:	CLRL	EAX			;Clear the hit bits
	MOVL	DR6, EAX
	POPL	EAX
	IRET

;Here if trap is from protected user mode

wplcluser:
	CMPL	4[ESP], #usercodebase
	JL	dbgprot
	CMPL	4[ESP], #usercodetop#
	JAE	14$
	CMPB	CS:userwp, #1
	JE	14$
	JMP	dbgprot
.PAGE
;Here if this is a task switch debug trap - This should only be possible when
;  servicing a stack error since this is the only time we error do a hardware
;  taskswitch. This code has NOT been tested!

tsktrp:	PUSHL	EDX
	MOVL	EDX, CS:knlTda+tdaURegDR7#
	TESTB	DL, #0x01		;Is watchpoint 0 in use?
	JE	2$
	MOVL	EAX, CS:knlTda+tdaURegDR0# ;Yes
	MOVL	DR0, EAX
2$:	TESTB	DL, #0x04		;Is watchpoint 1 in use?
	JE	4$
	MOVL	EAX, CS:knlTda+tdaURegDR1# ;Yes
	MOVL	DR1, EAX
4$:	TESTB	DL, #0x10		;Is watchpoint 2 in use?
	JE	6$
	MOVL	EAX, CS:knlTda+tdaURegDR2# ;Yes
	MOVL	DR2, EAX
6$:	TESTB	DL, #0x40		;Is watchpoint 0 in use?
	JE	8$
	MOVL	EAX, CS:knlTda+tdaURegDR3# ;Yes
	MOVL	DR3, EAX
8$:	MOVL	EAX, knlTda+tdaURegDR6#
	ANDL	EAX, #0x400F
	MOVL	DR6, EAX
	MOVL	DR7, EDX
	POPL	EDX			;Restore registers
	POPL	EAX
	IRET				;Return

;Here if this is a trace trap

trctrpx::
	PUSHL	EAX			;Enter here on fake trace trap when
					;  returning from a system call
trctrp:	CMPB	CS:tracetrp, #1		;Does exec GeckoX want this?
	JE	10$			;Yes
	CMPB	CS:tracetrp, #2		;No - what about GeckoT?
	JE	12$			;Yes
	ANDB	12t+1[ESP], #~0x01	;No - clear the saved T flag
	TESTB	12t+2[ESP], #0x02	;From virtual DOS mode?
	JNE	dbgreal			;Yes
	TESTB	8[ESP], #0x03		;No - from user mode?
	JNE	dbgprot			;Yes
	CMPW	12t[ESP], #GS_XCODE	;No - from kernel code segment?
	JNE	10$			;No
	PUSHL	ES			;Yes
	LESL	EAX, 8[ESP]		;Get address
	POPL	ES			;No - restore registers

	CRASH	TTRP


10$:	MOVL	EAX, #geckoxdispatch#
	TESTL	EAX, EAX
	JE	14$
	POPL	EAX
	JMPF	geckoxdispatch#+2	;No - go directly to exec GECKO

12$:	MOVL	EAX, #geckotdispatch#
	TESTL	EAX, EAX
	JE	14$
	POPL	EAX
	JMPF	geckotdispatch#+2

14$:	POPL	EAX
	CRASH	TTRP

;Here if trap is from real mode

dbgreal:POPL	EAX
	PUSHL	#0
	PUSHL	#0
	PUSHL	#VECT_DEBUG+{ID_DEBUG/8+200h}*10000h
	JMP	28$

;Here if trap is from protected user mode

dbgprot:POPL	EAX
	PUSHL	#0
	PUSHL	#0
	PUSHL	#VECT_DEBUG
28$:	PUSHL	EAX
	MOVL	EAX, DR6
	ORL	knlTda+tdaURegDR6#, EAX
	CLRL	EAX
	MOVL	DR6, EAX
	POPL	EAX
	JMP	usertrap
.PAGE
;Here on segment not present trap

snperr:	TESTB	8[ESP], #3		;From user mode?
	JNE	6$			;Yes
	PUSHL	#0
	PUSHL	#'SGNP'			;No
	JMP	protcom

;Here if from protected user mode

6$:	PUSHL	#0
	PUSHL	#VECT_SEGNP
	JMP	usertrap
.PAGE
;Here on stack segment overrun or not present trap - this trap is handled with
;  a task gate, so we get here in a different task context - this is necessary
;  to allow the traping of exec mode stack errors.

stkerr::MOVZWL	EAX, stkerrtss#+tss_link ;Get the TSS for the interruptted
	ANDL	EAX, #0xFFFFFFFC	 ;  context
	MOVZBL	EBX, gdtable+4[EAX]
	MOVB	BH, gdtable+7[EAX]	;Get the address of the TSS
	SHLL	EBX, #16t
	MOVW	BX, gdtable+2[EAX]
	MOVL	EAX, ES:tss_CR3[EBX]	;Set memory mapping to the interruptted
	MOVL	CR3, EAX		;  context's address space
	TESTB	tss_EFR+2[EBX], #2	;From virtual-86 mode?
	JNE	stkeusr			;Yes
	TESTB	tss_CS[EBX], #03h	;No - from user mode?
	JE	14$			;No

;Here with stack error from user mode - we fix things up to make this look like
;  a normal trap gate trap and call badusrstk to pass the error to the user
;  process

stkeusr:STD
	MOVL	EDI, #tdaXStackV#-4	;Get his exec stack pointer
	CLRL	EAX			;Clear out the segment registers (these
	STOSL	[EDI]			;  don't matter here since this is a
	STOSL	[EDI]			;  fatal error for the user process and
	STOSL	[EDI]			;  the segment register value are lost!)
	STOSL	[EDI]
	MOVL	tss_GS[EBX], EAX
	MOVL	tss_FS[EBX], EAX
	MOVL	tss_ES[EBX], EAX
	MOVL	EAX, tss_SS[EBX]	;Store SS on his exec stack
	STOSL	[EDI]
	MOVL	EAX, tss_ESP[EBX]	;Store ESP on his exec stack
	STOSL	[EDI]
	MOVL	EAX, tss_EFR[EBX]	;Store EFR on his exec stack
	STOSL	[EDI]
	MOVL	EAX, tss_CS[EBX]	;Store CS on his exec stack
	STOSL	[EDI]
	MOVL	EAX, tss_EIP[EBX]	;Store EIP on his exec stack
	STOSL	[EDI]
	POPL	EAX			;Store the error code on his exec stack
	STOSL	[EDI]
	MOVL	[EDI], #stkeusr
	MOVL	tss_ESP[EBX], EDI	;Store his exec stack pointer
	MOVL	tss_SS[EBX], DS
	MOVL	tss_DS[EBX], #GS_XDATA	;Make sure his DS is right
	MOVL	tss_EIP[EBX], #badusrstk ;Set his CS:EIP
	MOVL	tss_CS[EBX], CS
	MOVL	tss_EFR[EBX], #0200h	;Set his EFR
	IRET				;This will "return" to badusrstk since
	JMP	stkerr			;  NT is set

;Here if stack error is not from user mode - this means we have a bad exec
;  mode stack - we save the crash data from the previous TSS and give a
;  fatal system error

14$:	MOVL	EAX, tss_ESP[EBX]
	MOVL	crshdata+pg0_crshESP, EAX
	MOVZWL	EAX, tss_SS[EBX]
	MOVL	crshdata+pg0_crshSS, EAX
	MOVZWL	EAX, tss_ES[EBX]
	MOVL	crshdata+pg0_crshES, EAX
	MOVZWL	EAX, tss_FS[EBX]
	MOVL	crshdata+pg0_crshFS, EAX
	MOVZWL	EAX, tss_GS[EBX]
	MOVL	crshdata+pg0_crshGS, EAX
	MOVL	EAX, stkerrtss#
	MOVL	crshdata+pg0_crshTR, EAX
	MOVL	EAX, tss_LDT[EBX]
	MOVL	crshdata+pg0_crshLDT, EAX
	MOVL	EAX, tss_EBX[EBX]
	MOVL	crshdata+pg0_crshEBX, EAX
	MOVL	EAX, tss_EAX[EBX]
	MOVL	ECX, tss_ECX[EBX]
	MOVL	EDX, tss_EDX[EBX]
	MOVL	EDI, tss_EDI[EBX]
	MOVL	ESI, tss_ESI[EBX]
	MOVL	EBP, tss_EBP[EBX]
	PUSHL	ES
	CALL	savreg2			;Store other registers
	POPL	ES
	POPL	EAX			;Restore error code
	PUSHL	ES:tss_EFR[EBX]		;Set up the stack the way fatal
	PUSHL	ES:tss_CS[EBX]		;  expects it
	PUSHL	ES:tss_EIP[EBX]
	PUSHL	EAX
	PUSHL	#0
	PUSHL	#'STKE'
	JMP	fatal
.PAGE
;Here on page fault trap - We have an error code on the stack when get here
;  We first must determine the type of page fault. If it is on a mapped page
;  then it is always an error. If it is on a page that is not mapped it may
;  be a virtual page or a blocked screen buffer page. In both of these cases
;  this code dispatches to the code to handle the situation.

pgferr:	PUSHL	EAX			;Save registers we need
	MOVL	EAX, CR2		;Get page fault linear address
	STI				;Interrupts are OK now
	XCHGL	EAX, [ESP]
	PUSHL	EAX
	PUSHL	DS
	PUSHL	#GS_XDATA		;Setup to access our data segment
	POPL	DS
	MOVL	EAX, 8[ESP]		;Get page fault linear address
	SHRL	EAX, #12t		;Get index into page table
	IFFAULT	pgfunal
	MOVL	EAX, knlPgTable#[EAX*4]	;Get page table entry
	TESTB	AL, #01			;Is the P bit set?
	JNE	pgfprs			;Yes
	ANDL	EAX, #0x3C		;No - get the page type
	JMPIL	pgfdsp[EAX]		;Dispatch on type of page

;Page fault dispath table

pgfdsp:	.LONG	pgfunal		;PT_FREE =  0 - Unallocated
	.LONG	pgfvirtpg#	;PT_VIRT =  1 - Virtually allocated page
	.LONG	pgfcrsh		;PT_SWAP =  2 - Swapped out page
	.LONG	pgfterm#	;PT_DISP =  3 - Unmapped display page (bits 5-31
				;		  contain offset of TDB for
				;		  terminal)
	.LONG	pgfcrsh		;	 =  4 - Illegal
	.LONG	pgfcrsh		;	 =  5 - Illegal
	.LONG	pgfcrsh		;	 =  6 - Illegal
	.LONG	pgfcrsh		;	 =  7 - Illegal
	.LONG	pgfcrsh		;	 =  8 - Illegal
	.LONG	pgfcrsh		;	 =  9 - Illegal
	.LONG	pgfcrsh		;	 = 10 - Illegal
	.LONG	pgfcrsh		;	 = 11 - Illegal
	.LONG	pgfcrsh		;	 = 12 - Illegal
	.LONG	pgfcrsh		;	 = 13 - Illegal
	.LONG	pgfcrsh		;	 = 14 - Illegal
	.LONG	pgfcrsh		;	 = 15 - Illegal

;Here if illegal page table entry type

pgfcrsh:CRASH	IPTT		;[Illegal Page Table Type]
.PAGE
;Here if have page fault on a page with the P bit set
;	c{EAX} = Page table entry

pgfprs:	POPL	DS			;Save reigsters in the standard way
	PUSHL	ECX			;  (we cannot use a PUSHAL here since
	PUSHL	EDX			;  we must preserve the value in EAX!)
	PUSHL	EBX
	PUSHL	ESP
	PUSHL	EBP
	PUSHL	ESI
	PUSHL	EDI
	PUSHL	DS
	PUSHL	ES
	PUSHL	FS
	PUSHL	GS
	PUSHL	#GS_XDATA		;Make sure DS is correct
	POPL	DS
	PUSHL	EDX
	CALL	sysMemGetMTE#		;Get the memory table entry
	TESTL	EAX, EAX
	JE	pgfuna0			;Fail if physical page
	MOVL	EDX, [EAX]		;Get page type
	SHRL	EDX, #20t
	ANDL	EDX, #0x0F
	JMPIL	pgtdsp[EDX*4]		;Dispatch on the page type

	DATA

pgtdsp:	.LONG	pgfuna0		;MT_FREE  = 0  - Unallocated page
	.LONG	pgfuna0		;MT_SYS   = 1  - System page
	.LONG	pgfuna0		;MT_PDIR  = 2  - Page directory page
	.LONG	pgfuna0		;MT_PTBL  = 3  - Page table page
	.LONG	pgfuna0		;MT_PDA   = 6  - Process data area (PDA) page
	.LONG	pgfuna0		;MT_SDA   = 7  - Shared section data area (SDA) page
	.LONG	pgfuser		;MT_PLOCK = 8  - Private locked user page
	.LONG	pgfuna0		;MT_SLOCK = 9  - Shared locked user page
	.LONG	pgfuser		;MT_PNSWP = 10 - Private non-swapable user page
	.LONG	pgfuna0		;MT_SNSWP = 11 - Shared non-swapable user page
	.LONG	pgfuser		;MT_PUSER = 12 - Private user page
	.LONG	pgfuna0		;MT_SUSER = 13 - Shared user page
	.LONG	pgfuna0		;	  = 14 - Illegal
	.LONG	pgfuna0		;	  = 15 - Illegal

	CODE
.PAGE
;Here for page fault on allocated user page

pgfuser:CMPB	knlForkLvl#, #FORK_MAIN	;Must be at main program level here!
	JNE	6$
	PUSHL	4[EAX]			;Get offset of MDB
	CALLI	mdb_fault[EDI]		;Call msect routine to see if we can
					;  fix the problem
	TESTL	EAX, EAX
	JE	pgfuna0			;If should fail
pgfuagn::
	LEAL	EDI, 52t[ESP]		;Should retry - remove the CR2 and
	PUSHL	SS			;  error code values from the stack
	POPL	ES
	LEAL	ESI, 44t[ESP]
	MOVL	ECX, #12t
	STD
	RMOVSL	[EDI], SS:[ESI]
	ADDL	ESP, #8t
	TESTB	0x34[ESP], #0x03	;Is trap from exec mode?
	JNE	knlSignalChk#		;No - return to user to try again

;Here if trap is from exec mode

	CLI				;No interrupts now
	ORB	0x39[ESP], #02		;Make sure interrupts are enabled
	POPL	GS			;  in the EFR
	POPL	FS			;Restore segment registers
	POPL	ES
	POPL	DS
	POPAL				;Restore general registers
	IRET				;Return to exec mode code

6$:	CRASH	ATFK			;[AT ForK level]
.PAGE
;Here if error after all registers saved

pgfuna0:POPL	GS			;Restore segment registers
	POPL	FS
	POPL	ES
	POPL	DS
	POPAL				;Restore user registers
	JMP	pgfuna2

;Here for page fault on unallocated or physically mapped page

	FAULTHDR
pgfunal:POPL	DS
	POPL	EAX
pgfuna2::
	TESTB	18t[ESP], #2		;From virtual DOS mode?
	JE	14$			;No
	JMP	vaddrtrp		;Yes

vbadaddr::
	POPL	GS			;Restore segment registers
	POPL	FS
	POPL	ES
	POPL	DS
	POPAL				;Restore user registers
vaddrtrp::
	PUSHL	#VECT_PAGEFLT
					;And go handle normal real mode user
	JMP	usertrap		;  trap

;Here if page fault trap is not from virtual DOS mode

14$:	TESTB	12t[ESP], #3		;From user mode?
	JNE	xaddrtrp		;Yes
	PUSHL	#'PFLT'			;No
	JMP	protcom

;Here if page fault trap is from protected user mode

xaddrtrp::
	PUSHL	#VECT_PAGEFLT
	JMP	usertrap
.PAGE
;Here on trap through vector 9 (coprocessor segment overrun). This is only
;  possible on an 80386.

proter0::
	PUSHL	#0			;Fake up the error code
					;Fall into normal protection trap
					;  routine

;Here on general protection trap through vector 13.

proterr:TESTB	14t[ESP], #2		;From virtual DOS mode?
	JE	proterr2		;No
	POPL	SS:knlTda+tdaErrCode#	;Yes - put error code in a safe place
	PUSHAL				;Save all registers in the standard way
	PUSHL	DS
	PUSHL	ES
	PUSHL	FS
	PUSHL	GS
	MOVL	EDX, SS
	MOVL	DS, EDX
	MOVL	ES, EDX
	MOVZWL	ESI, 52t[ESP]		;Get CS value
	SHLL	ESI, #4			;Times 16
	ADDL	ESI, 48t[ESP]		;Plus EIP value gives address in segment
	MOVL	rmlastprot, ESI
	MOVL	userdatsz, #2		;Indicate code and data sizes are 16
	MOVL	useradrsz, #2		;  bits
	IFFAULT	realperr
	CMPB	[ESI], #0xCD		;INT instruction?
	JNE	realperr		;No - fail
	IFFAULT	realperr
	MOVZBL	EAX, 1[ESI]		;Yes - get vector number
	IFFAULT	realperr
	CMPL	0[EAX*4], #0		;Is the vector initialized?
	JE	realperr		;No - fail
	MOVZWL	EDX, knlTda+tdaURegESP#	;Yes - get user's stack pointer
	MOVZWL	ECX, knlTda+tdaURegSS#
	SHLL	ECX, #4
	ADDL	ECX, EDX
	MOVL	EBX, knlTda+tdaURegEIP#	;Put return address on the user stack
	ADDL	EBX, #2
	IFFCALL	badusrstk
	MOVW	-6[ECX], BX
	MOVL	EBX, knlTda+tdaURegCS#
	IFFCALL	badusrstk
	MOVW	-4[ECX], BX
	MOVL	EBX, knlTda+tdaURegEFR#
	BTSL	EBX, #9			;Assume "interrupts" enabled
	CMPB	knlTda+tdaSigLvl#, #4	;Right?
	JB	18$			;Yes
	BTZL	EBX, #9
	IFFCALL	badusrstk
18$:	MOVW	-2[ECX], BX
	SUBL	knlTda+tdaURegESP#, #6	
	IFFAULT	realperr
	MOVZWL	EBX, 0[EAX*4]		;Get offset part of address
	IFFAULT	realperr
	MOVZWL	EAX, 2[EAX*4]		;Get segment part of address
	MOVL	knlTda+tdaURegEIP#, EBX
	MOVL	knlTda+tdaURegCS#, EAX
	ANDB	knlTda+tdaURegEFR#+1, #0x0E
	ORB	knlTda+tdaURegEFR#+1, #0x02
	MOVW	knlTda+tdaURegEFR#+2, #0x0002
	JMP	knlSignalChk#
.PAGE
;Here for real mode protection error which is really a protection error

	FAULTHDR
realperr:
	STI
	IFFAULT	10$
2$:	POPL	GS			;Restore segment registers
	IFFAULT	12$
4$:	POPL	FS
	IFFAULT	14$
6$:	POPL	ES
	IFFAULT	16$
8$:	POPL	DS
	POPAL				;Restore user registers
	PUSHL	#0
	PUSHL	#0
	PUSHL	#VECT_PROT+{ID_PROT/8+0x200}*0x10000
	JMP	usertrap

	FAULTHDR
10$:	POPL	EAX
	PUSHL	#0
	JMP	2$

	FAULTHDR
12$:	POPL	EAX
	PUSHL	#0
	JMP	4$

	FAULTHDR
14$:	POPL	EAX
	PUSHL	#0
	JMP	6$

	FAULTHDR
16$:	POPL	EAX
	PUSHL	#0
	JMP	8$
.PAGE
;Here if general protection trap is not from real mode

proterr2:
	TESTB	8t[ESP], #3		;From user mode?
	JNE	userperr		;Yes
	PUSHL	#0			;No - give fatal error
	PUSHL	#'PROT'
	JMP	protcom

;Here if general protection trap is from protected user mode

userperr:
	POPL	SS:knlTda+tdaErrCode#	;Put error code in a safe place
	PUSHAL				;Save user registers in the standard
	PUSHL	DS			;  way
	PUSHL	ES
	PUSHL	FS
	PUSHL	GS
	STI
	PUSHL	#GS_XDATA		;Make exec data addressable
	POPL	DS

;;;;;qqqqqqqqqqqqqqqqqqqq

	IFFAULT	pfpe
	LGSL	ESI, knlTda+tdaURegEIP	;Get address of the instruction
	MOVL	EAX, GS			;Get the access bits for the code
	LARL	EDX, EAX		;  segment
	MOVL	EAX, #1			;Assume have a 16 bit code segment
	BTL	EDX, #22t		;Right?
	ADCL	EAX, #0			;Make it 2 if 32 bits
	ADDL	EAX, EAX		;Make it 2 if 16 and 4 if 32 bits
	MOVL	userdatsz, EAX		;Store as initial code and data widths
	MOVL	useradrsz, EAX
protgetop::

;;;;;;	IFFAULT	pfpe
;;;;;;	MOVZBL	EAX, GS:[ESI]		;Get opcode byte
;;;;;;	MOVB	AL, poptblx#[EAX]	;Get index value
;;;;;;	JMPIL	poptbld#[EAX]		;Dispatch on the opcode

;Here if have a real protected mode protection error

	FAULTHDR
pfpe::	POPL	GS
	POPL	FS
	POPL	ES
	POPL	DS
	POPAL
	PUSHL	SS:knlTda+tdaErrCode#
	PUSHL	#0
	PUSHL	#VECT_PROT
	JMP	usertrap
.PAGE
;Common routine for exec mode memory protection errors

protcom:PUSHL	DS			;Make sure DS is right
	PUSHL	#GS_XDATA
	POPL	DS
	PUSHL	EAX			;Free up some registers
	PUSHL	EBX
	CMPW	28t[ESP], #GS_XCODE	;Was it from our code segment?
	JNE	memfail			;No - fatal error
	MOVL	EBX, 24t[ESP]		;Yes - get offset of instruction
	CMPL	EBX, #usercodebase	;Possible value?
	JB	memfail			;No
	CMPL	EBX, #ttlusercodetop	;Maybe
	JB	2$			;OK
	CMPL	EBX, #codebase		;Possible value?
	JB	memfail			;No
	CMPL	EBX, #ttlcodetop	;Maybe
	JAE	memfail			;No
	IFFAULT	memfail
2$:	CMPB	-5[EBX], #0xA9		;Yes - have IFFAULT instruction?
	JE	4$			;Yes
	IFFAULT	memfail
	CMPB	-5[EBX], #0x3D		;No - have IFFCALL instruction?
	JNE	memfail			;No
	IFFAULT	memfail
4$:	MOVL	EAX, -4[EBX]		;Maybe - get offset
	CMPL	EBX, #usercodebase	;Possible value?
	JB	memfail			;No
	CMPL	EBX, #ttlusercodetop	;Maybe
	JB	6$			;OK
	CMPL	EAX, #codebase		;Possible value?
	JB	memfail			;No
	CMPL	EAX, #oocodetop#	;Maybe
	JAE	memfail			;No
	IFFAULT	memfail
6$:	CMPB	-1[EAX], #0x90		;Have right header value?
	JE	8$			;Yes
	IFFAULT	memfail
	CMPB	-1[EAX], #0xFE		;Maybe - want error code in EAX?
	JNE	memfail			;No
	MOVL	4t[ESP], #ER_ADRER	;Yes - store error code
8$:	MOVL	memfault, EBX		;Store address for debugging
	IFFAULT	memfail
	CMPB	-5[EBX], #0x3D		;Have IFFCALL instruction?
	JNE	10$			;No
hviffcall:
	MOVL	EBX, 32t[ESP]		;Yes - rearange the stack as follows:
	MOVL	20t[ESP], EBX		;  ESP+0 to ESP+8 contains saved regs
	MOVL	EBX, 16t[ESP]		;    and is unchanged.
	MOVL	28t[ESP], EBX		;  ESP+32  -> ESP+20 (err EFR)
	MOVL	EBX, 24t[ESP]		;  ESP+28  -> junk   (err CS)
	MOVL	32t[ESP], EBX		;  ESP+24  -> ESP+32 (err EIP)
	MOVL	EBX, 12t[ESP]		;  ESP+20  -> junk   (err text)
	MOVL	24t[ESP], EBX		;  ESP+16  -> ESP+28 (err code 2)
	MOVL	12t[ESP], EAX		;  ESP+12  -> ESP+24 (err code 1)
	MOVL	16t[ESP], #GS_XCODE	;  CS_CODE -> ESP+16
					;  New EIP -> ESP+12
					;This results in a stack set up as
					;  follows:
					;  c{ESP+32) = Error EIP
					;  c{ESP+28} = Error code 2
					;  c{ESP+24} = Error code 1
					;  c{ESP+20} = New EFR
					;  c{ESP+16} = New EIP
					;  c{ESP+12} = New CS
					;  c{ESP+8}  = Saved DS
					;  c{ESP+4}  = Saved EAX
					;  c{ESP+0}  = Saved EBX
	POPL	EBX			;Restore registers and go to the
	POPL	EAX			;  error handler routine
	POPL	DS
	IRET

;Here if have IFFAULT instruction

10$:	MOVL	24t[ESP], EAX		;Store error handler offset as return
	POPL	EBX			;  offset
	POPL	EAX			;Restore registers
	POPL	DS
	ADDL	ESP, #12t		;Remove junk from the stack
	IRET				;Go to error handler

;Here when error cannot be recovered

memfail:POPL	EBX			;Restore registers
	POPL	EAX
	POPL	DS			;Save registers in the normal way for
savcom:	CALL	savregs			;  a crash
	JMP	fatal			;And go fail
.PAGE
;Here on fatal system error interrupt

syscrash:
	PUSHL	#0			;Push dummy values to make the stack the
	PUSHL	#0			;  way savregs expects it to be
	PUSHL	#0
	CALL	savregs			;Save registers
	LESL	EDI, 12t[ESP]		;Point to the crash code
	SUBL	12t[ESP], #2		;Adjust EIP value to point to the INT
	MOVL	EAX, ES:[EDI]		;Get crash code
	MOVL	[ESP], EAX
	JMP	fatal
.PAGE
;Here for spurious interrupt from slave interrupt controller

illintmin::
sprints::
	PUSHL	EAX
	MOVB	AL, #INT_EOI		;Release slave interrupt controller
	OUTB	P_INC2P0
	JMP	2$			;Continue

;Here for spurious interrupt from master interrupt controller

sprintm::
	PUSHL	EAX
	MOVB	AL, #INT_EOI		;Release master interrupt controller
2$:	OUTB	P_INC1P0
	POPL	EAX
	IRET				;Just dismiss interrupt

;Generate the entires for each possible illegal interrupt

illint0F:
	PUSHL	#0x0F
	JMP	illint

illint11:
	PUSHL	#0x11
	JMP	illint

illint12:
	PUSHL	#0x12
	JMP	illint

illint13:
	PUSHL	#0x13
	JMP	illint

illint14:
	PUSHL	#0x14
	JMP	illint

illint15:
	PUSHL	#15h
	JMP	illint

illint16:
	PUSHL	#16h
	JMP	illint

illint17:
	PUSHL	#17h
	JMP	illint

illint18:
	PUSHL	#18h
	JMP	illint

illint19:
	PUSHL	#19h
	JMP	illint

illint1A:
	PUSHL	#1Ah
	JMP	illint

illint1B:
	PUSHL	#1Bh
	JMP	illint

illint1C:
	PUSHL	#1Ch
	JMP	illint

illint1D:
	PUSHL	#1Dh
	JMP	illint

illint1E:
	PUSHL	#1Eh
	JMP	illint

illint71:
	PUSHL	#71h
	JMP	illint

illint72:
	PUSHL	#72h
	JMP	illint

illint73:
	PUSHL	#73h
	JMP	illint

illint74:
	PUSHL	#74h
	JMP	illint

illint75:
	PUSHL	#75h
	JMP	illint

illint76:
	PUSHL	#76h
	JMP	illint

illint78:
	PUSHL	#78h
	JMP	illint

illint79:
	PUSHL	#79h
	JMP	illint

illint7A:
	PUSHL	#7Ah
	JMP	illint

illint7B:
	PUSHL	#7Bh
	JMP	illint

illint7C:
	PUSHL	#7Ch
	JMP	illint

illint7D:
	PUSHL	#0x7D
	JMP	illint

illint7E:
illintmax::
	PUSHL	#7Eh
illint:	ANDL	[ESP], #0FFh
	PUSHL	#0
	PUSHL	#'IINT'
	CALL	savregs			;Fall into fatal error routine on next
					;  page
.PAGE
;Here on fatal system error to display console message

fatal::	CLI				;Make sure no interrupts after this
	POPL	crshdata+pg0_crshCODE	;Store crash code
	POPL	EAX			;Discard stacked CR2 value
	POPL	crshdata+pg0_crshERRC	;Store error code for the error display
	POPL	crshdata+pg0_crshEIP	;Store EIP
	POPL	crshdata+pg0_crshCS	;Store CS
	POPL	crshdata+pg0_crshEFR	;Store EFR
	MOVL	EAX, knlSysDateTime#+0	;Store date and time
	MOVL	EDX, knlSysDateTime#+4
	MOVL	crshdata+pg0_crshTIME+0, EAX
	MOVL	crshdata+pg0_crshTIME+4, EDX

;;;;;	JMP	boxdone			;Insert this to eliminate the crash box
					;  and the display reset!

	PUSHL	knlPageZero+pg0_ic1mask	;Save the orignal interrupt enables
	MOVW	knlPageZero+pg0_ic1mask, #0xFFFF
	MOVL	savestk+0, ESP
	MOVL	savestk+4, SS
	CMPL	memoryok#, #0		;Have we set up memory?
	JE	fatal2			;No (Can't switch to real mode and back
					;  unless memory set up has been done!)
	MOVL	EAX, knlPda+pdaPageDir+0 ;Yes - switch to real mode to reset
	MOVL	savepg0d, EAX		 ;  the display

	MOVL	ESI, #crshpg0
	MOVL	ECX, #{crshend-crshpg0}
	MOVL	EBX, #0x83		;Assume have color display
	TESTB	knlDispType#, #DISP$COLOR ;Right?
	JNE	4$			;Yes
	MOVB	BL, #0x87		;No - its mono
4$:	CMPB	knlDispMode#, #DM_TEXT	;Currently in text mode?
	JBE	realmode		;Yes
	ANDL	EBX, #0x7F		;No - clear the screen
	JMP	realmode
.PAGE
;Here on return from real mode after resetting the console display - interrupts
;  are disabled and all segment registers (except CS) are invalid

fatal2:	CLI				;Make sure!
	MOVL	EAX, #GS_XDATA
	MOVL	SS, EAX
	MOVL	DS, EAX
	MOVL	ES, EAX
	MOVL	FS, EAX
	MOVL	GS, EAX
	MOVL	EAX, {crshdata&0xFFF}+pg0_crshCR3
	MOVL	CR3, EAX
	MOVL	EAX, crshdata+pg0_crshCR0 ;Restore the CR0 from the time of the
	MOVL	CR0, EAX		  ;  crash
	MOVL	EAX, crshdata+pg0_crshGDT+0 ;Restore the GDT from the time of
	MOVL	temp+0, EAX		    ;  the crash
	MOVL	EAX, crshdata+pg0_crshGDT+4
	MOVL	temp+2, EAX
	LGDTL	temp
	MOVL	EAX, crshdata+pg0_crshIDT+0 ;Restore the IDT from the time of
	MOVL	temp+0, EAX		    ;  the crash
	MOVL	EAX, crshdata+pg0_crshIDT+4
	MOVL	temp+2, EAX
	LIDTL	temp
	LLDT	crshdata+pg0_crshLDT	;Restore the LDT from the time of the
					;  crash
	LSSL	ESP, savestk		;Restore the SS:ESP from the time of
					;  the crash
	POPL	knlPageZero+pg0_ic1mask	;Restore the original interrupt enables

	MOVL	EDX, #P_EGAGCINDX	;Fix up the VGA display mapping
	MOVB	AL, #0x06
	OUTB	[DX]
	IOPAUSE
	INCL	EDX
	MOVB	AL, #0x06
	OUTB	[DX]

.IF NE 0
	MOVL	EDX, #0x3D4		;Assume have color display
	TESTB	knlDispType#, #DISP$COLOR ;Right?
	JNE	5$			;Yes
	SUBL	EDX, #0x020		;No - its mono
5$:
	INT3

	MOVB	AL, #0x11
	OUTB	[DX]
	IOPAUSE
	INCL	EDX
	INB	[DX]
	IOPAUSE

	MOVB	REG11A, AL

	ANDB	AL, #0x7F
	OUTB	[DX]
	IOPAUSE

	INB	[DX]
	MOVB	REG11B, AL
	IOPAUSE

	DECL	EDX

	MOVB	AL, #0x03		;Make sure can change vertical retrace
	OUTB	[DX]			;  registers
	IOPAUSE
	INCL	EDX
	INB	[DX]
	IOPAUSE

	MOVB	REG03A, AL

	ORB	AL, #0x80
	OUTB	[DX]
	IOPAUSE

	INB	[DX]
	MOVB	REG03B, AL
	IOPAUSE

	DECL	EDX

	MOVB	AL, #0x11
	OUTB	[DX]
	IOPAUSE
	INCL	EDX
	INB	[DX]
	IOPAUSE

	MOVB	REG11xA, AL

	ANDB	AL, #0x7F
	OUTB	[DX]
	IOPAUSE

	INB	[DX]
	IOPAUSE
	MOVB	REG11xB, AL

	DECL	EDX

	MOVB	AL, #6			;Set display for 60 lines instead of 50
	OUTB	[DX]
	IOPAUSE
	INCL	EDX

	INB	[DX]
	IOPAUSE
	MOVB	REG06A, AL

	MOVB	AL, #0x0B
	OUTB	[DX]
	IOPAUSE

	INB	[DX]
	IOPAUSE
	MOVB	REG06B, AL

	DECL	EDX

	MOVB	AL, #7
	OUTB	[DX]
	IOPAUSE
	INCL	EDX
	INB	[DX]
	IOPAUSE

	MOVB	REG07A, AL

	ANDB	AL, #0xDE
	ORB	AL, #0x20
	OUTB	[DX]
	IOPAUSE

	INB	[DX]
	IOPAUSE
	MOVB	REG07B, AL

	DECL	EDX

	MOVB	AL, #0x15
	OUTB	[DX]
	IOPAUSE
	INCL	EDX

	INB	[DX]
	IOPAUSE
	MOVB	REG15A, AL

	MOVB	AL, #0xE7
	OUTB	[DX]
	IOPAUSE

	INB	[DX]
	IOPAUSE
	MOVB	REG15B, AL

	DECL	EDX
.ENDC

	MOVL	EDI, #BOXPSN*2		;Start at top of screen
	MOVL	ESI, #eline
	MOVL	EBX, #crshdata+pg0_crshCODE
	CALL	toscreen		;Display message
boxdone:MOVL	EAX, #geckoxdispatch#	;Was GeckoX or GeckoT loaded?
	ORL	EAX, #geckotdispatch#
	TESTL	EAX, EAX
	JE	stop			;No
	MOVL	EAX, crshdata+pg0_crshEAX ;Yes - restore all registers except
	MOVL	EBX, crshdata+pg0_crshEBX ;  for SS, SP, and CS to make
	MOVL	ECX, crshdata+pg0_crshECX ;  debugging a little easier!
	MOVL	EDX, crshdata+pg0_crshEDX
	MOVL	EDI, crshdata+pg0_crshEDI
	MOVL	ESI, crshdata+pg0_crshESI
	MOVL	EBP, crshdata+pg0_crshEBP
	PUSHL	EAX
	CLRL	EAX
	CMPW	crshdata+pg0_crshES, #3
	JBE	6$
	MOVL	ES, EAX
	VERR	crshdata+pg0_crshES
	JNE	8$
6$:	MOVW	ES, crshdata+pg0_crshES
8$:	CMPW	crshdata+pg0_crshFS, #3
	JBE	10$
	MOVL	FS, EAX
	VERR	crshdata+pg0_crshFS
	JNE	12$
10$:	MOVW	FS, crshdata+pg0_crshFS
12$:	CMPW	crshdata+pg0_crshGS, #3
	JBE	14$
	MOVL	GS, EAX
	VERR	crshdata+pg0_crshGS
	JNE	16$
14$:	MOVW	GS, crshdata+pg0_crshGS
16$:	POPL	EAX
fatal_system_error::
	INT3				;Go to GECKO
	JMP	fatal_system_error


REG11A:	.BYTE	0
REG11B:	.BYTE	0
REG03A:	.BYTE	0
REG03B:	.BYTE	0
REG11xA:.BYTE	0
REG11xB:.BYTE	0
REG06A:	.BYTE	0
REG06B:	.BYTE	0
REG07A:	.BYTE	0
REG07B:	.BYTE	0
REG15A:	.BYTE	0
REG15B:	.BYTE	0

.PAGE
;The following code is copied to the middle of page 0 of physical memory so
;  we can use the BIOS to reset the display hardware.  We change the mapping
;  and segmentation so that this code can be executed with one-to-one mapping
;  so we can disable mapping and then switch to real mode.  After resetting
;  the console display, this code returns to protected mode!
;	c(BL) = BIOS INT 10 set mode function
;	c(BH) = BIOS display mode

	.SEG16				;Assemble this code for a 16 bit
					;  segment, even though it is being
					;  placed in a 32 bit segment here
					;  since we are going to copy it to a
					;  16 bit segment before executing it

crshpg0:MOVL	CR0, EDX
	CLRL	EAX			;Clear the TLB
	MOVL	CR3, EAX
	ANDB	DL, #0FEh		;Switch to real mode
	MOVL	CR0, EDX
	JMPF	0:{crshreal-crshpg0}+800h ;This is needed to load the correct
					  ;  real mode selector into CS
crshreal:
	CLRW	AX			;Set our selectors for real mode
	MOVW	SS, AX
	MOVW	DS, AX
	MOVW	ES, AX
	MOVW	FS, AX
	MOVW	GS, AX
	LIDTL	{crshidt-crshpg0}+0x800	;Set the IDT pointer for real mode
	MOVW	AX, BX			;Get display mode and INT 10 function
	INT	0x10

	MOVW	AX, #0x1112		;Change to 50-line mode
	CLRW	BX
	INT	0x10

	LGDTL	{crshgdt-crshpg0}+0x800	;Reload the GDT for protected mode
	CLI				;Make sure interrupts are disabled
	MOVL	EAX, #pa_nullpgdir#
	MOVL	CR3, EAX
	MOVL	EAX, CR0
	ORL	EAX, #0x80000001	;Set protected mode, paging enabled,
	MOVL	CR0, EAX
	.BYTE	0x66, 0xEA
	.LONG	fatal2
	.WORD	!fatal2

;;;;;;	JMPF	fatal2

crshidt:.WORD	0x3FF
	.LONG	0

crshgdt:.WORD	0xFFFF
	.LONG	gdtable

crshend:

	CODE
.PAGE
;Here if GECKO is not loaded - wait until someone presses one of the Del keys
;  or the Pause key

stop::	CLI
	INB	P_KEYSTS		;Have anything from the keyboard?
	IOPAUSE
	ANDB	AL, #1
	JE	stop			;No - wait
	INB	P_KEYDATA		;Yes - get keyboard code
	CMPB	AL, #0x53		;Is this the reboot key?
	JE	knlReboot		;Yes
	CMPB	AL, #0x62		;Maybe
	JE	knlReboot		;Yes
	CMPB	AL, #0xE1		;Maybe
	JNE	stop			;No - wait

;Here when ready to reboot the system (we are also entered here from GECKO to
;  reboot).  This does a "soft" reboot which preserves memory so that the
;  crash-save data will be preserved.  This is not the easiest way to reboot
;  the system.  It requires that the original machine state be restored so that
;  the BIOS reboot function (which does NOT reset much of anything) will work
;  right!  This includes switching back to real mode.

knlReboot::
	BTL	knlSysDescp#, #SYSD%FASTBOOT ;Want to do a fast boot?
	JC	2$			;Yes
	JMPIL	knlPhysReset		;No - do full physical reset

;Here to do a fast boot

2$:	MOVL	ESI, #rebpg0
	MOVL	ECX, #{rebend-rebpg0}

;	c{EBX} = Data value passed to real mode

realmode:
	MOVB	AL, #0xFF		;Disable all interrupts
	OUTB	P_INC1P1
	IOPAUSE
	OUTB	P_INC2P1
	CLI
	PUSHL	#GS_XDATA
	POPL	DS
	MOVL	EAX, #pa_nullpgdir#	;Use the null process's memory context
	MOVL	CR3, EAX		;  (We know its there and we know where
					;  the page directory is!)

;Now initialize the interrupt controllers like the BIOS does (needed because
;  we have put the hardware vectors in a different place)

	MOVB	AL, #11h		;Controller 1, ICW1, edge, master, ICS4
	OUTB	P_INC1P0
	IOPAUSE
	MOVB	AL, #08h		;Controller 1, ICW2, interrupt type
	OUTB	P_INC1P1
	IOPAUSE
	MOVB	AL, #04h		;Controller 1, ICW3, master level 2
	OUTB	P_INC1P1
	IOPAUSE
	MOVB	AL, #01h		;Controller 1, ICW4, master, 8086 mode
	OUTB	P_INC1P1
	IOPAUSE
	MOVB	AL, knlPageZero+pg0_ic1mask ;Restore interrupt enables for
	OUTB	P_INC1P1		    ;  for controller 1
	IOPAUSE
	MOVB	AL, #11h		;Controller 2, ICW1, edge, master, ICS4
	OUTB	P_INC2P0
	IOPAUSE
	MOVB	AL, #70h		;Controller 2, ICW2, interrupt type
	OUTB	P_INC2P1
	IOPAUSE
	MOVB	AL, #02h		;Controller 2, ICW3, slave level 2
	OUTB	P_INC2P1
	IOPAUSE
	MOVB	AL, #01h		;Controller 2, ICW4, slave, 8086 mode
	OUTB	P_INC2P1
	IOPAUSE
	MOVB	AL, knlPageZero+pg0_ic2mask ;Restore interrupt enables for
	OUTB	P_INC2P1		    ;  controller 2
	IOPAUSE

;Now initialize the DMA controllers

;;;;;	MOVB	AL, #0
;;;;;	OUTB	P_DMA1PG0
;;;;;	IOPAUSE
;;;;;	OUTB	P_DMA1PG1
;;;;;	IOPAUSE
;;;;;	OUTB	P_DMA1PG2
;;;;;	IOPAUSE
;;;;;	OUTB	P_DMA1PG3
;;;;;	IOPAUSE
;;;;;	OUTB	P_DMA2PG1
;;;;;	IOPAUSE
;;;;;	OUTB	P_DMA2PG2
;;;;;	IOPAUSE
;;;;;	OUTB	P_DMA2PG3
;;;;;	IOPAUSE

	.REPT	0Eh
	NOP
	.ENDR

;Now initialize timer 0 to interrupt at the standard BIOS rate (about 18 times
;  a second) - we have changed this too

	MOVB	AL, #34h
	OUTB	P_TMRCWR
	IOPAUSE
	MOVB	AL, #0
	OUTB	P_TMRCNT0
	IOPAUSE
	MOVB	AL, #0
	OUTB	P_TMRCNT0
	IOPAUSE

;Now copy the rest of this routine to physical page 0 - must do this so its
;  in memory which we can map one-to-one so we can disable paging

	PUSHL	DS
	POPL	ES
	MOVL	EDI, #knlPageZero+0x800
	CLD
	RMOVSB	[EDI], [ESI]
	MOVL	EAX, knlDosTime#	 ;Store the current DOS tick count on
	MOVL	knlPageZero+bda_vtimer, EAX ; page 0
	MOVL	knlPageZero, #0x03	;Set up page 0 as a page table with
					;  one entry pointing to page 0
	MOVL	pdabase+pdaPageDir+0, #03
	MOVL	EAX, #0x1000		;Clear the TLB
	MOVL	CR3, EAX		;Get bits for CR0 to disable paging and
	MOVL	EDX, CR0		;  put the FPU bits in the right state
	ANDL	EDX, #0x7FFFFFF1	;This assumes that we have an FPU
	CMPB	fputype#, #FPUTYPE_NONE	;Right?
	JNE	4$			;Yes
	ORB	DL, #0x04		;No - indicate no FPU

;;;;;;; THIS IS WRONG!!!! NEED TO CHANGE SEGS TO 64K LIMIT AND SET LIDT!!!!
;;;;;;; ALSO MAY HAVE PROBLEM WITH GDT AND IDT (SEE VOL 3, PAGE 9-18!)

4$:	MOVL	EAX, #GS_DATAR16	;Reload all of the selectors (we MUST
	MOVL	DS, EAX			;  do this to correctly set the shadow
	MOVL	ES, EAX			;  parts for real mode)
	MOVL	GS, EAX
	MOVL	FS, EAX
	MOVL	SS, EAX
	MOVL	ESP, #0x400
	JMPF	GS_CODER16:0x800	;Reload CS and jump to code at 0x800
.PAGE
;The following code is copied to the middle of page 0 of physical memory.
;  We change the mapping and segmentation so that this code can be executed
;  with one-to-one mapping so we can disable mapping and then switch to real
;  mode.

	.SEG16				;Assemble this code for a 16 bit
					;  segment, even though it is being
					;  placed in a 32 bit segment here
					;  since we are going to copy it to a
					;  16 bit segment before executing it

					;Set CR0 to disable paging and set the
rebpg0:	MOVL	CR0, EDX		;  correct FPU bits
	CLRL	EAX			;Clear the TLB
	MOVL	CR3, EAX
	ANDB	DL, #0xFE		;Switch to real mode
	MOVL	CR0, EDX
	JMPF	0:{rebreal-rebpg0}+0x800 ;This is needed to load the correct
					 ;  real mode selector into CS
rebreal:CLRW	AX			;Set our selectors for real mode
	MOVW	SS, AX
	MOVW	DS, AX
	MOVW	ES, AX
	MOVW	FS, AX
	MOVW	GS, AX
	LIDTL	{rebidt-rebpg0}+0x800	;Set the IDT pointer for real mode
	MOVB	AH, #0			;Try to set display to mode 3
	MOVB	AL, #3
	INT	0x10
	MOVB	AH, #0x0F		;Read back the mode to see if it worked
	INT	0x10
	CMPB	AL, #3
	JE	2$
	MOVB	AH, #0			;Didn't work - try mode 7
	MOVB	AL, #7
	INT	0x10
2$:	MOVW	SI, #{bootmsg-rebpg0}+0x800
	CLRW	DX			;Display the "Booting ..." message
4$:	MOVB	AH, #2
	MOVB	BH, #0
	PUSHW	DX
	PUSHW	SI
	INT	0x10
	POPW	SI
	POPW	DX
	INCW	DX
	MOVB	AL, [SI]		;Get next character
	INCW	SI
	MOVB	AH, #9
	MOVB	BL, #0x70
	MOVB	BH, #0
	MOVW	CX, #1
	CMPB	AL, #0			;Finished?
	JE	6$			;Yes
	PUSHW	DX			;No
	PUSHW	SI
	INT	0x10			;Display the character
	POPW	SI
	POPW	DX
	JMP	4$			;Continue

;Here when finished displaying the message

6$:	INT	0x10
	CLRW	CX
8$:	INB	P_KEYDATA
	IOPAUSE
	INB	P_KEYSTS		;Empty out the keyboard input buffer
	IOPAUSE
	TESTB	AL, #0x02
	LOOPNE	CX, 8$
	MOVL	0x41A, #0x001E001E	;Reset the keyboard buffer
	MOVW	BX, 0x413		;Get size of low memory
	CMPW	BX, #640t		;Make sure not too big
	JBE	10$
	MOVW	BX, #640t
10$:	ANDB	BL, #0xFC		;Round down to whole pages
	SHLW	BX, #6t			;Change to selector value
	CLD				;Just to be very safe and make sure
	MOVW	DX, #0x100		;  nothing that follows XOS is messed
	CLRW	AX			;  by anything we leave behind, zero
12$:	MOVW	ES, DX			;  all base memory above page 0!
	CLRW	DI
	MOVW	CX, #0x800
	RSTOSW	[DI]
	ADDW	DX, #0x100
	CMPW	DX, BX
	JB	12$

;We now have the machine as close as we can get it to the state it was in
;  just before XOS was loaded

	STI				;Enable interrupts
	MOVB	AH, #0			;Reset the floppy disk
	MOVB	DL, #0
	INT	13h
	MOVB	AH, #0
	MOVB	DL, #80			;Reset the hard disk
	INT	13h
20$:	INT	19h			;Reboot the system
	JMP	20$

rebidt:	.WORD	03FFh
	.LONG	0

bootmsg:.ASCIZ	" Booting ... "

rebend:
					;This is needed to restore the correct
	CODE				;  segment size attributes
.PAGE
;Here to do a physical reset of the system - This is normally accessed through
;  the knlPhysReset vector which may be changed by a processor dependent LKE.

physreset::
	MOVB	AL, #0FEh
	OUTB	64h
	MOVL	ECX, #200t
	CALL	knlSDelay#
	JMP	physreset
.PAGE
	.SBTTL	usradrer - Return address error to user
.IF NE 0
;Here when have an address error from exec mode which should be reported to the
;  user as a protection error trap - user state must be saved in the pdaUReg*
;  locations (which means this cannot be used with SVC routines, which do not
;  use the pdaUReg* locations!)

	FAULTHDR
usradrer::
	TESTB	knlTda+tdaURegEFR#+2, #0x02 ;From real mode?
	JNE	realperr		;Yes
	CLI				;No
	MOVL	ESP, #tdaXStkBegin#	;No
	IFFAULT	10$
2$:	POPL	GS			;Restore segment registers
	IFFAULT	12$
4$:	POPL	FS
	IFFAULT	14$
6$:	POPL	ES
	IFFAULT	16$
8$:	POPL	DS
	POPAL				;Restore user registers
	PUSHL	#0
	PUSHL	#0
	TESTB	18t[ESP], #02h		;From real mode?
	JE	9$			;Yes
	PUSHL	#VECT_PROT		;No
	JMP	usertrap

9$:	PUSHL	#VECT_PROT+{ID_PROT/8+200h}*10000h
	JMP	usertrap

	FAULTHDR
10$:	POPL	EAX
	PUSHL	#0
	JMP	2$

	FAULTHDR
12$:	POPL	EAX
	PUSHL	#0
	JMP	4$

	FAULTHDR
14$:	POPL	EAX
	PUSHL	#0
	JMP	6$

	FAULTHDR
16$:	POPL	EAX
	PUSHL	#0
	JMP	8$
.ENDC
.PAGE
;Here on all user mode traps which can be handled by the user - The signal
;  vector has been pushed on the stack, nothing has been saved. Trap is known
;  to be from user mode.  When get here, the exec stack is setup as follows:
;	c{{ESP}+0} = Trap vector number
;	c{{ESP}+4} = Trap data
;	c{{ESP}+8} = Trap error code

usertrap:
	CLI
	POPL	SS:knlTda+tdaTrapVect#
	POPL	SS:knlTda+tdaTrapData#
	POPL	SS:knlTda+tdaTrapCode#
	PUSHAL				;Save user registers in the standard
	PUSHL	DS			;  places
	PUSHL	ES
	PUSHL	FS
	PUSHL	GS
	STI
	PUSHL	#GS_XDATA		;Make exec data addressable
	POPL	DS
	CLRL	ESI
	MOVZWL	EDX, knlTda+tdaTrapVect#+0 ;Get vector number
	CMPL	knlPda+pdaSigVTbl#+4[EDX*8], #0 ;Is the vector set up?
	JE	userfail		;No
	MOVL	ESI, #knlTda+tdaTrapSlb# ;Yes - get address of the trap SLB
	MOVL	slb_vector[ESI], EDX	;Store the vector number
	JMP	dosig2#			;Go do the trap
.PAGE
;Here if no vector is setup for a user mode trap - kill the process

	FAULTHDR
userfail:
	MOVZWL	EAX, knlTda+tdaTrapVect# ;Get termination status value
	ORL	EAX, #TC_NOVECT<24t
	CLRL	ESI
	CLRL	EBX
	JMP	userfail2

;Here if have bad user stack address

	FAULTHDR
badusrstk::				;Discard the error information (Put a
	ADDL	ESP, #12t		;  breakpoint here to see this for
					;  debugging!)
	PUSHL	#GS_XDATA		;Make sure DS is right
	POPL	DS
	MOVL	EAX, #TC_BDUSTK<24t
userfail2:
	PUSHL	EAX
	PUSHL	knlPda+pdaAddr#
	PUSHL	#0
	CALL	sysSchTermProc#		;Kill this process
.PAGE
;Subroutine to find start of next instruction in memory given address of an
;  instruction
;	c{ES:EBX} = Address of instruction
;	CALL	nextins
;	C:set = Cannot determine address of next instruction
;	C:clr = Have address of next instruction
;	  c{ES:EBX} = Address of next instruction
;  All registers except EAX and EBX are unchanged

$$$=0
FRM ni_size, 4
FRM ni_skip, 4
ni_SIZE=!$$$

nextins::
	ENTER	ni_SIZE, 0
	CLRL	EAX
	MOVL	ni_skip[EBP], EAX	;Assume no immediate value bytes to skip
	MOVB	ni_size[EBP], AL	;Assume 16 bit segment
	MOVL	EAX, ES
	LARL	EAX, EAX		;Get access bits for segment
	BTL	EAX, #22t		;Is this a 32 bit segment?
	JNC	nxtinxt			;No
	MOVB	ni_size[EBP], #3	;Yes
	IFFAULT	nxtibad
nxtinxt:MOVZBL	EAX, ES:[EBX]		;Get first opcode byte
	INCL	EBX			;Bump to next byte
	MOVB	AL, opctbl1[EAX]	;Get index
	JMPIL	opcdsp1[EAX]		;Dispatch to routine
.PAGE
;Define symbol used in the opcode byte index tables

DONE=!0t		;This is last byte of opcode
FAIL=!4t		;Memory error on this instruction cannot be recovered
AMBN=!8t		;Address mode byte is next
PRFX=!12t		;Prefix byte
OPFX=!16t		;Operand size prefix byte
APFX=!20t		;Address size prefix byte
OFSN=!24t		;Offset next
XINS=!28t		;Extended instruction prefix byte
IMM1=!32t		;1 byte immediate value follows instruction
IMMX=!36t		;2 or 4 byte immediate value follows instruction
GRP3=!40t		;Group 3 instructions
IMX2=!44t		;2 byte immediate value follows instruction (no memory
			;  address)

;Index table for opcode byte when finding end of instruction

	DATA

opctbl1:.BYTE	AMBN, AMBN, AMBN, AMBN	;00, 01, 02, 03
	.BYTE	FAIL, FAIL, FAIL, FAIL  ;04, 05, 06, 07
	.BYTE	AMBN, AMBN, AMBN, AMBN	;08, 09, 0A, 0B
	.BYTE	FAIL, FAIL, FAIL, XINS  ;0C, 0D, 0E, 0F
	.BYTE	AMBN, AMBN, AMBN, AMBN	;10, 11, 12, 13
	.BYTE	FAIL, FAIL, FAIL, FAIL  ;14, 15, 16, 17
	.BYTE	AMBN, AMBN, AMBN, AMBN	;18, 19, 1A, 1B
	.BYTE	FAIL, FAIL, FAIL, FAIL  ;1C, 1D, 1E, 1F
	.BYTE	AMBN, AMBN, AMBN, AMBN	;20, 21, 22, 23
	.BYTE	FAIL, FAIL, PRFX, FAIL  ;24, 25, 26, 27
	.BYTE	AMBN, AMBN, AMBN, AMBN	;28, 29, 2A, 2B
	.BYTE	FAIL, FAIL, PRFX, FAIL  ;2C, 2D, 2E, 2F
	.BYTE	AMBN, AMBN, AMBN, AMBN	;30, 31, 32, 33
	.BYTE	FAIL, FAIL, PRFX, FAIL  ;34, 35, 36, 37
	.BYTE	AMBN, AMBN, AMBN, AMBN	;38, 39, 3A, 3B
	.BYTE	FAIL, FAIL, PRFX, FAIL  ;3C, 3D, 3E, 3F
	.BYTE	FAIL, FAIL, FAIL, FAIL	;40, 41, 42, 43
	.BYTE	FAIL, FAIL, FAIL, FAIL	;44, 45, 46, 47
	.BYTE	FAIL, FAIL, FAIL, FAIL	;48, 49, 4A, 4B
	.BYTE	FAIL, FAIL, FAIL, FAIL	;4C, 4D, 4E, 4F
	.BYTE	FAIL, FAIL, FAIL, FAIL	;50, 51, 52, 53
	.BYTE	FAIL, FAIL, FAIL, FAIL	;54, 55, 56, 57
	.BYTE	FAIL, FAIL, FAIL, FAIL	;58, 59, 5A, 5B
	.BYTE	FAIL, FAIL, FAIL, FAIL	;5C, 5D, 5E, 5F
	.BYTE	FAIL, FAIL, FAIL, FAIL	;60, 61, 62, 63
	.BYTE	PRFX, PRFX, OPFX, APFX	;64, 65, 66, 67
	.BYTE	FAIL, FAIL, FAIL, FAIL	;68, 69, 6A, 6B
	.BYTE	FAIL, FAIL, FAIL, FAIL	;6C, 6D, 6E, 6F
	.BYTE	FAIL, FAIL, FAIL, FAIL	;70, 71, 72, 73
	.BYTE	FAIL, FAIL, FAIL, FAIL	;74, 75, 76, 77
	.BYTE	FAIL, FAIL, FAIL, FAIL	;78, 79, 7A, 7B
	.BYTE	FAIL, FAIL, FAIL, FAIL	;7C, 7D, 7E, 7F
	.BYTE	IMM1, IMMX, IMM1, IMM1	;80, 81, 82, 83
	.BYTE	AMBN, AMBN, AMBN, AMBN	;84, 85, 86, 87
	.BYTE	AMBN, AMBN, AMBN, AMBN	;88, 89, 8A, 8B
	.BYTE	AMBN, FAIL, AMBN, AMBN	;8C, 8D, 8E, 8F
	.BYTE	FAIL, FAIL, FAIL, FAIL	;90, 91, 92, 93
	.BYTE	FAIL, FAIL, FAIL, FAIL	;94, 95, 96, 97
	.BYTE	DONE, DONE, FAIL, DONE	;98, 99, 9A, 9B
	.BYTE	FAIL, FAIL, FAIL, FAIL	;9C, 9D, 9E, 9F
	.BYTE	OFSN, OFSN, OFSN, OFSN	;A0, A1, A2, A3
	.BYTE	DONE, DONE, DONE, DONE	;A4, A5, A6, A7
	.BYTE	FAIL, FAIL, DONE, DONE	;A8, A9, AA, AB
	.BYTE	DONE, DONE, DONE, DONE	;AC, AD, AE, AF
	.BYTE	FAIL, FAIL, FAIL, FAIL	;B0, B1, B2, B3
	.BYTE	FAIL, FAIL, FAIL, FAIL	;B4, B5, B6, B7
	.BYTE	FAIL, FAIL, FAIL, FAIL	;B8, B9, BA, BB
	.BYTE	FAIL, FAIL, FAIL, FAIL	;BC, BD, BE, BF
	.BYTE	IMM1, IMM1, FAIL, FAIL	;C0, C1, C2, C3
	.BYTE	AMBN, AMBN, IMM1, IMMX	;C4, C5, C6, C7
	.BYTE	FAIL, FAIL, IMX2, DONE	;C8, C9, CA, CB
	.BYTE	FAIL, FAIL, FAIL, DONE	;CC, CD, CE, CF
	.BYTE	AMBN, AMBN, AMBN, AMBN	;D0, D1, D2, D3
	.BYTE	FAIL, FAIL, FAIL, DONE	;D4, D5, D6, D7
	.BYTE	AMBN, AMBN, AMBN, AMBN	;D8, D9, DA, DB
	.BYTE	AMBN, AMBN, AMBN, AMBN	;DC, DD, DE, DF
	.BYTE	FAIL, FAIL, FAIL, FAIL	;E0, E1, E2, E3
	.BYTE	FAIL, FAIL, FAIL, FAIL	;E4, E5, E6, E7
	.BYTE	FAIL, FAIL, FAIL, FAIL	;E8, E9, EA, EB
	.BYTE	FAIL, FAIL, FAIL, FAIL	;EC, ED, EE, EF
	.BYTE	FAIL, FAIL, PRFX, PRFX	;F0, F1, F2, F3
	.BYTE	FAIL, FAIL, GRP3, GRP3	;F4, F5, F6, F7
	.BYTE	FAIL, FAIL, FAIL, FAIL	;F8, F9, FA, FB
	.BYTE	FAIL, FAIL, FAIL, FAIL	;FC, FE, FD, FF

;Dispatch table for first opcode byte

opcdsp1:.LONG	nxtidon		;DONE =  0. - This is last byte of opcode
	.LONG	nxtibad		;FAIL =  4. - Memory error on this instruction
				;	       cannot be recovered
	.LONG	nxtiamb		;AMBN =  8. - Address mode byte is next
	.LONG	nxtinxt		;PRFX = 12. - Prefix byte
	.LONG	nxtiosp		;OPFX = 16. - Operand size prefix byte
	.LONG	nxtiasp		;APFX = 20. - Address size prefix byte
	.LONG	nxtiofs		;OFSN = 24. - Offset next
	.LONG	nxtixip		;XINS = 28. - Extended instruction prefix byte
	.LONG	nxtiim1		;IMM1 = 32. - 1 byte immediate value follows
				;		instruction
	.LONG	nxtiimx		;IMMX = 36. - 2 or 4 byte immediate value
				;		follows instruction
	.LONG	nxtigp3		;GRP3 = 40. - Group 3 instructions
	.LONG	nxtixm2		;IMX2 = 44. - 2 byte immediate value follows
				;		instruction (no memory address)

	CODE
.PAGE
;Here if cannot find end of instruction for some reason

	FAULTHDR
nxtibad:STC				;Indicate error
	LEAVE
	RET				;And return

;Here when finding end of instruction when current byte is an operand size
;  prefix

nxtiosp:XORB	ni_size[EBP], #1	;Change operand size
	JMP	2$

;Here when finding end of instruction when current byte is an address size
;  prefx

nxtiasp:XORB	ni_size[EBP], #2	;Change address size
2$:	JMP	nxtinxt

;Here when finding end of instruction when current byte is an extended
;  instruction prefix byte

	IFFAULT	nxtibad
nxtixip:MOVB	AL, ES:[EBX]		;Get next byte
	INCL	EBX
	CMPB	AL, #3
	JBE	nxtiamb
	CMPB	AL, #0A3h
	JE	nxtiamb
	CMPB	AL, #0B3h		;Is this a good instruction?
	JB	6$			;No
	CMPB	AL, #0BAh
	JE	nxtiim1
	CMPB	AL, #0BFh
	JBE	nxtiamb
6$:	JMP	nxtibad			;No
.PAGE
;Here when finding end of instruction when current byte is opcode byte for
;  group 3 instruction

	IFFAULT	nxtibad			;Is this an immediate mode TEST
nxtigp3:TESTB	ES:1[EBX], #0x38	;  instruction?
	JNE	nxtiamb			;No
	TESTB	ES:[EBX], #0x01		;Yes - is it TESTB?
	JNE	nxtiimx			;No
					;Yes

;Here when finding end of instruction when current byte is opcode byte for
;  instruction with 1 byte immediate operand

nxtiim1:MOVB	AL, #1			;Get size of immediate operand
	JMP	4$

;Here when finding end of instruction when current byte is opcode byte for
;  instruction with 2 or 4 byte immediate operand

nxtiimx:MOVB	AL, #2			;Assume 2 byte immediate operand
	TESTB	ni_size[EBP], #1	;Right?
	JE	4$			;Yes
	INCL	EAX			;No - its 4 bytes
	INCL	EAX
4$:	MOVB	ni_skip[EBP], AL	;Skip this many bytes at end
					;Fall into nxtiamb routine

;Here when finding end of instruction when next byte is the addressing
;  mode byte

	IFFAULT	nxtibad
nxtiamb:MOVB	AL, ES:[EBX]		;Get the address mode byte
	INCL	EBX
	ANDB	AL, #0C7h
	TESTB	ni_size[EBP], #2	;32 bit address mode?
	JNE	10$			;Yes
	CMPB	AL, #06h		;Simple 16 bit offset?
	JE	nxtixm2			;Yes
	ANDB	AL, #0C0h		;No - any more bytes?
	JE	nxtidon			;No
	CMPB	AL, #0C0h		;Maybe
	JE	nxtidon			;No
	CMPB	AL, #40h		;Yes - only 1 byte?
	JE	20$			;Yes
	JMP	nxtixm2			;No - 2 bytes

;Here for 32 bit address modes

10$:	CMPB	AL, #05h		;Simple 32 bit offset?
	JE	nxtiofs			;Yes
	CMPB	AL, #04h		;No - is the SIB byte present?
	JE	14$			;Yes
	CMPB	AL, #44h
	JE	14$			;Yes
	CMPB	AL, #84h
	JNE	16$			;No
	IFFAULT	nxtibad
14$:	MOVB	AH, ES:[EBX]		;Get the SIB byte
	INCL	EBX
	ANDB	AH, #07h		;We only care about the low 3 bits
	ANDB	AL, #0C0h
	ORB	AH, AL
	CMPB	AH, #5			;Is this the exception?
	JE	nxtiofs			;Yes - have 4 offset bytes
16$:	ANDB	AL, #0C0h		;Only care about the high 2 bits now
	JE	nxtidon			;Any more bytes?
	CMPB	AL, #0C0h		;Maybe
	JE	nxtidon			;No
	CMPB	AL, #40h		;Yes - only 1 byte?
	JE	20$			;Yes
					;No

;Here when finding end of instruction when next byte starts a memory offset

nxtiofs:INCL	EBX			;Point to end of 16 bit offset
	INCL	EBX
	TESTB	ni_size[EBP], #2	;Have 32 bit offset?
	JE	nxtidon			;No
nxtixm2:INCL	EBX			;Yes
20$:	INCL	EBX

;Here when finding end of instruction when current byte is the last byte of
;  the instuction

nxtidon:ADDL	EBX, ni_skip[EBP]	;Skip over any immediate value bytes
	LEAVE
	RET				;Finished
.PAGE
;Subroutine to save registers on error trap
;	CALL	savregs

savregs:PUSHL	DS
	PUSHL	#GS_XDATA
	POPL	DS
	POPL	crshdata+pg0_crshDS
	MOVL	crshdata+pg0_crshESP, ESP
	ADDL	crshdata+pg0_crshESP, #28t
	MOVL	crshdata+pg0_crshSS, SS
	MOVL	crshdata+pg0_crshES, ES
	MOVL	crshdata+pg0_crshFS, FS
	MOVL	crshdata+pg0_crshGS, GS
	SLDT	crshdata+pg0_crshLDT
	STR	crshdata+pg0_crshTR
	MOVL	crshdata+pg0_crshEBX, EBX
savreg2:MOVL	crshdata+pg0_crshEAX, EAX
	MOVL	crshdata+pg0_crshECX, ECX
	MOVL	crshdata+pg0_crshEDX, EDX
	MOVL	crshdata+pg0_crshEDI, EDI
	MOVL	crshdata+pg0_crshESI, ESI
	MOVL	crshdata+pg0_crshEBP, EBP
	SIDT	crshdata+pg0_crshIDT
	MOVL	EAX, crshdata+pg0_crshIDT+2
	MOVL	crshdata+pg0_crshIDT+4, EAX
	SGDT	crshdata+pg0_crshGDT
	MOVL	EAX, crshdata+pg0_crshGDT+2
	MOVL	crshdata+pg0_crshGDT+4, EAX
	MOVL	EAX, CR0
	MOVL	crshdata+pg0_crshCR0, EAX
	MOVL	EAX, CR2
	MOVL	crshdata+pg0_crshCR2, EAX
	MOVL	EAX, CR3
	MOVL	crshdata+pg0_crshCR3, EAX
	MOVL	EAX, crshdata+pg0_crshESP
	MOVL	stkaddr, EAX
	MOVL	ECX, #tdaXStackV#	;Calculate how much is on the stack
	SUBL	ECX, EAX	;;;?????
	SHRL	ECX, #2
	CMPL	ECX, #32t		;Too much to display?
	JBE	6$			;No
	MOVL	ECX, #32t		;Yes - just display what we can
6$:	MOVB	stkcnt, CL		;Save amount for display routine
	TESTL	ECX, ECX		;Anything to save?
	JE	10$			;No
	PUSHL	DS			;Yes - store up to the first 32 longs
	PUSHL	DS			;  of the stack for display
	POPL	ES
	MOVL	ESI, crshdata+pg0_crshESP
	MOVW	DS, crshdata+pg0_crshSS
	MOVL	EDI, #crshdata+pg0_crshSTK
	CLD
	RMOVSL	[EDI], [ESI]
	POPL	DS
10$:	RET				;All done here
.PAGE
;Subroutine to place error box on the screen
;	c{EBX}    = Offset for values to display
;	c{ESI}    = Offset of error message string
;	c{ES:EDI} = Pointer to screen buffer
;	CALL	toscreen

toscreen:
	MOVL	EAX, firstlke#
	MOVL	nextlke, EAX
	TESTB	knlDispType#, #DISP$COLOR ;Color display?
	JNE	tosloop			;Yes
	MOVB	attrib, #A_MNORM	;No - fix up normal display attribute
tosloop:MOVZBL	EAX, [ESI]		;Get character
	INCL	ESI
	TESTB	AL, AL			;Done?
	JE	4$			;Yes
	CMPB	AL, #LF			;End of line?
	JE	14$			;Yes
	CMPB	AL, #'%'		;Insert word value?
	JE	18$			;Yes
	CMPB	AL, #'#'		;Insert stack value?
	JE	tosstkv			;Yes
	CMPB	AL, #'*'		;Insert stack address?
	JE	tosstka			;Yes
	cMPB	AL, #'!'		;Insert LKE name and address?
	JE	toslke
	CMPB	AL, #'&'		;Insert long value?
	JE	toslong			;Yes
	CMPB	AL, #'+'		;Insert data character?
	JE	12$
	CMPB	AL, #'='		;Insert XOS version?
	JE	tosver
	CMPB	AL, #'('		;Start blink?
	JE	6$			;Yes
	CMPB	AL, #')'		;End special?
	JE	8$			;Yes
	CMPB	AL, #'{'		;Start inverse?
	JE	10$
2$:	MOVB	AH, attrib		;Get attribute byte
	MOVW	textdispbase[EDI], AX	;Store character and attribute
	ADDL	EDI, #2
	JMP	tosloop			;Continue

;Here if finished

4$:	RET

;Here to start blink region

6$:	MOVB	attrib, #A_CBLNK
	TESTB	knlDispType#, #DISP$COLOR
	JNE	tosloop
	MOVB	attrib, #A_MBLNK
	JMP	tosloop

;Here to end blink region

8$:	MOVB	attrib, #A_CNORM
	TESTB	knlDispType#, #DISP$COLOR
	JNE	tosloop
	MOVB	attrib, #A_MNORM
	JMP	tosloop

;Here to start inverse region

10$:	MOVB	attrib, #A_CINVR
	TESTB	knlDispType#, #DISP$COLOR
	JNE	tosloop
	MOVB	attrib, #A_MINVR
	JMP	tosloop

;Here to insert data character

12$:	MOVB	AL, [EBX]		;Get data character
	INCL	EBX
	JMP	2$			;Go display it

;Here if at end of line

14$:

.IF NE 0
	PUSHL	EDX
	LEAL	EAX, -1[EDI]		;Advance to start of next line
	ANDL	EAX, #0FFFh
	ANDL	EDI, #0FFFFF000h
	CLRL	EDX
	MOVL	ECX, #160t
	DIVL	ECX
	INCL	EAX
	MULL	ECX
	POPL	EDX
	LEAL	EDI, BOXPSN*2[EAX+EDI]
.ENDC

	ADDL	EDI, #BOXPSN*2

	CMPB	stkcnt, #0		;Done with stack data?
	JG	tosloop			;No - continue
	MOVL	ESI, #lkeln		;Yes - skip the rest
	CMPL	nextlke, #0		;Done with LKEs?
	JNE	tosloop
	MOVL	ESI, #lastln
	JMP	tosloop

;Here if need to insert 32 bit hex value

toslong:MOVL	EAX, [EBX]
	CALL	dsplong
	JMP	20$

;Here if need to insert 16 bit hex value

18$:	MOVZWL	EAX, [EBX]		;Get value
	SHLL	EAX, #16t
	MOVL	ECX, #4
	CALL	dspnhex			;Display it
20$:	ADDL	EBX, #4
	JMP	tosloop
.PAGE
;Here to insert the XOS version number

tosver:	MOVL	EDX, #knlName#
	MOVB	AH, attrib		;Get attribute byte
	MOVL	ECX, #47t
4$:	MOVB	AL, [EDX]
	INCL	EDX
	CMPB	AL, #0
	JE	tosfill
	MOVW	textdispbase[EDI], AX
	ADDL	EDI, #2
	LOOP	ECX, 4$
	JMP	tosloop
.PAGE
;Here if need to insert 32 bit hex value from the stack

tosstkv:DECB	stkcnt			;Anything left to display?
	JNS	toslong			;Yes - just display it
	MOVB	AL, #'-'		;No - display "--------"
	MOVB	AH, attrib
	MOVL	ECX, #8
24$:	MOVW	textdispbase[EDI], AX
	ADDL	EDI, #2
	LOOP	ECX, 24$
	JMP	tosloop
.PAGE
;Here if need to insert 32 bit stack address

tosstka:MOVL	EAX, stkaddr
	CALL	dsplong
	ADDL	stkaddr, #0x10
	JMP	tosloop

;Here if need to insert name and address of an LKE

toslke:	MOVB	stkcnt, #0		;So the EOL check works right!
	MOVB	AH, attrib		;Get attribute byte
	CMPL	nextlke, #0		;Have another LKE
	JNE	4$			;Yes
	MOVL	ECX, #25t
tosfill:MOVB	AL, #' '		;No - display 16 spaces
2$:	MOVW	textdispbase[EDI], AX	;Store character and attribute
	ADDL	EDI, #2
	LOOP	ECX, 2$
	JMP	tosloop

;Here with another LKE to display

4$:	MOVL	EBX, nextlke
	ADDL	EBX, #lke_name
	MOVL	ECX, #10t
6$:	MOVB	AL, [EBX]
	INCL	EBX
	CMPB	AL, #0
	JE	8$
	MOVW	textdispbase[EDI], AX
	ADDL	EDI, #2
	LOOP	ECX, 6$
8$:	MOVB	AL, #' '
10$:	CMPL	ECX, #0
	JE	12$
	MOVW	textdispbase[EDI], AX
	ADDL	EDI, #2
	DECL	ECX
	JMP	10$

12$:	MOVB	AL, #'='
	MOVW	textdispbase[EDI], AX
	ADDL	EDI, #2
	MOVL	EAX, nextlke
	SHLL	EAX, #12t
	MOVL	ECX, #5
	CALL	dspnhex

	MOVB	AH, attrib
	MOVB	AL, #' '
	MOVW	textdispbase[EDI], AX
	ADDL	EDI, #2

	LEAL	ECX, 16t[EDI]
	MOVL	EAX, nextlke
	MOVZBL	EAX, lke_version+3[EAX]
	CALL	dspdec
	MOVB	AH, attrib
	MOVB	AL, #'.'
	MOVW	textdispbase[EDI], AX
	ADDL	EDI, #2

	MOVL	EAX, nextlke
	MOVZBL	EAX, lke_version+2[EAX]
	CALL	dspdec
	MOVB	AH, attrib
	MOVB	AL, #'.'
	MOVW	textdispbase[EDI], AX
	ADDL	EDI, #2

	MOVL	EAX, nextlke
	MOVZWL	EAX, lke_version+0[EAX]
	CALL	dspdec

	MOVL	EDX, nextlke		;Advance to next lke
	MOVL	EDX, lke_next[EDX]
	MOVL	nextlke, EDX

	CMPL	EDI, ECX		;Did we fill the field?
	JB	14$			;No
	MOVL	EDI, ECX		;Yes
	JMP	tosloop

14$:	SUBL	ECX, EDI
	SHRL	ECX, #1
	JMP	tosfill
.PAGE
;Function to display a decimal number
;	c{EAX} = Value to display
;	c{ECX} = Maximum pointer value

dspdec:	CLRL	EDX
	DIVL	lit10
	PUSHL	EDX
	TESTL	EAX, EAX
	JE	4$
	CALL	dspdec
4$:	POPL	EAX
	CMPL	EDI, ECX
	JAE	6$
	MOVB	AH, attrib
	ADDL	EAX, #'0'
	MOVW	textdispbase[EDI], AX	;Store character and attribute
	ADDL	EDI, #2
6$:	RET

lit10:	.LONG	10t
.PAGE
;Subroutine to display a long
;	c{EAX} = Value

dsplong:MOVL	ECX, #8

;Subroutine to display N hex digits
;	c{EAX} = Value (left justified)
;	c{ECX} = Number of digits

dspnhex:ROLL	EAX, #4			;Get next 4 bits
	PUSHL	EAX
	ANDL	EAX, #0x0F
	CMPL	EAX, #0x09
	JLE	4$
	ADDL	EAX, #'A'-'0'-0x0A
4$:	ADDL	EAX, #'0'
	MOVB	AH, attrib
	MOVW	textdispbase[EDI], AX	;Store character and attribute
	ADDL	EDI, #2
	POPL	EAX
	LOOP	ECX, dspnhex
	RET
.PAGE
;Crash message text

eline:	.BYTE	BTL
	.REPT	9t
	.NLIST
	.BYTE	BHL
	.LIST
	.ENDR
	.ASCII	"( Fatal system error )"
	.REPT	17t
	.NLIST
	.BYTE	BHL
	.LIST
	.ENDR
	.ASCII	"{ ++++ )"
;;;;	.REPT	9t
;;;;	.NLIST
;;;;	.BYTE	BHL
;;;;	.LIST
;;;;	.ENDR
;;;;	.BYTE	BTR
	.BYTE	LF
	.ASCII	{BVL}"    ="{BVL}{LF}
	.ASCII	{BVL}"EAX:& EBX:& ECX:& EDX:&"{BVL}{LF}
	.ASCII	{BVL}"ESP:& EBP:& EDI:& ESI:&"{BVL}{LF}
	.ASCII	{BVL}"CS:% SS:% DS:% ES:% FS:% GS:%    "{BVL}{LF}
	.ASCII	{BVL}"EIP:& EFR:& TR:% LDT:%         "{BVL}{LF}
	.ASCII	{BVL}"IDT:%-&   GDT:%-&              "{BVL}{LF}
	.ASCII	{BVL}"ERR:& CR0:& CR2:& CR3:&"{BVL}{LF}
	.ASCII	{BVL}"Data:& & & & &  "{BVL}{LF}
	.ASCII	{BVL}"     & & & & &  "{BVL}{LF}
	.ASCII	{BVL}"     & & & & &  "{BVL}{LF}
	.ASCII	{BVL}"     & & & & &  "{BVL}{LF}
	.ASCII	{BVL}"Stk:*> # # # #  "{BVL}{LF}
	.ASCII	{BVL}"    *> # # # #  "{BVL}{LF}
	.ASCII	{BVL}"    *> # # # #  "{BVL}{LF}
	.ASCII	{BVL}"    *> # # # #  "{BVL}{LF}
	.ASCII	{BVL}"    *> # # # #  "{BVL}{LF}
	.ASCII	{BVL}"    *> # # # #  "{BVL}{LF}
	.ASCII	{BVL}"    *> # # # #  "{BVL}{LF}
	.ASCII	{BVL}"    *> # # # #  "{BVL}{LF}
lkeln:	.ASCII	{BVL}"! !"{BVL}{LF}
	.ASCII	{BVL}"! !"{BVL}{LF}
	.ASCII	{BVL}"! !"{BVL}{LF}
	.ASCII	{BVL}"! !"{BVL}{LF}
	.ASCII	{BVL}"! !"{BVL}{LF}
	.ASCII	{BVL}"! !"{BVL}{LF}
	.ASCII	{BVL}"! !"{BVL}{LF}
	.ASCII	{BVL}"! !"{BVL}{LF}
	.ASCII	{BVL}"! !"{BVL}{LF}
	.ASCII	{BVL}"! !"{BVL}{LF}
	.ASCII	{BVL}"! !"{BVL}{LF}
	.ASCII	{BVL}"! !"{BVL}{LF}
	.ASCII	{BVL}"! !"{BVL}{LF}
	.ASCII	{BVL}"! !"{BVL}{LF}
	.ASCII	{BVL}"! !"{BVL}{LF}
lastln:	.BYTE	BBL
	.REPT	51t
	.NLIST
	.BYTE	BHL
	.LIST
	.ENDR
	.BYTE	BBR
	.BYTE	0
.PAGE
	DATA

knlPhysReset::			;Physical reset vector
	   .LONG physreset
memfault:: .LONG 0		;Offset of last exec mode IFFAULT instruction
memufault::.LONG 0		;Offset of last user mode IFFAULT instruction
userdatsz::.LONG 0
useradrsz::.LONG 0

rmlastprot::
	   .LONG 0

savestk:   .LONG 0, 0
savepg0d:  .LONG 0
temp:	   .LONG 0, 0

nextlke:   .LONG 0
stkaddr:   .LONG 0
stkcnt:	   .BYTE 0
attrib:	   .BYTE A_CNORM
fpuignore::.BYTE 0		;Non-zero if should ignore FPU traps

	.MOD	4
msgbfr:	   .BYTE MT_SYSLOG, 1, 0, 0
	   .LONG 0, 0, 0, 0
msgend:

xxxxCR3:: .LONG  0
xxxxTR::  .LONG  0
xxxxDR6v::.LONG  0
	  .LONG  0x55553333

	END
