	.TITLE	alarm - Alarm routines

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

	.PROC	80486
	.INCLUD	XOSINC:\XMAC\XOS.PAR
	.INCLUD	XOSINC:\XMAC\XOSX.PAR
	.INCLUD	XOSINC:\XMAC\XOSTIME.PAR
	.INCLUD	XOSINC:\XMAC\XOSDOS.PAR
	.INCLUD	XOSINC:\XMAC\XOSXTRM.PAR
	.INCLUD	XOSINC:\XMAC\XOSERR.PAR

	CODE

;Here for the svcSchClrAlarm SVC - Clear alarm
;	long svcSchClrAlarm(
;	    long  handle);	// Alarm handle
;  Value returned is 0 if normal or a negative XOS error code if error.

;NOTE: This will return an ER_NTDEF error if the alarm has expired and the
;      alarm is not repeated. Due to queuing of signals, this may happen when
;      the user's alarm signal has not been seen yet.

psvcSchClrAlarm::
	TOFORK
	PUSHL	knlTda+tdaArg1#		;Cancel the timer
	CALL	sysSchTmrCancel#
	FROMFORK
	TESTL	EAX, EAX
	JE	4$			;If no alarm was found
	DECL	knlPda+pdaAlrmCnt#	;Reduce number of alarms
	JNS	2$
	CRASH	BDAC			;[BaD Alarm Count]

2$:	CLRL	EAX
	RET

;Here if the TMR was not found

4$:	MOVL	EAX, #ER_NTDEF
	RET
.PAGE
;Here for the svcSchSetAlarm SVC - Set alarm
;	long svcSchSetAlarm(
;	    long  vector,	// Signal vector
;	    long  data;		// Signal data
;	    llong dt,		// Date/time (bit 63 set if repeated)
;  Value returned is the alarm handle (positive) if normal or a negative XOS
;    error code if error.

psvcSchSetAlarm::
	MOVL	EDX, knlTda+tdaArg1#	;Get vector number
	CMPL	EDX, #0x30		;Make sure valid
	JB	10$
	CMPL	EDX, #0xFF
	JA	10$
	CMPL	knlPda+pdaSigVTbl#+4[EDX*8], #0 ;Is the vector set up?
	JE	12$			;No - fail
	MOVL	EAX, knlPda+pdaAlrmCnt#	;Do we have too many alarms now?
	CMPL	EAX, almlimit#
	JB	6$			;No - go on
	MOVL	EAX, #ER_TMALM
	RET

6$:	PUSHL	knlTda+tdaArg3#
	PUSHL	knlTda+tdaArg4#
	PUSHL	EDX			;First data item is the vector number
	PUSHL	knlTda+tdaArg2#		;Second data item is the user's data
					;  value
	PUSHL	#alarmdone
	CALL	sysSchTmrCreate#	;Create the TMR
	TESTL	EAX, EAX
	JS	8$			;If error
	INCL	knlPda+pdaAlrmCnt#	;OK - count this alarm
8$:	RET

;Here if bad vector number

10$:	MOVL	EAX, #ER_BADVN
	RET

;Here if vector is not set up

12$:	MOVL	EAX, #ER_VECNS
	RET
.PAGE
;Timer function called in scheduler context when an alarm timer expires.
;	void alarmdone(
;	    PDA *pda,		// Actual address of PDA
;	    long handle,	// Alarm handle (bit 31 set if repeated)
;	    long data1,		// Signal vector number
;	    long data2);	// Signal data

adn_pda  =!16t
adn_hndl =!12t
adn_data1=!8
adn_data2=!4

alarmdone::
	MOVL	EDX, adn_pda[ESP]	;Get target PDA
	TESTB	adn_hndl+3[ESP], #0x80	;Repeated alarm?
	JNE	6$			;Yes
	DECL	pdaAlrmCnt#[EDX]	;No - reduce his alarm count
	JNS	6$
	CRASH	BDAC			;[BaD Alarm Count]

6$:	PUSHL	adn_data2[ESP]		;Stack user's value as signal data
	PUSHL	adn_hndl+4[ESP]		;Stack the alarm handle
	PUSHL	#2			;2 data items
	PUSHL	pdaPid#[EDX]		;Target PID
	PUSHL	#0			;No grant function
	PUSHL	#0
	MOVZBL	EAX, adn_data1+24t[ESP]	;Vector number
	PUSHL	EAX
	CALL	sysSchReqSignal#	;Request signal
	ADDL	ESP, #28t
	RET	16t

	END
