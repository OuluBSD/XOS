	.TITLE	data - XOS common data

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

	.PROC	80486
	.INCLUD	XOSINC:\XMAC\XOS.PAR
	.INCLUD	XOSINC:\XMAC\XOSX.PAR
	.INCLUD	XOSINC:\XMAC\XOSTIME.PAR
	.INCLUD	XOSINC:\XMAC\XOSDOS.PAR
	.INCLUD	XOSINC:\XMAC\XOSXTRM.PAR
	.INCLUD	XOSINC:\XMAC\PCAT.PAR

.IF NDF $$GECKOB
  $$GECKOB =!0		;Set non-zero if linking GECKOB
.ENDC

XOSMAJV=!4		;XOS major version number
XOSMINV=!5		;XOS minor version number
XOSEDIT=!1		;XOS edit number

;NOTE: DON'T FORGET TO ALSO UPDATE THE VERSION NUMBER IN MAKEFILE.MAK!!

;NOTE: All previous history comments moved to the file history.m86 to reduce
;	 size of this file!

;3.4.0  - 10-Apr-09
;	Changed base of the exec code (GS_XCODE) and data (GS_XDATA) segments
;	to 0. (Still uses segmentation otherwise)
;4.0.0  - 22-Jun-09
;	Lots of changes. Logical name and path handling rewritten, both now
;	use XMBs. Logical name and path svcs changed significantly. Logical
;	names are now "live". Boot sequence modified signficantly to allow
;	booting from USB file structured devices. No longer image compatable
;	with version 3.x.x
;4.0.1  - 30-Jun-09
;	Lots more changes. Now bootable for USB disks. USB retry implimented
;	so can load link and class drivers for USB devices after the device
;	is originally detected by USBCTL. vesaadev works.
;4.1.0  - 
;	Version released to WERC. Lots more changes and bug fixes. Uses disk
;	ID to find boot disk.
;4.1.1  - 6-Dec-09
;	Many changes.
;4.1.2  - 7-Dec-09
;	Fixed problem with getting HR date-time.
;4.1.3  - 15-Dec-09
;	Most of the segment/msect/psect names changed to be more compatable
;	with the names generated by the Watcom C compiler.
;4.2.0	- 9-Jan-10
;	Some RUN file format changes requiring recompiling of everything!
;	(Everything now compiled with OWXC.)
;4.3.0  - 18-Jan-10
;	Mostly minor fixes, kernel moved to base directory, requiring bootstrap
;	version 8.1.
;4.4.0  -
;	Major rewrite of the FFS support, major changes to remove a lot of
;	code from fork level.
;4.4.1  -
;	Mostly bug fixes.
;4.4.2  - 19-May-2010
;       More bug fixes, expanded the "crash box".
;4.4.3  - 20-May-2010
;	More bug fixes, fixed cache block number problem, removed early crash
;	breakpoint.
;4.4.7  - 29-Jun-2010
;	More bug fixes
;4.4.8  -  6-Jul-2010
;	Fixed incorrect thread limit hanling, fixed problems with INx and OUTx
;	in GECKOT.
;4.4.9	-  8-Jul-2010
;	Changed knlQ_xxx to knlS_xxx, restructured scheduler queues, fixed
;	problem with terminating threads waiting for abortable IO.
;4.4.10	- 11-Jul-2010
;	Modified USBCTL to fully use threads. Wrote USBWAIT which allows
;	startup stuff to wait only until USBCTL is idle. Added a per-thread
;	memory page (which moved the HUM up 1KB). Fixed a number of problems
;	with threads.
;4.4.11 - 26-Jul-2010
;	Fixed problem sync with svcTrmWrtInB.
;4.4.12 -  9-Aug-2010
;	"Offical" XOS release!
;4.4.13 - 20-Aug-2010
;	First version to fully support exec mode C code. nullcls, ipmcls,
;	IO parameter routines, and characteristics routine rewritten in C.
;	Eliminted extra parameter processing when opening devices. (Not needed
;	since "search open directory" parameter eliminated.)
;4.4.16 - 18-Oct-2010
;	Werc release.
;4.4.18 - 24-Oct-2010
;	Rewrote memory page management code. It now uses a single level
;	memtable and supports up to 4GB RAM. Also slightly reduced base memory
;	requirements.
;4.4.19 - 9-Nov-2010
;	Added "gecko" item to the HUM.
;4.4.20 - 2-Dec-2010
;	Major changes to IO scheduling to fix some problems with canceling IO.
;	ioclose rewritten in C.
;4.4.21 - 26-Dec=2010
;       Changed sysIoRunCmd to take a list of files rather than an environment
;       string name.
;4.5.0  -  6-Jan-2011
;	Public release
;4.5.1  - 11-Jan-2011
;	Added DM_ACTIVE bit to indicate current display.

DOSMAJV==!3		;DOS emulator major version number
DOSMINV==!30t		;DOS emulator minor version number

LKEMAJC=!10t		;LKE major compatability level
LKEMINC=!0		;LKE minor compatability level

	.SBTTL	Define order of loading segments

;This specifies all segments, msects, and psects and determines the order
;  in which they are placed in memory

;NOTE: As of 4.1.3 most of the segment/msect/psect names have been changed
;      to be more compatable with the names generated by the Watcom C
;      compiler.

;WARNING: The order of the loading of all segments is hard-coded in the
;	  oncereal module - this order cannot be changed unless oncereal
;	  is also modified

;Most XOS exec data is in this segment

	.SEG	x_DATA_rs  , DATA     , 16BIT
	.MSECT	x_DATA_rm  , x_DATA_rs, ADDR=0
	.SEG	x_DATA_s   , 32BIT    , SELECT=GS_XDATA, DATA, READ, WRITE
	.MSECT	x_DATA_m   , x_DATA_s , ADDR=database
	.PSECT	lowmem_p   , x_DATA_m , MOD=0x10 ;Low memory data
	.PSECT	x_DATA_p   , x_DATA_m , MOD=0x10 ;XOS data
databgn::
	.PSECT	x_BSS_p    , x_DATA_m , MOD=0x10
	.PSECT	xCONST_p   , x_DATA_m , MOD=0x10
	.PSECT	xCONST2_p  , x_DATA_m , MOD=0x10
	.PSECT	xCONSTZ_p  , x_DATA_m , MOD=0x10
knlsymbols::
	.PSECT	$$SYMBOLS_p, x_DATA_m, MOD=4
	.PSECT	$$TYPES_p  , x_DATA_m, MOD=4
	.PSECT	datatop_p  , x_DATA_m , MOD=0x10
datatop::!					;Highest used data address
	.PSECT	gdt_p      , x_DATA_m , MOD=0x10

;This segment contains the once-only data
.IF NE 0
	.SEG	o_DATA_rs  , DATA     , 16BIT
	.MSECT	o_DATA_rm  , o_DATA_rs, ADDR=0
	.SEG	o_DATA_s   , 32BIT    , SELECT=GS_XDATA, DATA, READ, WRITE
	.MSECT	o_DATA_m   , o_DATA_s , ADDR=oodatabase
	.PSECT	o_DATA_p   , o_DATA_m , MOD=0x10 ;XOS data
	.PSECT	oodatatop_p, o_DATA_m , MOD=0x10
oodatatop::!					;Highest used once-only data
						;  address (ram disk starts
						;  here)
.ENDC

;This segment contains the first page of the process spy area

	.SEG	pspy_rs, DATA   , 16BIT
	.MSECT	pspy_rm, pspy_rs, ADDR=0
	.SEG	pspy_s , 32BIT  , SELECT=GS_XDATA, DATA, READ, WRITE
	.MSECT	pspy_m , pspy_s , ADDR=procspy
	.PSECT	pspy_p , pspy_m , MOD=0x10
$$$=!$
	.MACRO	xname majv, minv, edit
	.ASCIZ	"XOS version majv'.'minv'.'edit"
	.ENDM
sysname::.RADIX 10
	 xname  >XOSMAJV, >XOSMINV, >XOSEDIT
	 .RADIX 16
$=$$$+0x1F
	.BYTE	0
	.PSECT	pspytop_p, pspy_m, MOD=0x10
procspytop::

;This segment contains the user mode virtual-86 code

	.SEG	vusercode_rs, CODE        , 16BIT
	.MSECT	vusercode_rm, vusercode_rs, ADDR=0
	.SEG	vusercode_s , 16BIT       , SELECT=GS_VUSERCODE, CODE
	.MSECT	vusercode_m , vusercode_s , ADDR=0
	.PSECT	vusercoded_p, vusercode_m , MOD=0x1000
	.PSECT	vusercode_p , vusercode_m , MOD=0x10
	.PSECT	vusercode_t , vusercode_m , MOD=0x1000
vusercodetop::!

;This segment contains the global protected mode user mode code

	.SEG	u_CODE_rs, CODE     , 16BIT
	.MSECT	u_CODE_rm, u_CODE_rs, ADDR=0
	.SEG	u_CODE_s , 32BIT    , SELECT=GS_UCODE, CODE
	.MSECT	u_CODE_m , u_CODE_s , ADDR=usercodebase
	.PSECT	u_CODE_p , u_CODE_m , MOD=0x10
	.PSECT	u_CODE_t , u_CODE_m , MOD=0x1000
usercodetop::!

;This segment contains the global protected mode user mode data

	.SEG	u_DATA_rs, CODE     , 16BIT
	.MSECT	u_DATA_rm, u_DATA_rs, ADDR=0
	.SEG	u_DATA_s , 32BIT    , SELECT=GS_UDATA, DATA, READ, WRITE
	.MSECT	u_DATA_m , u_DATA_s , ADDR=userdatabase
	.PSECT	u_DATA_p , u_DATA_m , MOD=0x10
	.PSECT	u_BSS_p  , u_DATA_m , MOD=0x10
	.PSECT	uCONST_p , u_DATA_m , MOD=0x10
	.PSECT	uCONST2_p, u_DATA_m , MOD=0x10
	.PSECT	uCONSTZ_p, u_DATA_m , MOD=0x10
userdatatop::!

;The GeckoT debugger code and data is in this segment

	.SEG	gt_DEBUG_rs, CODE       , 16BIT
	.MSECT	gt_DEBUG_rm, gt_DEBUG_rs, ADDR=0
	.SEG	gt_DEBUG_s , 32BIT      , SELECT=GS_XCODE, CODE
	.MSECT	gt_DEBUG_m , gt_DEBUG_s , ADDR=geckotbase
	.PSECT	gt_CODE_p  , gt_DEBUG_m , MOD=0x10 ;GeckoT code
	.PSECT	gt_DATA_p  , gt_DEBUG_m , MOD=0x10 ;GeckoT data
	.PSECT	gt_DEBUG_t , gt_DEBUG_m , MOD=0x10
geckottop::!

;The GeckoX debugger code and data is in this segment

	.SEG	gx_DEBUG_rs, CODE       , 16BIT
	.MSECT	gx_DEBUG_rm, gx_DEBUG_rs, ADDR=0
	.SEG	gx_DEBUG_s , 32BIT      , SELECT=GS_XCODE, CODE
	.MSECT	gx_DEBUG_m , gx_DEBUG_s , ADDR=geckoxbase
	.PSECT	gx_CODE_p  , gx_DEBUG_m , MOD=0x10 ;GeckoX code
	.PSECT	gx_DATA_p  , gx_DEBUG_m , MOD=0x10 ;GeckoX data
	.PSECT	_symbols_p , gx_DEBUG_m , OVER
	.PSECT	gx_DEBUG_t , gx_DEBUG_m , MOD=0x10
geckoxtop::!

;All XOS exec mode code is in this segment

	.SEG	x_CODE_rs, CODE     , 16BIT
	.MSECT	x_CODE_rm, x_CODE_rs, ADDR=0
	.SEG	x_CODE_s , 32BIT    , SELECT=GS_XCODE, CODE
	.MSECT	x_CODE_m , x_CODE_s , ADDR=codebase
	.PSECT	x_CODE_p , x_CODE_m , MOD=0x10

;;;;	.PSECT	codeexp_p, x_CODE_m , MOD=0x10
;;;;	.BLKB	0x1000			;Space for allocatable 16-bit code space

	.PSECT	code_u   , x_CODE_m , MOD=0x10
	.PSECT	code_t   , x_CODE_m , MOD=0x10
codetop::!

;This segment contains all once-only protected mode code (Note that this is
;  not really a separate segment since it has the same selector as the code
;  segment, but the bootstrap does not know how to load multiple msects, so
;  we fake it out this way!)

	.SEG	o_CODE_rs, CODE     , 16BIT
	.MSECT	o_CODE_rm, o_CODE_rs, ADDR=0
	.SEG	o_CODE_s , CODE     , 32BIT  , SELECT=GS_XCODE
	.MSECT	o_CODE_m , o_CODE_s , ADDR=oocodebase
	.PSECT	o_CODE_p , o_CODE_m , MOD=0x10
oncebgn::!
	.PSECT	o_DATA_p , o_CODE_m , MOD=0x10
	.PSECT	o_BSS_p  , o_CODE_m , MOD=0x10

	.PSECT	init_p   , o_CODE_m , MOD=0x10
doinit::!
	.PSECT	initend_p, o_CODE_m
	RET

	.PSECT	o_TBL_p   , o_CODE_m, MOD=4
inittbl::!
	.PSECT	x_TBL_p   , o_CODE_m	;This out of place psect name is needed
					;  to accomidate OW's inability to
					;  change the "data segment" prefix in
					;  in the code when specifying the init
					;  routine in the same file as a driver
	.PSECT	o_TBLEND_p, o_CODE_m
	.LONG	0

	.PSECT	o_CODE_t , o_CODE_m , MOD=0x10
oocodetop::!

;This segment contains the real mode once-only code

.IF NE $$GECKOB
	.SEG	gboot_s  , DATA, READ, WRITE, 16BIT
.ENDC
	.SEG	r_CODE_rs, COMB     , 16BIT, READ, WRITE
	.MSECT	r_CODE_rm, r_CODE_rs, ADDR=0
	.PSECT	r_CODE_rp, r_CODE_rm

;This segment gives the highest location loaded

	.SEG	top_rs, DATA  , 16BIT
	.MSECT	top_rm, top_rs, ADDR=0
.PAGE
	.PSECT	lowmem_p

knlRamAccess  == 0xE4750000	;Address space (1 page) for mapping physical
				;  memory

knlMemTable   == 0xF8000000	;Memory table (indexed by physical page number)
knlMemTableS10==!0xF8000000>10t
knlMemTableS20==!0xF8000000>20t
knlPgTable    == 0xFF800000	;Page table (mapped per process, indexed by
knlPgTableS20 ==!0xFF800000>20t

knlRamAccessPTE==!knlPgTable+{knlRamAccess>10t}




;Define items that are located in the system spy area

knlName     ==!procspy+sspy_sysname
knlProcMax  ==!procspy+sspy_procmax
knlProcLimit==!procspy+sspy_proclimit
knlProcInUse==!procspy+sspy_procinuse
knlProcHigh ==!procspy+sspy_prochigh
knlThrdMax  ==!procspy+sspy_thrdmax
knlThrdLimit==!procspy+sspy_thrdlimit
knlThrdInUse==!procspy+sspy_thrdinuse
knlThrdHigh ==!procspy+sspy_thrdhigh
knlMemAvail ==!procspy+sspy_memavail	;Number of pages currently available
knlMemTotal ==!procspy+sspy_memtotal	;Total number of pages in system
knlMemUser  ==!procspy+sspy_memuser	;Number of pages available to user
					;  programs
knlSysTtl   ==!procspy+sspy_systtl	;Total system up-time (system ticks)
knlClkTtl   ==!procspy+sspy_clkttl	;Total system up-time (clock ticks)
knlSchedTime==!procspy+sspy_schedtime	;Total scheduler time (clock ticks)
knlForkTime ==!procspy+sspy_forktime	;Total device fork time (clock ticks)
knlIdleCur  ==!procspy+sspy_idlecur	;Current idle (null process) count
knlIdleAve  ==!procspy+sspy_idleave	;Averaged idle (null process) count

;Define address in the high user memory (HUM) area

humPerThrd ==!humperthrd
humPTResvd ==!humperthrd+hpt_resvd	;Start of the reserved area
humPTTid   ==!humperthrd+hpt_tid	;TID
humPTLtn   ==!humperthrd+hpt_ltn	;Local thread number
humPTErrNo ==!humperthrd+hpt_errno	;errno
humArea    ==!humarea
humData    ==!humarea+hum_data
.PAGE
;Fixed location data - the absolute offsets of the following items are known
;  in various places in XOS - they CANNOT be changed - the first item
;  must be at offset = 0xE4000000!

	    .LONG 0		;(4) 0xE4000000 - GECKOX: Reserved
	    .LONG 0		;(4) 0xE4000004 - GECKOX: Reserved

knlGeckoSig::  .LONG 0, 0	;(4) 0xE4000008 - GECKOX: GECKO signature

knlGeckotDev:: .LONG 0		;(4) 0xE4000010 - GECKOT: Address of operational
				;                   register block for EHCI with
				;                   debug port
knlGeckotPort::.LONG 0		;(4) 0xE4000014 - GECKOT: Debug port number
	       .LONG 0		;(4) 0xE4000018 - GECKOT: Reserved
	       .LONG 0		;(4) 0xE400001C - GECKOT: Reserved

knlIDTable::.BLKB 256t*8	;The interrupt descriptor table

serialnum:: .LONG 1234h		;Kernel serial number
knlSysDescp::			;System description bits
	    .LONG SYSD$KBRESET


sysstate::  .LONG 0		;System state

cpubits0::  .LONG 0		;CPUID valid bits
cpubits1::  .LONG 0		;Bits returned in EDX for CPUID func 1
cpubits2::  .LONG 0		;BIts returned in ECX for CPUID func 1
cpubits3::  .LONG 0		;Bits returned in EDX for CPUID func 0x80000001
cpubits4::  .LONG 0		;Bits returned in ECX for CPUID func 0x80000001
cpulabel::  .BLKB 16t
cpudesc::   .BLKB 52t
cputype::   .BYTE 0		;Processor type
cpuven::    .BYTE 0
fputype::   .BYTE 0		;FPU type
fpustate::  .BYTE 0		;FPU state
knlCrashed::.BYTE 0		;Non-zero if system has crashed
	    .BLKB 3
lkecount::  .LONG 0		;Number of LKEs loaded (Does not include
				;  init-only LKEs.)
firstlke::  .LONG 0		;Offset of code for first LKE
lastlke::   .LONG 0		;Offset of code for last LKE
lkenumber:: .LONG 1		;Number for next LKE loaded (Also counts
				;  init-only LKEs so there may be gaps. This
				;  is used by GeckoT to manage it's symbol
				;  table.)
knlConDhb:: .LONG 0		;Offset of DHB for console
knlDispType::
	    .LONG 0		;Console display type
knlDispMode::
	    .LONG 0		;Current consol display mode
knlMachType::
	    .LONG 0		;Machine type code
knlBootID:: .LONG 0		;Boot disk ID
country::   .LONG 1		;Default country code for system
almlimit::  .LONG 16t		;Per-process alarm limit
knlFirstCcb::
	    .LONG 0		;Offset of first CCB
numccb::    .LONG 0		;Number of CCBs

cnmser::    .LONG 0		;Number of serial ports
cnmpar::    .LONG 0		;Number of parallel ports
knlver::    .LONG {XOSMAJV<24t}|{XOSMINV<16t}|XOSEDIT
				;XOS version number
dosver::    .LONG {DOSMAJV<24t}|{DOSMINV<16t}
				;DOS emulator version number memory

gdtval::    .WORD 0x0FFF
	    .LONG gdtable
idtval::    .WORD 0x07FF
	    .LONG knlIDTable

gselnum::   .LONG 0		;Number of global selectors created
gselinuse:: .LONG 0		;Number of global selectors in use

firstcab::  .LONG 0		;Offset of first close action block
procseq::   .LONG 1		;Current process sequence number
thrdseq::   .LONG 1		;Current thread sequence number
knlForkLvl::.LONG 0		;Fork level flag (this is a long so we can PUSH
				;  and POP the value)
lkebusy::   .BYTE 0		;LKE loading busy flag (1 = busy)
flopswap::  .BYTE 0		;Floppy unit swap flag (80 = units 0 and 1 are
				;  swapped)
cadelflg::  .BYTE 1		;CTRL-ALT-DEL flag
intmulbug:: .BYTE 0		;Non-zero if have 386 integer multiply bug
fpudivbug:: .BYTE 0		;Non-zero if have Pentium FPU divide bug
	    .BYTE 0, 0, 0
fileseqnum::.LONG 0, 0		;Current file sequence number
knlCpsPda:: .LONG 0		;Selector for process to interrupt with ^P
				;  terminal signal
lkelevel::  .LONG {LKEMAJC<<16t}|LKEMINC
				;LKE compatability level

;IRQ name table

;;;intnames::  .LONG 'SYST', 'EM_C', 'LOCK', 0	;Name for IRQ0
;;;	    .LONG 0     , 0     , 0     , 0	;Name for IRQ1
;;;	    .LONG 'SYST', 'EM_C', 'asca', 'de'	;Name for IRQ2
	    .LONG 0     , 0     , 0     , 0	;Name for IRQ3
	    .LONG 0     , 0     , 0     , 0	;Name for IRQ4
	    .LONG 0     , 0     , 0     , 0	;Name for IRQ5
	    .LONG 0     , 0     , 0     , 0	;Name for IRQ6
	    .LONG 0     , 0     , 0     , 0	;Name for IRQ7
	    .LONG 'SYST', 'EM_R', 'TC'  , 0	;Name for IRQ8
	    .LONG 0     , 0     , 0     , 0	;Name for IRQ9
	    .LONG 0     , 0     , 0     , 0	;Name for IRQ10
	    .LONG 0     , 0     , 0     , 0	;Name for IRQ11
	    .LONG 0     , 0     , 0     , 0	;Name for IRQ12
	    .LONG 'SYST', 'EM_F', 'PU'  , 0	;Name for IRQ13
	    .LONG 0     , 0     , 0     , 0	;Name for IRQ14
	    .LONG 0     , 0     , 0     , 0	;Name for IRQ15

;;;knlDskCcb::  .LONG 0		;Offset of DISK class CCB
knlHdkDataC::.LONG 0, 0, 0, 0	;Data for first hard disk (D0:)
knlHdkDataD::.LONG 0, 0, 0, 0	;Data for second hard disk (D1:)
knlPort61::  .BYTE 0		;Value to output to port 61

	    .MOD  4
knlSysGroup:: .ASCII 'USR'	;Default group name for system
	      .BLKB  13t
knlSysUser::  .ASCII 'USER'	;Default user name for system
	      .BLKB  12t

disprom::     .LONG 0		;Physical address of display ROM

knlFont8x8L:: .LONG 0		;Offset of ROM 8x8 low font (basic)
knlFont8x8H:: .LONG 0		;Offset of ROM 8x8 high font (basic)
knlFont8x14L::.LONG 0		;Offset of ROM 8x14 low font (basic)
knlFont8x14H::.LONG 0		;Offset of ROM 8x14 high font (basic)
knlFont8x16L::.LONG 0		;Offset of ROM 8x16 low font (basic)
knlFont8x16H::.LONG 0		;Offset of ROM 8x16 high font (basic)
knlFont9x8F:: .LONG 0		;Offset of ROM 9x8 font (fixup)
knlFont9x14F::.LONG 0		;Offset of ROM 9x14 font (fixup)
knlFont9x16F::.LONG 0		;Offset of ROM 9x16 font (fixup)

serialchk:: .LONG 0CBEDFFFFh

dosfcbn::   .BYTE 16t		;Size of the DOS FCB table
dosfcbp::   .BYTE 8t		;Number of protected entires in the DOS FCB
				;  table

knlJunk1::  .LONG 0, 0, 0

oncemax::   .LONG 0

;Vectors to extension routines

knxLogGiveAllPaths::
	    .LONG nullfunc#
knxPciFindVendor::
	    .LONG knlNotIns#
knxPciFindType::
	    .LONG knlNotIns#
knxPciReadConfig::
	    .LONG knlNotIns#
knxPciWriteConfig::
	    .LONG knlNotIns#
knxSpdSetActive::
	    .LONG nullfunc#
knxSpdSetIdle::
	    .LONG nullfunc#
knlCurSpeed::
	    .LONG 0
knlIsNull:: .LONG 0		;Non-zero if null process is running

oordsz::    .LONG 0		;Size of the once-only ram-disk
.PAGE
;Other data which can be at any location

	DATA

lit0::	   .LONG 0		;Commonly used literal values
lit3::	   .LONG 3t
lit4::	   .LONG 4t
lit5::	   .LONG 5t
lit6::	   .LONG 6t
lit7::	   .LONG 7t
knlLit10:: .LONG 10t
knlLit11:: .LONG 11t
lit12::	   .LONG 12t
lit14::	   .LONG 14t
lit16::	   .LONG 16t
lit20::	   .LONG 20t
lit30::	   .LONG 30t
lit31::	   .LONG 31t
lit60::	   .LONG 60t
lit80::	   .LONG 80t
lit100::   .LONG 100t
knlLit128::.LONG 128t
lit240::   .LONG 240t
knlLit256::.LONG 256t
lit365::   .LONG 365t
lit366::   .LONG 366t
lit400::   .LONG 400t
knlLit512::.LONG 512t
lit768::   .LONG 768t
lit1000::  .LONG 1000t
lit1024::  .LONG 1024t
lit1461::  .LONG 1461t
knlLit10000::
	   .LONG 10000t
knlLit16000::
	   .LONG 16000t
lit36524:: .LONG 36524t
lit60000:: .LONG 60000t
;lit36525::.LONG 36525t
lit86400:: .LONG 86400t		;Seconds per day
lit146097::.LONG 146097t
lit200000::.LONG 200000t
lit864000::.LONG 864000t	;Tenth seconds per day
lit3600000::
	   .LONG 3600000t
lit20000000::
	   .LONG 20000000t
lit3600000000::
           .LONG 3600000000t
litCCPERSP::
           .LONG CCPERSP
knlLitTICKPERSEC::
           .LONG TICKPERSEC
knlLitTICKPERSP::
           .LONG TICKPERSP
knlLitSPPERDAY::
           .LONG SPPERDAY
litDTPERDAY::
           .LONG DTPERDAY
knlLitSPPERSEC::
           .LONG SPPERSEC
knlLitMSPERSP::			;Milliseconds per scheduler period
	   .LONG MSPERSP
lit31B5D43B::
	   .LONG 31B5D43Bh
lit5D34553A::
	   .LONG 5D34553Ah
knlLitTICKPERDAY::
	   .LONG TICKPERDAY_LO
	   .LONG TICKPERDAY_HI

knlConDhdb::			;DHDB for the console display
	   .LONG  'DHDB'
	   .BLKB  dhdb_dispname-4
	   .ASCII "Standard VGA"
	   .BLKB  dhdb_SIZE-dhdb_dispname-12t
dhdbend::
.PAGE
	.SBTTL	Global segment descriptor table (GDT)

;The initial contents of each GDT entry is out of order.  This allows the
;  address in a call gate to be stored normally here.  The items are reordered
;  by the code in oncer before entering protected mode!

;Define macro for specifing general GDT entry

	.MACRO	GDTENT  type, class, size, addr
	.LONG	{type<24t}+{class<16t}+size
	.LONG	addr
	.ENDM

;Create the GDT

	.PSECT	gdt_p

xgdtable::

;0000 - Not used
	.LONG	0, 0

;0008 - Not used
	.LONG	0, 0

;0010 - Not used
	.LONG	0, 0

;GS_UCODE = 0x0018 - User code segment
	GDTENT	DT_NXRCODE+PL_3, DC_PG+DC_32, 0xFFFFF, 0

;GS_UDATA = 0x0020 - User data segment
	GDTENT	DT_RWDATA+PL_3, DC_PG+DC_32, 0xFFFFF, 0

;GS_XCODE = 0x0028 - Exec data segment
	GDTENT	DT_NXRCODE+PL_0, DC_PG+DC_32, 0xFFFFF, 0

;GS_XDATA = 0x0030 - Exec code segment
	GDTENT	DT_RWDATA+PL_0, DC_PG+DC_32, 0xFFFFF, 0

;0038 - Not used
	.LONG	0, 0

;GS_BIOSDATA = 0040 - Maps DOS environment BIOS data
	GDTENT	DT_RWDATA+PL_3, DC_BG+DC_16, 0x0FFFF, 0x400

;GS_CODER16 = 0048 - 16-bit 64K code segment
	GDTENT	DT_NXRCODE+PL_0, DC_BG+DC_16, 0x0FFFF, 0

;GS_DATAR16 = 0050 - 16-bit 64K data segment
	GDTENT	DT_RWDATA+PL_0, DC_BG+DC_16, 0x0FFFF, 0

;0058 - Not used
	.LONG	0, 0
 
;GS_STKERRTSS = 0060 - Stack error handler TSS
	GDTENT	DT_ITSS+PL_0, DC_BG, 0x68-1, stkerrtss#

;GS_DBLERRTSS = 0068 - Double exception error handler TSS
	GDTENT	DT_ITSS+PL_0, DC_BG, 0x68-1, dblerrtss#

;GS_NULLTSS = 0070 - Null process TSS selector
	GDTENT	DT_ITSS+PL_0, DC_BG, 0x68-1, tdabase+tdaTss#

;0078 - Not used
	.LONG	0, 0

XGDTSIZE==!$-xgdtable

	END
