	.TITLE	screen - Screen symbiont SVCs

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

	.PROC	80486
	.INCLUD	xosinc:\xmac\xos.par
	.INCLUD	xosinc:\xmac\xosx.par
	.INCLUD	xosinc:\xmac\xoserr.par
	.INCLUD	xosinc:\xmac\xostrm.par
	.INCLUD	xosinc:\xmac\xosxtrm.par

	CODE

	.SBTTL	svcScnTrans - SVC to transfer data for screen symbiont

;Here for the svcScnTrans SVC - Transfer data for screen
;	long rtn = svcScnTrns(
;	  long  exectdb,	// Exec address of terminal TDB
;	  long  func,		// Function bits
;	  long  firstpg,	// First page to transfer
;	  long  numpgs,		// Number of pages to transfer
;	  long *pglist,		// Address of page list array
;	  char *pgbufr);	// Address of page buffer
;  Value returned is raw hardware cursor position (read functions) or 0 (write
;    function) if normal or a negative error code if error

psvcScnTrans::
	MOVL	ESI, knlTda+tdaArg1#	;Get address of TDB for terminal
	MOVL	EDX, knlTda+tdaArg2#	;Get function bits
	MOVL	EAX, knlTda+tdaArg3#	;Get first page
	MOVL	ECX, knlTda+tdaArg4#	;Get number of pages
	MOVL	EDI, knlTda+tdaArg5#	;Get address of page list
	MOVL	EBX, knlTda+tdaArg6#	;Get address of buffer
	MOVL	EBP, tdb_ddisp[ESI]	;Dispatch to terminal routine
	JMPIL	tfx_sstrans[EBP]
.PAGE
	.SBTTL	svcScnMapBufr - SVC to map physical screen buffer for screen symbiont

;Here for the svcScnMapBufr SVC - Map physical screen buffer for screen symbiont
;	long svcScnMapBufr(
;	    long  exectdb,	// Exec address of terminal TDB
;	    char *buffer,	// Address of buffer
;	    long  size);	// Maximum size for buffer
;  Value returned is size of buffer mapped if normal or negative error code
;    if error

psvcScnMapBufr::
	MOVL	ESI, knlTda+tdaArg1#	;Get address of TDB for terminal
	MOVL	EDX, knlTda+tdaArg2#	;Get address of buffer
	MOVL	ECX, knlTda+tdaArg3#	;Get maximum size
	MOVL	EAX, tdb_ddisp[ESI]	;Dispatch to terminal routine
	JMPIL	tfx_ssmapbufr[EAX]
.PAGE
	.SBTTL	svcScnMaskWrt - SVC to write screen buffer with masking for screen symbiont

;Here for the svcScnWrite SVC - Write screen buffer with masking for screen
;  symbiont
;	long rtn = svcScnMaskWrt(
;	    long  exectdb,	// Exec address of terminal TDB
;	    long  firstpg,	// First page to write
;	    long  numpgs,	// Number of pages to write
;	    long  width,	// Width of menu (characters)
;	    long  height,	// Height of menu (rows)
;	    long  offset, 	// Offset in buffer for first visible character
;	    char *pgbufr);	// Address of page buffer
;  Value returned is 0 if nothing was written, 1 if something was written, or
;    a negative error code if error

psvcScnMaskWrt::
	MOVL	ESI, knlTda+tdaArg1#	;Get address of TDB for terminal
	MOVL	EAX, knlTda+tdaArg2#	;Get first page
	MOVL	ECX, knlTda+tdaArg3#	;Get number of pages
	MOVL	EBX, knlTda+tdaArg5#	;Get menu height
	SHLL	EBX, #16t
	MOVW	BX, knlTda+tdaArg4#	;Get menu width
	MOVL	EDX, knlTda+tdaArg6#	;Get offset of first character
	MOVL	EDI, knlTda+tdaArg7#	;Get address of buffer
	MOVL	EBP, tdb_ddisp[ESI]	;Dispatch to terminal routine
	JMPIL	tfx_ssmaskwrt[EBP]
.PAGE
	.SBTTL	svcScnUtil - General utility SVC for screen symbiont

;Here for the svcScnUtil SVC - General utility SVC for the screen symbiont
;	long rtn = svcScnUtil(
;	  long exectdb,		// Exec address of terminal TDB or handle
;				//   (handle if < 0x10000)
;	  long data);		// Data value:
;				//   -1 = Remove cursor from physical screen
;				//    0 = Wake up thread using TDB address / 64
;				//          + 1 as wait index
;				//   >0 = Wake up extended fork frame with this
;				//	    selector ?????
;  If handle given, value returned is the exec address of the TDB / 4,
;     otherwise value returned is 0 if normal or a negative error code
;     if error.

psvcScnUtil::
	MOVL	ESI, knlTda+tdaArg1#	;Get handle or address of TDB
	CMPL	ESI, #0x10000		;Handle given?
	JA	6$			;No
	CALL	sysTrmGetDcb#		;Yes - get DCB and TDB
	TESTL	EAX, EAX
	JS	4$
	MOVL	EAX, knlTda+tdaAdb#	;Return address of the TDB / 4
	SHRL	EAX, #2
4$:	RET

6$:	MOVL	EDX, knlTda+tdaArg2#	;Get data value
	MOVL	EBP, tdb_ddisp[ESI]	;Dispatch to terminal routine
	JMPIL	tfx_ssutil[EBP]
.PAGE
	.SBTTL	svcScnInsertChr - SVC for screen symbiont to write to input buffer

;Here for the svcScnInsertChr SVC - Write to terminal's input buffer
;	long rtn = svcScnInsertChr(
;	  long exectdb,		// Exec address of terminal TDB
;	  long chr);		// Character value (internal scan code)
;  
;  Value returned is 1 if the character was stored or 0 if the character
;    was not stored because the terminal is in text mode or a negative
;    error code if error

;  This call is intended to be used by the screen symbiont to send a
;    character to a graphic mode program to indicate that its screen has
;    just become the current screen. It also servers as the check that the
;    terminal is in a graphic mode.

psvcScnInsertChr::
	MOVL	ESI, knlTda+tdaArg1#	;Get offset of TDB for terminal
	CMPB	tdb_mode[ESI], #DM_TEXT	;In a graphic mode?
	JLE	10$			;No - do nothing
	TOFORK				;Yes
	PUSHL	ESI
	PUSHL	knlTda+tdaArg2#		;Get character
	CALL	sysTrmInput#
	FROMFORK
	MOVL	EAX, #1			;Return 1
	CLC
	RET

10$:	CLRL	EAX			;Return 0
	RET

	END
