	.TITLE	xfpcls - XFP routines for XOS

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

	.PROC	80486
	.INCLUD	XOSINC:\XMAC\XOS.PAR
	.INCLUD	XOSINC:\XMAC\XOSX.PAR
	.INCLUD	XOSINC:\XMAC\XOSTIME.PAR
	.INCLUD	XOSINC:\XMAC\XOSERR.PAR
	.INCLUD	XOSINC:\XMAC\XOSNET.PAR
	.INCLUD	XOSINC:\XMAC\XOSXNET.PAR
	.INCLUD	XOSINC:\XMAC\XOSXIPS.PAR
	.INCLUD	XOSINC:\XMAC\XOSXTCP.PAR
	.INCLUD	XOSINC:\XMAC\XOSXXFP.PAR
	.INCLUD	XOSINC:\XMAC\XOSLKE.PAR
	.INCLUD	XOSINC:\XMAC\XOSXLKE.PAR

MAJV   =!2t
MINV   =!0t
EDITNUM=!0t

	LKEHEAD	XFPCLS, MAJV, MINV, EDITNUM, LKETYPE_CLASS

FOBITS=!FO$NODENUM|FO$NODENAME|FO$RXOSNAME|FO$RDOSNAME|FO$RVOLNAME
FOBITS=!FOBITS|FO$PATHNAME|FO$PATHDOS|FO$FILENAME|FO$FILEDOS|FO$ATTR|FO$VERSION

SNDSIZE=!0x600

$$$=0
FRM opx_frame1  , 4t
FRM opx_frame2  , 4t
FRM opx_newname , 4t		;Offset of new name string for rename
FRM opx_newnsz  , 4t		;Size of new name string for rename
FRM opx_rspsz   , 4t		;Response size
FRM opx_datasz  , 4t		;Size of data or name
FRM opx_parmsz  , 4t		;Size of parameter list
FRM opx_msgsz   , 4t		;Total message size
FRM opx_msgtype , 1t		;Message type
FRM opx_respbits, 1t
FRM             , 2t
FRM opx_error   , 4t		;Error code
FRM opx_parmerr1, 4t		;Parameter error bits
FRM opx_parmerr2, 4t
FRM opx_devsts  , 4t
FRM opx_unitnum , 4t
FRM opx_filattr , 4t
FRM opx_glbid   , 16t
FRM opx_amount  , 4t
FRM opx_parm    , 4t
FRM opx_srverror, 4t
FRM opx_respdata, 4t
FRM opx_respttl , 4t
FRM opx_sndbufr , SNDSIZE
opx_SIZE=!$$$-8

	CODE

	.SBTTL	SVC dispatch table for XFP devices

;SVC dispatch table for XFP devices

xfpdsp:	.LONG	knlRtnZero##	;sd_mount     =  0 - Mount
	.LONG	xfpgivedcb	;sd_cleardcb  =  4 - Clear DCB
	.LONG	knlNullQio##	;sd_opena     =  8 - Open additional
	.LONG	xfpopen		;sd_open1     = 12 - Open device/file
	.LONG	xfpdevparm	;sd_devparm   = 16 - Device parameters
	.LONG	xfpdelete	;sd_delete    = 20 - Delete file
	.LONG	xfprename	;sd_rename    = 24 - Rename file
	.LONG	xfpinpblk	;sd_inblock   = 28 - Input block
	.LONG	xfpoutblk	;sd_outblock  = 32 - Output block
	.LONG	xfpoutstr	;sd_outstring = 36 - Output string
	.LONG	knlRtnMOne##	;sd_getiosts  = 40 - Get input/output status
	.LONG	knlIFnDevTF##	;sd_special   = 44 - Special device function
	.LONG	xfpclose	;sd_close     = 48 - Close file
	.LONG	knlNullLabel##	;sd_label     = 52 - Get device label
	.LONG	xfpcommit	;sd_commit    = 56 - Commit data to disk
	.LONG	xostcpDevInfo##	;sd_devinfo   = 60 - Get device info
XFPDSPSZ=!{$-xfpdsp}/4

;Class function dispatch table for XFP class devices

	.LONG	XFPCLSFMX
xfpcls::.LONG	xfpaddunit	;CF_ADDUNIT = 1 - Add unit
	.LONG	xfpunitinfo	;CF_PUNITS  = 2 - Get information about
				;                   physical units
	.LONG	knlIFnDev##	;CF_AUNITS  = 3 - Get information about active
				;                   units
XFPCLSFMX=!{$-xfpcls}/4
.PAGE
;Device characteristics tables for the XFP devices

	DATA

	.MOD	4
xfpdctbl:
 DCHARBGN  1, knlDCharValCom##
 DCHARENT  CLASS  , TEXT, ,  8, knlDcMsgClass##  , knlDcGetClass##    , knlDcSetClass##    , 0
 DCHARENT  TCPDEV , TEXT, , 16, xostcpMsgTcpDev##, xostcpGetTcpDev##  , 0                  , 0
 DCHARENT  RETRY1 , DECV, ,  1, xosipsMsgRetry1##, xosipsGetDpdbByte##, xosipsSetDpdbByte##, dpdb_tcpxfpretry1
 DCHARENT  RETRY2 , DECV, ,  1, xosipsMsgRetry2##, xosipsGetDpdbByte##, xosipsSetDpdbByte##, dpdb_tcpxfpretry2
 DCHARENT  RMTPORT, DECV, ,  4, msgrmtport       , xosipsGetDpdbData##, xosipsSetDpdbData##, dpdb_rmtport
 DCHARENT  MSGIN  , DECV, ,  4, msgmsgin         , xosipsGetDpdbData##, xosipsSetDpdbData##, dpdb_tcpxfpcntmsgin
 DCHARENT  BYTEIN , DECV, ,  4, knlDcMsgByteIn## , xosipsGetDpdbData##, xosipsSetDpdbData##, dpdb_tcpxfpcntbytein
 DCHARENT  MSGOUT , DECV, ,  4, msgmsgout        , xosipsGetDpdbData##, xosipsSetDpdbData##, dpdb_tcpxfpcntmsgout
 DCHARENT  BYTEOUT, DECV, ,  4, knlDcMsgByteOut##, xosipsGetDpdbData##, xosipsSetDpdbData##, dpdb_tcpxfpcntbyteout
 DCHARENT  PROERR , DECV, ,  4, msgproerr        , xosipsGetDpdbData##, xosipsSetDpdbData##, dpdb_tcpxfpcntproerr

	CODE

msgrmtport:DCHARINFO  {Remote (server) port}
msgmsgin:  DCHARINFO  {Number of messages input}
msgmsgout: DCHARINFO  {Number of messages output}
msgproerr: DCHARINFO  {Protocol errors}
.PAGE
	.SBTTL	xfpinit - Initialization routine for XFP class devices

	INITSUB	xfpinit

;The command for installing XFPCLS is:
;	LKELOAD XFPCLS

xfpinit:MOVL	EDI, #xfpchk		;Install the XFP class
	MOVL	EBX, #xfpcls		;Offset of class function dispatch table
	CLRL	ECX
	MOVL	EAX, #'XFP'
	CLRL	EDX
	MOVL	ESI, #xfpccb
	CALL	knlNewClass##
	JC	10$.S
	MOVL	ECX, #codetop
	CLRL	EDX
	CLRL	EAX
10$:	MOVL	EBX, #QSTS$DONE
	RET

	CODE
.PAGE
	.SBTTL	xfpaddunit - Subroutine to add XFP "unit"

;Subroutine to add XFP "unit" - this is a logical unit which implements the
;  XFP application level protocol for a single transport level (TCP) unit
;  - multiple XFP units may be set up for different TCP units if desired
;	c{ES:EDI} = Address of data block
;	CALL	xfpaddunit
;	c{EAX} = Error code
;	c{EBX} = Status bits
;	c{ECX} = Item count

$$$=!0
FRM xfpau_tpdb, 4t	;Offset of TCP TPDB
FRM xfpau_unit, 4t	;Unit number
FRM xfpau_pdb , 4t	;Offset of PDB
xfpau_SIZE=!$$$

	DATA

	.MOD	4
xfpaublk:				;Parameter description block for
 DCHARBGN  2, knlDCharValCom##		;  adduparms
 DCHARENT  UNIT  , DECV, ,  1, 0, 0, xfpauunit, 0
 DCHARENT  TCPDEV, TEXT, , 16, 0, 0, xfpaudev , 0

	CODE

xfpaddunit:
	ENTER	xfpau_SIZE, 0		;Allocate our stack frame
	CLRL	EAX
	MOVL	xfpau_tpdb[EBP], EAX	;Store illegal values for TCP TPDB
	DECL	EAX			;  and unit number
	MOVL	xfpau_unit[EBP], EAX
	IFFAULT	4$
	LFSL	EDX, iorb_buffer2[ESI]
	MOVL	EBX, #xfpaublk		;Process the characteristics
	MOVB	AL, #0			;Fail on bad names
	CALL	knlAddUnitChar##
	JC	2$			;If error
	MOVL	EAX, xfpau_tpdb[EBP]	;Make sure TCP device and unit number
	DECL	EAX			;  are specified
	ORL	EAX, xfpau_unit[EBP]
	INCL	EAX
	JNE	6$
	MOVL	EAX, #ER_CHARM
2$:	MOVL	EBX, #QSTS$DONE
	CLRL	ECX
	LEAVE
	TOFORK
	RET
		
;Here if address error

4$:	MOVL	EAX, #ER_ADRER
	JMP	2$

;Here if have all required characteristics

6$:	PUSHL	xfpau_unit[EBP]		;Stack unit number
	PUSHL	#dpdb_tcpxfpSIZE	;Stack DPDB size
	PUSHL	#'XFP'			;Stack base name
	PUSHL	#dcb_xfpINDEX		;Stack size index for DCB
	PUSHL	#xfpccb			;Stack offset of the XFP CCB
	PUSHL	xfpau_tpdb[EBP]		;Stack offset of first TCP TPDB
	PUSHL	#xfpdpdbhead		;Stack offset of XFP DPDB head pointer
	CALL	xosipsMakeDev##		;Create new network device
	JC	2$.S			;If error
	CALL	knlGiveXRes##		;Give up the exec memory resource
	MOVL	dpdb_rmtport[EDI], #TCPP_XFP ;Store default remote port
	MOVB	dpdb_tcpxfpretry1[EDI], #RETRY_TRN1 ;Initialize default retry
	MOVB	dpdb_tcpxfpretry2[EDI], #RETRY_TRN2 ;  levels
	CLRL	EAX
	JMP	2$.S
.PAGE
;Subroutine called by adduparms for the "UNIT" parameter

xfpauunit:
	CMPL	EAX, #100t		;Valid value?
	JAE	knlBadParmV##
	MOVL	xfpau_unit[EBP], EAX
	CLC
	RET

;Subroutine called by adduparms for the "DEV" parameter

xfpaudev:
	MOVL	EAX, xfpau_tpdb[EBP]	;Get current TCP TPDB offset
	CALL	xostcpAuTcpDev##	;Get TCP TPDB offset
	JC	2$.S			;If error
	MOVL	xfpau_tpdb[EBP], EDI	;OK - store TCP TPDB offset
2$:	RET
.PAGE
	.SBTTL	xfpunitinfo - XFP class get phyical unit information function

;Here for the get physical unit information class function (CL_PUNITS) for the
;  XFP class
;	c{EBX} = Offset of CCB
;	c{ESI} = Offset of IORB
;	CALL	xfpunitinfo
;	c{EAX} = Error code
;	c{EBX} = Status bits
;	c{ECX} = Item count
;  A zero count (iorb_count) requests that the number of units only be returned
;    in qab_amount.  A non-zero count indicates that a buffer is available for
;    that many unit names (8 characters each, null padded).

xfpunitinfo:
	CRASH	NIYT
.PAGE
	.SBTTL	xfpchk - Device check routine for XFP class devices

;Device check routine for XFP class devices
;	c{SS:EBX} = Address of device name (16 characters)
;	CALL	xfpchk
;	C:set = Error (match found)
;	  c{EAX} = Error code
;	C:clr = Normal
;	  Z:set = Match found
;	    c{EDI} = Offset of DCB
;	  Z:clr = Not found
;  ESI is preserved

xfpchk:	MOVL	EAX, SS:[EBX]
	ANDL	EAX, #0FFFFFFh
	CMPL	EAX, #'XFP'		;Is this XFP*?
	JNE	28$			;No

;Here if this may be an XFP device - First check to see if there is a matching
;  held device

	PUSHL	EBX
	BTL	SS:xffHvValue1##, #IOV1%RMTNETAS ;Have an address parameter?
	JNC	4$			;No	
	MOVL	EDX, opn_rmtnetas[EBP]	;Yes
	JMP	6$			;Continue

;Here if no network address parameter was specified

4$:	LEAL	EDX, opn_namebfr[EBP]	;Was a network address given in the
	CALL	xosnetChkNetAddr##	;  name?
	JNE	newdcb			;No - go on
	LEAL	EBX, opn_namebfr[EBP]	;Yes
	PUSHL	SS
	POPL	ES
	MOVB	AL, #':'
	CALL	xosipsParseAddress##	;Parse the network address
	JC	newdcb			;If error
	MOVL	opn_rmtnetas[EBP], EDX
	BTSL	SS:xffHvValue1##, #IOV1%RMTNETAS

;Here with the remote address and port number - now we can search for a
;   matching held DCB

6$:	MOVW	ES, SS:xffPda##
	MOVZWL	ECX, ES:pdaSesProc##
	MOVW	ES, knlProcTable##[ECX*2]
	MOVL	EDX, #pdaHdlbList##
	POPL	EBX
	PUSHL	ESI
8$:	MOVL	ESI, ES:[EDX]
	TESTL	ESI, ESI
	JE	14$
	MOVL	EDI, hdlb_dcb[ESI]	;Get held DCB
	MOVL	EAX, dcb_name+0[EDI]	;Compare the device name
	CMPL	EAX, SS:[EBX]
	JNE	10$.S
	MOVL	EAX, dcb_name+4[EDI]
	CMPL	EAX, SS:4[EBX]
	JNE	10$.S
	MOVL	EAX, dcb_ipsrmtaddr[EDI] ;Same name - compare network address
	CMPL	EAX, opn_rmtnetas[EBP]
	JE	12$			;Same use this DCB

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;	MOVW	CX, dcb_ipsrmtport[EDI] ;We really should check this too
;;;	CMPW	CX, opn_rmtports[EBP]
;;;	JE	12$

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

10$:	LEAL	EDX, hdlb_nextp[ESI]	;Advance to next held DCB
	PUSHL	DS
	POPL	ES
	JMP	8$

;Here with a held DCB we can use

12$:	MOVL	EBX, EDX
	CALL	knlUnholdDevProc##	;Unhold the device
	POPL	ESI
	CLRL	EAX			;Set Z
	RET

;Here at end of the held DCB list - we didn't find one we can use

14$:	POPL	ESI
	JMP	16$

;Here if we need to create a new DCB

newdcb:	POPL	EBX
16$:	MOVL	EDI, xfpdpdbhead	;Yes - get offset of first XFP DPDB
	LEAL	ECX, 3[EBX]		;Get offset of 1st unit number character
	MOVL	EDX, #DS$SODIR|DS$FILE
	CALL	xosipsFindDev##		;Find matching network device
	JC	26$			;If error
	JNE	26$			;Or if not a match
	MOVL	ECX, #6			;Get a 4K output ring buffer (for now)
	CALL	knlGetXmb##
	JC	26$			;If error
	MOVL	dcb_tcpoutbufr[EDI], ESI
	MOVL	dcb_tcpoutsize[EDI], #1000h-4
	MOVL	dcb_tcpoutpush[EDI], #-1
	MOVL	dcb_sdisp[EDI], #xfpdsp ;Store offset of SVC dispatch table
	MOVL	dcb_tcpfuncdisp[EDI], #xostcpFncDisp## ;Store offset of func
	MOVL	EDX, dcb_ipsdpdb[EDI]		       ;  dispatch table
	MOVW	AX, dpdb_tcpxfpretry1[EDX] ;Store default retransmission
	MOVW	dcb_tcpretry1[EDI], AX	   ;  threshold values
	MOVL	dcb_netmode[EDI], #0	;Set default modes
	MOVL	dcb_devchar[EDI], #xfpdctbl ;Use our device characteristics
	MOVB	dcb_ipsprot[EDI], #IPP_TCP ;Store protocol value
	MOVL	ECX, dcb_netpdb[EDI]
	MOVL	EAX, pdb_ipmaxpktsz[ECX] ;Get the maximum we can use
22$:	SUBL	EAX, #20t		;Allow space for the TCP header

	CMPL	EAX, #2000t
	JB	23$
	INT3
23$:

	MOVL	dcb_tcpoutmaxsg[EDI], EAX
	MOVL	dcb_tcpoutpkt+npb_nextsnd[EDI], #-1
	MOVL	dcb_tcpoutpkt+npb_dcb[EDI], EDI
	MOVL	EDX, dpdb_tpdb[EDX]
	MOVL	ECX, tpdb_tcpnextport[EDX] ;Assign default port number
	BTSL	ECX, #31t
	INCL	tpdb_tcpnextport[EDX]
	CMPL	tpdb_tcpnextport[EDX], #0FF00h
	JB	24$
	MOVL	tpdb_tcpnextport[EDX], #0A000h
24$:	CALL	xosipsGetPort##
	JC	30$
	MOVL	EAX, dcb_ipsdpdb[EDI]	;Store remote port number
	MOVL	EAX, dpdb_rmtport[EAX]	
	XCHGB	AL, AH
	MOVW	dcb_ipsrmtport[EDI], AX
	CLRL	EAX			;Set Z
26$:	RET				;And return

28$:	CLC
	RET

;Here if can't allocate the default port number

30$:	PUSHL	EAX
	CALL	xosnetGiveDcb##
	POPL	EAX
	STC
	RET
.PAGE
	.SBTTL	sd_devparm - Device parameter function

;Here for the device parameter function entry
;	c{SS:EDX} = Offset of name buffer
;	c{EDI}    = Offset of DCB
;	CALL	xfpdevparm
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

xfpdevparm:
	MOVB	AL, #XFPCF_PARM
	JMP	4$

2$:	ANDB	SS:xffCmd##, #~{O$IN|O$OUT} ;No IO allowed
	MOVL	ECX, #1
	CLRL	EAX
	RET

	.SBTTL	sd_open - Open device

;Here for the open device entry
;	c{SS:EDX} = Offset of name buffer
;	c{EDI}    = Offset of DCB
;	CALL	xfpopen
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

xfpopen:MOVB	AL, #XFPCF_OPEN
4$:	TESTL	SS:xffCmd##, #O$PHYS|O$RAW ;Raw or physical IO?
	JE	open2			;No
	CMPB	SS:[EDX], #0		;Yes - have any file spec?
	JE	2$			;No - make this a local open
open2:	MOVB	SS:xffQueue##, #dcb_outframe ;Yes - set up output queue
	MOVW	dcb_outframe[EDI], SS
	MOVW	dcb_inpframe[EDI], #0
	ENTER	opx_SIZE, 2
	MOVB	opx_msgtype[EBP], AL
	MOVL	opx_newname[EBP], ESI	;Store offset of new name in case rename
	CLRL	EAX
	MOVL	SS:xffCount##, EAX
	MOVL	opx_newnsz[EBP], EAX
	MOVW	dcb_outframe[EDI], SS	;Set up an output queue
	MOVB	SS:xffQueue##, #dcb_outframe
	MOVL	ESI, dcb_netidb[EDI]	;Get offset of our IDB
	BTL	SS:xffHvValue1##, #IOV1%LCLPORT ;Local port number specified?
	JNC	6$			;No
	MOVL	ECX, opx_frame1[EBP]	;Yes
	MOVL	ECX, SS:opn_lclport[ECX] ;Use it
	PUSHL	EDX
	CALL	xosipsGetPort##
	POPL	EDX
	JC	16$			;If error setting the local port number
6$:	BTL	SS:xffHvValue1##, #IOV1%RMTPORTS ;Remote port number specified?
	JNC	8$.S			;No
	MOVL	EAX, opn_rmtports[EBP]	;Yes - use it
	XCHGB	AL, AH
	MOVW	dcb_ipsrmtport[EDI], AX
8$:	CLRL	ECX
	MOVB	dcb_xfpsts1[EDI], CL	;Clear our network status byte
	BTL	SS:xffHvValue1##, #IOV1%DIRHNDL ;Want to search open directory?
	JNC	18$			;No
	CALL	xosnetChkNetAddr##	;Yes - skip possible network address
	JNE	14$
	LEAL	EDX, 1[ECX]
14$:	CMPB	opx_msgtype[EBP], #XFPCF_OPEN ;Is this an open?
	JNE	havetcp			;No - this is OK
	MOVL	EAX, #ER_IFDEV		;CAN'T HANDLE THIS YET!!!!
16$:	CLRL	ECX
	LEAVE
	STC
	RET

;Here to establish a TCP connection if need to

18$:	CMPB	dcb_tcpstate[EDI], #TCPS_ESTAB ;Do we have a connection now?
	JNE	20$			;No
	CALL	xosnetChkNetAddr##	;Yes - skip possible network address
	JNE	havetcp
	LEAL	EDX, 1[ECX]
	JMP	havetcp

;Here if need to establish a TCP connection

20$:	MOVL	EAX, #30000t		;Get window size
	MOVB	CL, #3
	CALL	xostcpConnect##		;Establish the TCP connection
	JC	16$			;If error
					;OK - fall into havetcp on next page
.PAGE
;Here when we have a TCP connection - any errors after this point MUST clear
;  this connection before returning (except that we abandon the connection
;  if have a serious protocol error)!

havetcp:CALL	checkspec
	MOVL	opx_datasz[EBP], ECX
	PUSHL	EDX
	CMPB	opx_msgtype[EBP], #XFPCF_RENAME ;Is this a rename?
	JNE	2$			;No
	MOVL	EDX, opx_newname[EBP]	;Yes - get length of new name
	CALL	checkspec
	MOVL	opx_newnsz[EBP], ECX
2$:	POPL	EDX
	MOVL	EBX, #4t
	MOVL	EAX, SS:xffCmd##
	CALL	xfpputlong
	JC	10$
	MOVL	EAX, opx_datasz[EBP]
	CALL	storespec		;Store file specification in message
	JC	10$
	CMPB	opx_msgtype[EBP], #XFPCF_RENAME ;Is this a rename?
	JNE	4$.S			;No
	MOVL	EDX, opx_newname[EBP]	;Yes
	MOVL	EAX, opx_newnsz[EBP]
	CALL	storespec
	JC	10$
4$:	CALL	storeparm		;Store parameters
	MOVB	AL, opx_msgtype[EBP]	;Construct header
	MOVB	AH, #0x11
	BTL	SS:xffHvValue1##, #IOV1%DIRHNDL ;Searching open directory?
	JNC	6$			;No
	MOVB	AH, #0x12		;Yes - use channel 2
6$:	SHLL	EAX, #16t
	LEAL	ECX, -4[EBX]
	MOVB	AL, CH
	MOVB	AH, CL
	MOVL	opx_sndbufr[EBP], EAX
	CLRL	EDX
	CALL	xfpsend
	JC	10$
	CALL	xfppush			;Send the message
	JC	10$			;If error
	CALL	opendn
	LEAVE
	RET

10$:	CALL	opener
	LEAVE
	RET
.PAGE
;Here with file open request message sent

opendn:	CALL	xfprcvblk		;Get the response
	JC	8$			;If error
	CMPB	BL, #XFPSF_RESPONSE	;No - Is the response type right?
	JNE	openft			;No - fail
	MOVL	opx_error[EBP], EAX	;Yes - save response code
	MOVL	opx_rspsz[EBP], ECX	;Save bytes remaining in message
	CALL	xfpgetvalue		;Get the item count
	JC	8$
	MOVL	SS:xffCount##, EAX	;Save it
	CALL	xfpparm			;Process parameters from message
	JC	opener			;If error
	CALL	xfppar2			;OK - process the caller's parameters
					;  for the last time
	MOVL	EAX, opx_error[EBP]	;Get server's error code
	TESTL	EAX, EAX
	JE	opendn2			;If no error
	JNS	openft			;If positive (fatal error)
opener:	CMPB	dcb_xfpfcnt[EDI], #0	;Have any other files open on the
					;  connection?
	JNE	10$			;Yes
8$:	PUSHL	EAX			;No - save error code
	CALL	xostcpClear##		;Clear the TCP connection
	POPL	EAX
10$:	BTL	EAX, #31t		;Set C if error
	JMP	14$

;Here if no errors on the open

opendn2:CMPB	opx_msgtype[EBP], #XFPCF_OPEN ;Really an open?
	JE	13$
	CMPB	dcb_xfpfcnt[EDI], #0	;No - have any other files open on the
					;  connection?
	JNE	10$			;Yes
	BTL	SS:xffOption##, #O%NOHOLD
	JC	8$
	CMPB	dcb_tcpstate[EDI], #TCPS_ESTAB ;No - still have a connection?
	JNE	opener			;No
	MOVL	ECX, #15t		;Yes - hold the connection for 15
	CALL	knlHoldDev##		;  seconds
	MOVL	EAX, #0
	JC	opener			;If can't
	RET

;Here if really opening a file

13$:	INCB	dcb_xfpfcnt[EDI]	;Yes - count the open file
	BTL	SS:xffCmd##, #O%ODF	;Is this a open as a directory?
	JNC	14$			;No
	ORB	dcb_sts2[EDI], #D2$DIRECT ;Yes - indicate this
14$:	MOVL	ECX, SS:xffCount##	;Get item count
	RET				;All done

openft:	CALL	proterr			;Positive - fatal error!
	JMP	8$
.PAGE
	.SBTTL	sd_close - Close device

;Here for the close device entry
;	c{ECX} = Close option bits
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of device table entry
;	CALL	xfpclose
;	C:set = Error or not ready
;	  c{EAX} = Error code (0 means not ready)
;	C:clr = Normal

xfpclose:
	PUSHL	ESI
	CALL	sysIoCloseLock##	;Lock the QAB
	MOVB	iorb_queue[ESI], #dcb_outframe
	MOVL	iorb_routine[ESI], #xfpclose1
	JMP	knlXfQueue##		;Switch to extended fork context

;Here in extended fork context

xfpclose1:
	MOVL	ESI, dcb_netidb[EDI]	;Get offset of our IDB
	CMPL	dcb_opencnt[EDI], #1	;Final close?
	JNE	2$			;No
	TESTB	dcb_tcpsts2[EDI], #TCPS2$FATAL ;Is the XFP level still alive?
	JNE	2$			;No
	CMPB	dcb_tcpstate[EDI], #TCPS_ESTAB ;Yes - is the connection open?
	JE	10$			;No

;Here if not final close or if the TCP connection is already closed

2$:	CMPL	SS:xffParm##, #0	;Have any device parameters?
	JE	4$			;No
	MOVL	EBX, #ioparms		;Yes - process parameters
	MOVL	ECX, #knlComDPParms##
	IFFAULT	8$
	LFSL	EDX, SS:xffParm##
	CALL	knlProcDevParm##
	JC	6$
4$:	CLRL	EAX
6$:	JMP	knlXfCloseFin##

	FAULTHDR
8$:	MOVL	EAX, #ER_ADRER
	JMP	6$

;Here if final close and the TCP connection is still open

10$:	CMPB	dcb_xfpfcnt[EDI], #0	;Is a file open?
	JE	20$			;No
	MOVL	EBX, #knlOpnParms##	;Do initial setup (this also processes
	CALL	knlOpeXSetup##		;  any parameters and sets up an
					;  opn_ stack)
	JC	16$			;If error
	ENTER	opx_SIZE, 2
	MOVL	EBX, #4
	MOVL	EAX, SS:xffOption##	;Put command bits in the message
	CALL	xfpputlong
	CALL	storeparm		;Store possible parameters
	LEAL	EAX, -4[EBX]		;Construct the header bytes
	XCHGB	AL, AH
	ORL	EAX, #0x01000000+{XFPCF_CLOSE<16t}
	MOVL	opx_sndbufr[EBP], EAX	;Store them in the buffer
	CLRL	EDX
	CALL	xfpsend
	JC	14$
	CALL	xfppush			;Send the close message
	JC	14$			;If error
	DECB	dcb_xfpfcnt[EDI]	;Reduce the open file count
	CALL	opendn			;Get response and clear the connection
	LEAVE
	LEAVE
12$:	JMP	knlXfCloseFin##

;Here if error

14$:	LEAVE
16$:	LEAVE
	PUSHL	EAX
	CALL	xostcpClear##		;Clear the TCP connection
	POPL	EAX
	JMP	12$

;Here if no file is open but still have a TCP connection

20$:	CALL	xostcpClear##
	CLRL	EAX
	JMP	knlXfCloseFin##
.PAGE
xfpgivedcb:
	CMPL	dcb_hdlb[EDI], #0	;Has this device been held?
	JE	xostcpGiveDcb##		;No - give it up
	CLC				;Yes - do nothing here
	RET
.PAGE
;Here for the sd_commitfunc entry - commit data to disk
;	c{ESI} = Offset of IORB
;	c{EDI} = Offset of DCB
;	CALL	xfpcommit
;	c{EAX} = Error code
;	c{ECX} = Amount output
;	c{EBX} = Status bits

xfpcommit:
	PUSHL	ESI
	CALL	sysIoQabLock##		;Lock the QAB
	TESTL	EAX, EAX
	JS	2$			;If error
	PUSHL	ESI
	CALL	sysIoParmLock##		;Lock the parameter list
	TESTL	EAX, EAX
	JS	2$			;If error
	MOVB	iorb_queue[ESI], #dcb_outframe
	MOVL	iorb_routine[ESI], #xfpcommit1
	JMP	knlXfQueue##		;Switch to extended fork context

2$:	TOFORK
ret006:	RET

;Here in extended fork context

xfpcommit1:
	MOVL	SS:xffTimeOut##, #TIMEOUT_AP
	MOVL	EBX, #knlOpnParms##	;Do initial setup (this also processes
	CALL	knlOpeXSetup##		;  any parameters and sets up an
					;  opn_ stack)
	JC	16$			;If error
	ENTER	opx_SIZE, 2
;;;;;	CALL	checkparmio		;Calculate space needed for parameters
	INCL	ECX

;;	PUSHL	ECX
;;	ADDL	ECX, #4
;;	MOVL	EAX, SS:xffTimeOut##
;;	CALL	xostcpAlloc##		;Allocate space for the command
;;	POPL	ECX
;;	JC	16$			;If error

	CLRL	EBX

	LEAL	EAX, XFPCF_COMMIT<24t[ECX] ;Store the message header
	CALL	xfpputlong
	MOVB	AL, #1			;Store the file handle
	CALL	xfpputbyte
	CALL	storeparm		;Store parameters
	CLRL	EAX
	MOVL	SS:xffParm##, EAX
	CLRL	EDX
	CALL	xfpsend
	JC	16$
	CALL	xfppush			;Send the command
	JC	16$			;If error

10$:	CALL	xfprcvblk		;Get the response
	JC	16$			;If error
	TESTL	EAX, EAX		;Error reported by server?
	JS	14$			;Yes - don't check response type
	CMPB	BL, #XFPSF_RESPONSE	;Is the response type right?
	JNE	20$			;No - fail
14$:	MOVL	opx_error[EBP], EAX	;Yes - save error code
	MOVL	SS:xffCount##, ECX	;Save item count
	MOVL	opx_rspsz[EBP], EDX	;Save bytes remaining in message
	CALL	xfpparm			;Process parameters
	JC	16$			;If error
	CALL	xfppar2			;OK
	MOVL	EAX, opx_error[EBP]	;Get server's error code
	CMPL	EAX, #0
	JG	20$			;If bad error code
16$:	LEAVE
	LEAVE
	MOVL	ECX, SS:xffCount##	;Get item count
	MOVL	EBX, #QSTS$DONE
	RET

;Here with fatal protocol error

20$:	CALL	proterr
	CLRL	ECX
	LEAVE
	LEAVE
	RET
.PAGE
;Here for the sd_inpblock entry - input block
;	c{ESI} = Offset of IORB
;	c{EDI} = Offset of DCB
;	CALL	xfpinpblock
;	c{EAX} = Error code
;	c{ECX} = Amount output
;	c{EBX} = Status bits

xfpinpblk:
	PUSHL	ESI
	CALL	sysIoQabLock##		;Lock the QAB
	TESTL	EAX, EAX
	JS	2$			;If error
	PUSHL	ESI
	CALL	sysIoReadLock##		;Lock the buffer pages
	TESTL	EAX, EAX
	JS	2$			;If error
	MOVB	iorb_queue[ESI], #dcb_inpframe
	MOVL	iorb_routine[ESI], #xfpinpblk1
	JMP	knlXfQueue##		;Switch to extended fork context

2$:	TOFORK
	RET

;Here in extended fork context

xfpinpblk1:
	MOVL	SS:xffTimeOut##, #TIMEOUT_AP
	MOVL	EBX, #knlOpnParms##	;Do initial setup (this also processes
	CALL	knlOpeXSetup##		;  any parameters and sets up an
					;  opn_ stack)
	JC	6$			;If error
	ENTER	opx_SIZE, 2
	CMPL	SS:xffCount##, #0	;Really doing IO?
	JNE	10$			;Yes
	MOVL	ECX, SS:xffPVFilOpt##	;No - have any parameters?
	ORL	ECX, SS:xffHvValue1##
	ORL	ECX, SS:xffNdValue1##
	ORL	ECX, SS:xffHvValue2##
	ORL	ECX, SS:xffNdValue2##
	JNE	12$			;Yes
	CLRL	EAX			;No - nothing to do here
	LEAVE
6$:	LEAVE
	CLRL	ECX
	MOVL	EBX, #QSTS$DONE
	RET

8$:	LEAVE
	JMP	knlIllInpLv##

;Here if really doing input

10$:	TESTB	SS:xffCmd##, #O$IN	;Is input allowed?
	JE	8$			;No - fail
12$:	MOVL	EBX, #4t
	MOVL	EAX, SS:xffCount##	;Store amount wanted
	CALL	xfpputvalue
	CALL	storeparm		;Store parameters
	CLRL	EAX
	MOVL	opx_respttl[EBP], EAX
	MOVL	SS:xffParm##, EAX
	MOVL	EAX, #{XFPCF_DATAREQ+0x0100}<16t ;Construct header
	LEAL	ECX, -4[EBX]
	MOVB	AL, CH
	MOVB	AH, CL
	MOVL	opx_sndbufr[EBP], EAX
	CLRL	EDX
	CALL	xfpsend
	JC	38$
	CALL	xfppush			;Send the data request
14$:	JC	38$			;If error

;Here with the request message sent - get the response

20$:	CALL	xfprcvblk		;Get the response
	JC	14$			;If error
	CMPB	BL, #XFPSF_DATARESP
	JNE	46$
	MOVL	opx_srverror[EBP], EAX
	MOVB	opx_respbits[EBP], BH
	TESTB	BH, #0x20		;Have any parameters?
	JE	22$			;No
	MOVL	opx_rspsz[EBP], ECX	;Yes
	CALL	xostcpGetWord		;Get length of the data part
	JC	48$
	MOVL	opx_respdata[EBP], EAX
	ADDL	EAX, #2
	SUBL	opx_rspsz[EBP], EAX
	JNS	24$
	JMP	46$

;Here if there are no parameters in the message

22$:	MOVL	opx_respdata[EBP], ECX
	MOVL	opx_rspsz[EBP], #0
24$:	MOVL	ECX, opx_respdata[EBP]	;Get the length of the data

	CMPL	ECX, SS:xffCount##	;More than we asked for?
	JG	46$			;Yes - serious problem!
	JREGZ	ECX, 30$		;If no data
26$:	LESL	EBX, SS:xffBuffer1##

;;;;;;;	MOVL	EAX, #25t*ST_SECOND	;;;;;;;;;; INSERT THIS TO TEST
;;;;;;;	CALL	knlXfWait##		;;;;;;;;;; WINDOW PROBES!

	MOVL	ECX, opx_respdata[EBP]
	MOVL	EAX, #TIMEOUT_AP	;Get time-out value
	CALL	xostcpGetBlk##		;Give the data to the user
	JC	38$			;If error
	ADDL	opx_respttl[EBP], ECX	;OK - add into total transfered
	ADDL	SS:xffBuffer1##, ECX
	SUBL	opx_respdata[EBP], ECX
	JG	26$			;If need more
30$:	CMPL	opx_rspsz[EBP], #0	;Have any parameters?
	JE	32$			;No
	CALL	xfpparm			;Yes - process parameters from the
	JC	48$			;  message
	CALL	xfppar2			;Finally, process the user's parameters
32$:	CALL	xostcpOpenWindow##	;Open our window if we need to now
	TESTB	opx_respbits[EBP], #0x10 ;Final message?
	JE	20$			;No - continue
	MOVL	EAX, opx_error[EBP]
38$:	MOVL	ECX, opx_respttl[EBP]
	LEAVE
	LEAVE
	MOVL	EBX, #QSTS$DONE
	RET

;Here if have fatal protocol error

46$:	CALL	proterr
	JMP	50$.S

48$:	CALL	xostcpFatal##
50$:	MOVL	opx_respttl[EBP], #0
	JMP	38$.S
.PAGE
	.SBTTL	xfpoutstr - Queued output null terminated string

;Here for the sd_outstring entry - output null terminated string
;	c{EDI}    = Offset of DCB
;	c{FS:EDX} = Address of QAB
;	CALL	xfpoutstr
;	c{EAX} = Error code
;	c{ECX} = Amount output
;	c{EBX} = Status bits

xfpoutstr:
	PUSHL	ESI
	CALL	sysIoQabLock##		;Lock the QAB
	TESTL	EAX, EAX
	JS	2$			;If error
	PUSHL	ESI
	CALL	sysIoStringLock##	;Lock the string pages
	TESTL	EAX, EAX
	JNS	4$			;OK - go on
2$:	TOFORK				;If error
	RET

	.SBTTL	xfpoutblk - Queued output block

;Here for the sd_outblock entry - output block
;	c{ESI} = Offset of QAB
;	c{EDI} = Offset of DCB
;	CALL	xfpoutblk
;	c{EAX} = Error code
;	c{ECX} = Amount output
;	c{EBX} = Status bits

$$$=!0
FRM xo_count  , 4
FRM xo_iosize , 4
FRM xo_amount , 4
FRM xo_error  , 4
FRM xo_pktsize, 4
xo_SIZE=!$$$

xfpoutblk:
	PUSHL	ESI
	CALL	sysIoQabLock##		;Lock the QAB
	TESTL	EAX, EAX
	JS	2$			;If error
	PUSHL	ESI
	CALL	sysIoWriteLock##	;Lock the buffer pages
	TESTL	EAX, EAX
	JS	2$			;If error
4$:	MOVB	iorb_queue[ESI], #dcb_outframe
	MOVL	iorb_routine[ESI], #xfpoutblk1
	JMP	knlXfQueue##		;Switch to extended fork context

6$:	LEAVE
	CLRL	ECX			;Report nothing received
	MOVL	EBX, #QSTS$DONE
	RET				;And return

;Here in extended fork context

xfpoutblk1:
	MOVL	SS:xffTimeOut##, #TIMEOUT_AP
	MOVL	EBX, #knlOpnParms##	;Do initial setup (this also processes
	CALL	knlOpeXSetup##		;  any parameters and sets up an
					;  opn_ stack)
	JC	6$.S			;If error
	ENTER	opx_SIZE, 2		;Set up our stack frame
	MOVL	opx_amount[EBP], #0
8$:	MOVL	ECX, SS:xffCount##	;Get amount wanted
	CMPL	ECX, #XFPMXSIZE		;Too much for one message?
	JB	10$			;No
	MOVL	ECX, #XFPMXSIZE		;Yes - just use maximum
10$:	SUBL	SS:xffCount#, ECX	;Reduce amount needed
	MOVL	opx_datasz[EBP], ECX	;Save amount for this time
	CMPL	SS:xffParm##+0, #0	;Have any parameters?
	JNE	12$.S			;Yes

;Here if no parameters (usual case)

	CLRL	EBX
	MOVL	EAX, opx_datasz[EBP]	;Put message length in the header
	CALL	xfpputword
	MOVL	EAX, #0x0E01		;Assume no response wanted
	CMPL	SS:xffCount##, #0	;Right
	JNE	12$			;Yes
	ORB	AL, #0x10		;No - request response
12$:	CALL	xfpputword
	CLRL	EDX
	CALL	xfpsend
	JC	38$
	MOVL	ECX, opx_datasz[EBP]
	TESTL	ECX, ECX
	JE	outsend
	LESL	EBX, SS:xffBuffer1##
	CALL	xostcpPutBlk##
	JNC	outsend
	JMP	38$

;Here if have some parameters - We must construct the parameter list first
;  so we will know the total message length for the header.

20$:	MOVL	EBX, #8t
	CALL	storeparm		;Store parameters
	JC	38$
	MOVL	SS:xffParm##+0, #0	;Only do this once
	MOVL	opx_parm[EBP], EBX	;Save end of the parameter list
	MOVL	EAX, EBX		;Calculate total message length
	ADDL	EAX, opx_datasz[EBP]
	ADDL	EAX, #2
	CLRL	EBX
	CALL	xfpputword		;Store message length in the header
	MOVL	EAX, #0x0E21		;Assume no response wanted
	CMPL	SS:xffCount##, #0	;Right
	JNE	22$			;Yes
	ORB	AL, #0x10		;No - request response
22$:	CALL	xfpputword
	CLRL	EDX
	CALL	xfpsend			;Send the header
	JC	38$
	MOVL	ECX, opx_datasz[EBP]
	TESTL	ECX, ECX
	JE	38$
	LESL	EBX, SS:xffBuffer1##
	CALL	xostcpPutBlk##		;Send the data
	JC	38$
	MOVL	EBX, opx_parm[EBP]
	MOVL	EDX, #8
	CALL	xfpsend			;Send the parameter bytes
	JC	38$
outsend:CALL	xfppush
	JC	38$
	MOVL	EAX, opx_datasz[EBP]	;Increate amount done
	ADDL	opx_amount[EBP], EAX
	ADDL	SS:xffBuffer1##+0, EAX
	CMPL	SS:xffCount##, #0	;Want any more?
	JNE	8$			;Yes
	CALL	xfprcvblk		;No - get the response
	JC	38$			;If error
	CMPB	BL, #XFPSF_RESPONSE	;Did we get a response?
	JNE	46$			;No - protocol error!
	TESTL	EAX, EAX		;Error reported by server?
	JS	outserr			;Yes
	MOVL	opx_rspsz[EBP], ECX	;Save bytes remaining in message
	CALL	xfpgetvalue		;Get the item count
	JC	38$
	MOVL	opx_amount[EBP], EAX
34$:	CLRL	EAX
36$:	PUSHL	EAX
	CALL	xfpparm			;Process parameters from the message
	JC	44$
	MOVL	EAX, opx_parm[EBP]	;Restore parameter list offset
	MOVL	SS:xffParm##, EAX
	CALL	xfppar2			;Process parameter list
	POPL	EAX
38$:	MOVL	ECX, opx_amount[EBP]
	LEAVE
	LEAVE
	MOVL	EBX, #QSTS$DONE
	RET

;Here if error reported by server

outserr:CMPL	EAX, #ER_EOF		;End of file?
	JNE	36$			;No
	CMPL	opx_amount[EBP], #0	;Yes - did we get anything at all?
	JE	36$			;No - report the error
	JMP	34$			;Yes - just return what we got

;Here if error return from tcpgetblk

42$:	ADDL	opx_amount[EBP], ECX
	JMP	38$.S

;Here if have fatal protocol error

44$:	POPL	ECX			;Discard original error code
46$:	CALL	proterr
	JMP	38$
.PAGE
	.SBTTL	xfpdelete - Delete file

;Here for SV_delete function - delete file
;	c{SS:EDX} = Address of expanded file name
;	c{EDI}    = Offset of DCB for file to delete or its directory
;	c{ESI}    = Device table offset for file to delete or its directory
;	CALL	xfpdelete
;	C:set = Error
;	  c{EAX} = Error code
;	  c{ECX} = Item count
;	C:clr = Normal
;	  c{EAX} = 0
;	  c{ECX} = Item count

xfpdelete:
	MOVB	AL, #XFPCF_DELETE	;Get message type
	JMP	open2			;Continue with common code
.PAGE
	.SBTTL	xfprename - Rename file

;Here for SV_RENAME function - Rename file
;	c{SS:ESI} = Address of buffer containing processed new name
;	c{ECX}    = Option bits
;	c{SS:EDX} = Address of expanded file specification
;	c{EDI}    = Offset of DCB for old file or directory
;	CALL	xfprename
;	C:set = Error
;	  c{EAX} = Error code
;	  c{ECX} = Item count
;	C:clr = Normal
;	  c{EAX} = 0
;	  c{ECX} = Item count

xfprename:
	PUSHL	EDX
	LEAL	EBX, opn_devname[EBP]	;Get physical device name
	MOVL	EDX, opn_frame1[EBP]
	ADDL	EDX, #opn_devname
	MOVL	EAX, SS:[EBX]		;Same device?
	CMPL	SS:[EDX], EAX
	JNE	10$.S			;No - fail!
	MOVL	EAX, SS:4[EBX]
	CMPL	SS:4[EDX], EAX
	JNE	10$.S
	MOVL	EAX, SS:8[EBX]
	CMPL	SS:8[EDX], EAX
	JNE	10$.S
	MOVL	EAX, SS:12t[EBX]
	CMPL	SS:12t[EDX], EAX
	POPL	EDX
	JNE	10$.S
	PUSHL	ESI			;Scan the new name to see if there is
	CLD				;  a network address
2$:	LODSB	SS:[ESI]
	CMPB	AL, #0
	JE	4$.S
	CMPB	AL, #':'
	JNE	2$.S
	LODSB	SS:[ESI]
	CMPB	AL, #':'
	JNE	4$.S
	POPL	EAX			;Have network address - discard it!
	JMP	6$.S

;Here if don't have a network address

4$:	POPL	ESI			;Restore offset of start of name string
6$:	MOVB	AL, #XFPCF_RENAME	;Get message type
	JMP	open2			;Continue with common code

;Here if new name is different

10$:	MOVL	EAX, #ER_DFDEV
	CLRL	ECX
	STC
	RET
.PAGE
	.SBTTL	checkspec - Subroutine to determine length of file specification

;Subroutine to determine length of file specification
;	c{SS:EDX} = Address of file specification
;	CALL	checkspec
;	c{ECX} = Length of file specification (in bytes)

checkspec:
	PUSHL	EDI
	MOVL	EDI, EDX		;Get length of file specification
	PUSHL	SS
	POPL	ES
	MOVB	AL, #0
	CLD
	MOVL	ECX, #-1
	RNSCASB	[EDI]
	POPL	EDI
	NOTL	ECX
	CMPL	ECX, #127t		;Need two bytes for the count?
	JBE	4$.S			;No
	INCL	ECX			;Yes
4$:	RET

	.SBTTL	storespec - Subroutine to store file specification

;Subroutine to store file specification in command message
;	c{EAX}    = Total length for file specification (includes count byte(s))
;	c{SS:EDX} = Address of file specification
;	CALL	storespec
;	c{EBX} = Offset of first byte after file specification

storespec:
	PUSHL	EDX			;Save offset of file specification
	DECL	EAX			;Adjust count
	CMPL	EAX, #127t		;Will it fit in one byte?
	JBE	6$.S			;Yes
	DECL	EAX			;No
	PUSHL	EAX
	ORB	AH, #80h		;Indicate two byte value
	CALL	xfpputword
	JMP	8$.S

6$:	PUSHL	EAX			;Store one byte vaue
	CALL	xfpputbyte
8$:	JC	4$
	POPL	ECX			;Restore actual length of file spec.
	POPL	EDX			;Restore offset of file spec.
	JMP	xfpputblk
.PAGE
	.SBTTL	storeparm - Subroutine to store parameters

;Subroutine to store parameters for OPEN, PARM, DELETE, and RENAME functions
;	CALL	storeparm

storeparm:
	CLRL	EAX
	MOVL	opx_parmerr1[EBP], EAX
	MOVL	opx_parmerr2[EBP], EAX

;Handle the IOPAR_FILOPTN parameter

	MOVL	EAX, SS:xffPVFilOpt##	;Need IOPAR_FILOPTN parameter?
	ANDL	EAX, #FOBITS
	JE	18$			;No
	MOVL	EAX, #{XFPPAR_FILOPTN<8}|84h ;Yes - store parameter
	CALL	xfpputword
	JC	11$
	MOVL	EAX, SS:xffPVFilOpt##	;Get value
	ANDL	EAX, #FOBITS		;Clear unneeded bits
	BTL	EAX, #FO%RXOSNAME	;Want remote name?
	JNC	2$			;No
	BTSL	EAX, #FO%XOSNAME	;Yes - get device name
2$:	BTL	EAX, #FO%RDOSNAME	;Want remote DOS name?
	JNC	3$			;No
	BTSL	EAX, #FO%DOSNAME	;Yes - get DOS name
3$:	BTL	EAX, #FO%RVOLNAME	;Want remote volume name?
	JNC	4$			;No
	BTSL	EAX, #FO%VOLNAME	;Yes - get volume name
4$:	BTL	SS:xffHvValue1##, #IOV1%DIRHNDL ;Searching open directory?
	JNC	6$			;No
	ANDL	EAX, #~{FO$NODENUM|FO$NODENAME} ;Yes - node can't change here!
6$:	CALL	xfpputlong
	JC	11$

;Handle the IOPAR_FILSPEC parameter

	CMPL	SS:xffPPFilSpc##+0, #0	;Need IOPAR_FILSPEC parameter?
	JE	18$			;No
	MOVB	AL, #XFPPAR_FILSPEC
	CALL	xfpputbyte
	JC	11$
	MOVZWL	EAX, SS:xffPSFilSpc##	;Get length of his buffer
	TESTL	SS:xffPVFilOpt##, #FO$XOSNAME|FO$DOSNAME|FO$VOLNAME
					;Does he want the device name?
	JE	10$			;No
	SUBL	EAX, #12t		;Yes - subtract space for device name
	CMPL	EAX, #12t		;Big enough?
	JA	10$			;Yes
	MOVL	EAX, #12t		;No - do the best we can!
10$:	CMPL	EAX, #1Fh		;Need more than 5 bits for the length?
	JA	12$			;Yes
	ORB	AL, #40h		;No - store the 5 bit length value
	CALL	xfpputbyte
	JNC	18$
11$:	RET

;Here if need more than 5 bits for the count

12$:	CMPL	EAX, #0xFFF		;Need more than 12 bits?
	JG	14$			;Yes
	ORB	AH, #0x60		;No -store the 12 bit length value
	CALL	xfpputword
	JNC	18$
13$:	RET

;Here if need more than 12 bits for the count

14$:	CMPL	EAX, #0x7FFFF		;Need more than 19 bits?
	JG	16$			;Yes
	PUSHL	EAX
	SHRL	EAX, #16t
	ORB	AL, #0x70
	CALL	xfpputbyte
	POPL	EDX
	JC	13$
	MOVL	EAX, EDX
	CALL	xfpputword
	JNC	18$
	RET

;Here if need more than 19 bits for the count

16$:	CMPL	EAX, #0x3FFFFFF		;Too big?
	JLE	17$			;No
	MOVL	EAX, #0x3FFFFFF
17$:	ORL	EAX, 0x78000000
	CALL	xfpputlong

;Check for other parameters

18$:	PUSHL	SS:xffHvValue1##	;Get both the "have" and "need" bits
	MOVL	EAX, SS:xffNdValue1##
	ORL	[ESP], EAX
	JE	100$			;If nothing at all needed

;Handle the IOPAR_DEVSTS parameter (read only)

	BTL	[ESP], #IOV1%DEVSTS	;Need IOPAR_DEVSTS parameter?
	JNC	20$			;No
	MOVL	EAX, #{XFPPAR_DEVSTS<8}|0x44 ;Yes - store parameter
	CALL	xfpputword
	JC	200$

;Handle the IOPAR_UNITNUM parameter (read only)

20$:	BTL	[ESP], #IOV1%UNITNUM	;Need IOPAR_UNITNUM parameter?
	JNC	22$			;No
	MOVL	EAX, #{XFPPAR_UNITNUM<8}|0x44 ;Yes - store parameter
	CALL	xfpputword
	JC	200$

;Handle the IOPAR_GLBID parameter (read only)

22$:	BTL	[ESP], #IOV1%GLBID	;Need IOPAR_GLBID parameter?
	JNC	24$			;No
	MOVL	EAX, #{XFPPAR_GLBID<8}|0x50 ;Yes
	CALL	xfpputword
	JC	200$

;Handle the IOPAR_SRCATTR parameter (write only)

24$:	BTL	[ESP], #IOV1%SRCATTR	;Need IOPAR_SRCATTR parameter?
	JNC	26$			;No
	MOVL	EAX, #{XFPPAR_SRCATTR<8}|0x81 ;Yes - store parameter
	CALL	xfpputword
	JC	200$
	MOVL	EAX, opx_frame1[EBP]
	MOVB	AL, SS:opn_srcattr[EAX] ;Store value
	CALL	xfpputbyte
	JC	200$

;Handle t he IOPAR_FILATTR parameter

26$:	BTL	[ESP], #IOV1%FILATTR	;Need IOPAR_FILATTR parameter?
	JNC	32$			;No
	MOVL	EAX, #{XFPPAR_FILATTR<8}|1
	BTL	SS:xffNdValue1##, #IOV1%FILATTR
	JNC	28$
	ORB	AL, #40h
28$:	BTL	SS:xffHvValue1##, #IOV1%FILATTR
	JNC	30$
	ORB	AL, #80h
30$:	CALL	xfpputword
	JC	200$
	TESTB	AL, #80h
	JE	32$
	MOVL	EAX, opx_frame1[EBP]
	MOVB	AL, SS:opn_filattr[EAX]
	CALL	xfpputbyte
	JC	200$

;Handle the IOPAR_DIROFS parameter

32$:	MOVL	ECX, #IOV1%DIROFS
	BTL	[ESP], ECX		;Need IOPAR_DIROFS parameter?
	JNC	34$			;No
	MOVB	AH, #XFPPAR_DIROFS	;Yes
	MOVL	EDX, #opn_dirofs
	CALL	sparm4
	JC	200$

;Handle the IOPAR_xxxPOS parameters

34$:	MOVL	ECX, #IOV1%ABSPOS
	BTL	[ESP], ECX		;Need IOPAR_xxxPOS parameter?
	JNC	38$			;No
	MOVB	AH, #XFPPAR_ABSPOS	;Yes - assume need IOPAR_ABSPOS
	TESTL	[ESP], #IOV1$RELPOS|IOV1$EOFPOS ;Right?
	JE	36$			;Yes
	MOVB	AH, #XFPPAR_RELPOS	;No - assume need IOPAR_RELPOS
	BTL	[ESP], #IOV1%RELPOS	;Right?
	JC	36$			;Yes
	MOVB	AH, #XFPPAR_EOFPOS	;No - must be IOPAR_EOFPOS
36$:	MOVL	EDX, #opn_iopos
	CALL	sparm4
	JC	200$

;Handle the IOPAR_LENGTH parameter

38$:	MOVL	ECX, #IOV1%LENGTH
	BTL	[ESP], ECX		;Need IOPAR_LENGTH parameter?
	JNC	40$			;No
	MOVB	AH, #XFPPAR_LENGTH	;Yes
	MOVL	EDX, #opn_length
	CALL	sparm4
	JC	200$

;Handle the IOPAR_DIRHNDL parameter - We already know that the value of this
;  parameter points to the DCB we are currently using. The corresponding XFP
;  channel is always 1.

40$:	BTL	[ESP], #IOV1%DIRHNDL	;Need IOPAR_DIRHNDL parameter?
	JNC	42$			;No
	MOVL	EAX, #{XFPPAR_DIRHNDL<<8}|0x81 ;Yes
	CALL	xfpputword
	JC	200$
	MOVB	AL, #1			;Store value
	CALL	xfpputbyte
	JC	200$

;Handle the IOPAR_REQALLOC parameter

42$:	MOVL	ECX, #IOV1%REQALLOC
	BTL	[ESP], ECX		;Need IOPAR_REQALLOC parameter?
	JNC	44$			;No
	MOVB	AH, #XFPPAR_REQALLOC
	MOVL	EDX, #opn_reqalloc
	CALL	sparm4
	JC	200$
44$:	MOVL	ECX, #IOV1%RQRALLOC
	BTL	[ESP], ECX		;Need IOPAR_RQRALLOC parameter?
	JNC	46$			;No
	MOVB	AH, #XFPPAR_RQRALLOC
	MOVL	EDX, #opn_rqralloc
	CALL	sparm4
	JC	200$
46$:	MOVL	ECX, #IOV1%GRPSIZE
	BTL	[ESP], ECX		;Need IOPAR_GRPSIZE parameter?
	JNC	48$			;No
	MOVB	AH, #XFPPAR_GRPSIZE
	MOVL	EDX, #opn_grpsize
	CALL	sparm4
	JC	200$
48$:	MOVL	ECX, #IOV1%ADATE
	BTL	[ESP], ECX		;Need IOPAR_ADATE parameter?
	JNC	50$			;No
	MOVB	AH, #XFPPAR_ADATE
	MOVB	AL, #DF$DOSADATE
	MOVL	EDX, #opn_adate
	CALL	sparmdt
	JC	200$
50$:	MOVL	ECX, #IOV1%CDATE
	BTL	[ESP], ECX		;Need IOPAR_CDATE parameter?
	JNC	52$			;No
	MOVB	AH, #XFPPAR_CDATE
	MOVB	AL, #DF$DOSCDATE
	MOVL	EDX, #opn_cdate
	CALL	sparmdt
	JC	200$
52$:	MOVL	ECX, #IOV1%MDATE
	BTL	[ESP], ECX		;Need IOPAR_MDATE parameter?
	JNC	54$			;No
	MOVB	AH, #XFPPAR_MDATE
	MOVB	AL, #DF$DOSMDATE
	MOVL	EDX, #opn_mdate
	CALL	sparmdt
	JC	200$
54$:	MOVL	ECX, #IOV1%PROT
	BTL	[ESP], ECX		;Need IOPAR_PROT parameter?
	JNC	56$			;No
	MOVB	AH, #XFPPAR_PROT
	MOVL	EDX, #opn_prot
	CALL	sparm4
	JC	200$
56$:	MOVL	ECX, #IOV1%OWNER
	BTL	[ESP], ECX		;Need IOPAR_OWNER parameter?
	JNC	68$			;No
	MOVB	AL, #XFPPAR_OWNER	;Yes
	CALL	xfpputbyte		;Store parameter index
	JC	200$
	MOVL	EDX, opx_frame1[EBP]
	ADDL	EDX, #opn_owner		;Determine length of the name
	PUSHL	EDX
	CLRL	EAX
58$:	CMPB	SS:[EDX], #0
	JE	60$
	INCL	EAX
	JMP	58$

60$:	POPL	EDX
	MOVB	AH, #10h
	BTL	SS:xffNdValue1##, ECX	;Getting value?
	JNC	62$			;No
	ORB	AH, #40h		;Yes
62$:	BTL	SS:xffHvValue1##, ECX	;Setting value?
	JNC	64$			;No
	ORB	AH, #80h		;Yes
64$:	CALL	xfpputword
	JC	200$
	POPL	EDX
	TESTB	AH, #80h		;Need value?
	JE	68$.S			;No
66$:	MOVB	AL, SS:[EDX]		;Yes - store value
	CMPB	AL, #0
	JE	68$
	INCL	EDX
	PUSHL	EDX
	CALL	xfpputbyte
	POPL	EDX
	JNC	66$
	JMP	200$

68$:	MOVL	ECX, #IOV1%SETLOCK	;Need IOPAR_SETLOCK parameter?
	BTL	[ESP], ECX
	JNC	70$			;No
	MOVB	AH, #XFPPAR_SETLOCK	;Yes
	MOVL	EDX, #opn_lockval
	CALL	sparm8
	JC	200$
70$:	MOVL	ECX, #IOV1%CLRLOCK	;Need IOPAR_CLRLOCK parameter?
	BTL	[ESP], ECX
	JNC	100$			;No
	MOVB	AH, #XFPPAR_CLRLOCK	;Yes
	MOVL	EDX, #opn_lockval
	CALL	sparm8
	JC	200$
100$:	MOVL	EAX, SS:xffHvValue2##	;Get both the "have" and "need" bits
	ORL	EAX, SS:xffNdValue2##
	JE	200$			;If nothing at all needed here
	MOVL	[ESP], EAX
	BTL	EAX, #IOV2%FSTYPE	;Need IOPAR_FSTYPE parameter?
	JNC	102$			;No
	MOVL	EAX, #{XFPPAR_FSTYPE<8}|41h ;Yes - store parameter
	CALL	xfpputword
	JC	200$
102$:	BTL	[ESP], #IOV2%SECTSIZE	;Need IOPAR_SECTSIZE parameter?
	JNC	104$			;No
	MOVL	EAX, #{XFPPAR_SECTSIZE<8}|42h ;Yes - store parameter
	CALL	xfpputword
	JC	200$
104$:	BTL	[ESP], #IOV2%CLSSIZE	;Need IOPAR_CLSSIZE parameter?
	JNC	106$			;No
	MOVL	EAX, #{XFPPAR_CLSSIZE<8}|41h ;Yes - store parameter
	CALL	xfpputword
	JC	200$
106$:	BTL	[ESP], #IOV2%TTLSPACE	;Need IOPAR_TTLSPACE parameter?
	JNC	108$			;No
	MOVL	EAX, #{XFPPAR_TTLSPACE<8}|44h ;Yes - store parameter
	CALL	xfpputword
	JC	200$
108$:	BTL	[ESP], #IOV2%AVLSPACE	;Need IOPAR_AVLSPACE parameter?
	JNC	110$			;No
	MOVL	EAX, #{XFPPAR_AVLSPACE<8}|44h ;Yes - store parameter
	CALL	xfpputword
	JC	200$
110$:	BTL	[ESP], #IOV2%NUMHEAD	;Need IOPAR_NUMHEAD parameter?
	JNC	112$			;No
	MOVL	EAX, #{XFPPAR_NUMHEAD<8}|42h ;Yes - store parameter
	CALL	xfpputword
	JC	200$
112$:	BTL	[ESP], #IOV2%NUMSECT	;Need IOPAR_NUMSECT parameter?
	JNC	114$			;No
	MOVL	EAX, #{XFPPAR_NUMSECT<8}|42h ;Yes - store parameter
	CALL	xfpputword
	JC	200$
114$:	BTL	[ESP], #IOV2%NUMCYLN	;Need IOPAR_NUMCYLN parameter?
	JNC	200$			;No
	MOVL	EAX, #{XFPPAR_NUMCYLN<8}|42h ;Yes - store parameter
	CALL	xfpputword
200$:	POPL	ECX			;Fix up the stack
ret010:	RET				;Finished
.PAGE
;Subroutine to store parameter with 4 byte value
;	c(AH)  = Parameter index
;	c{EBX} = Pointer to message being built
;	c{ECX} = Bit to test (bit number)
;	c{EDX} = Offset of value for parameter
;	CALL	sparm4

sparm4:	ADDL	EDX, opx_frame1[EBP]
	MOVB	AL, #4
	BTL	SS:xffNdValue1##, ECX	;Getting value?
	JNC	2$			;No
	ORB	AL, #40h		;Yes
2$:	BTL	SS:xffHvValue1##, ECX	;Setting value?
	JNC	xfpputword		;No - just store the parameter header
	ORB	AL, #80h		;Yes
	PUSHL	EDX
	CALL	xfpputword		;Store parameter header
	POPL	EDX
	JC	ret010
	MOVL	EAX, SS:[EDX]		;Get value
	JMP	xfpputlong		;Store value and return

;Subroutine to store date/time parameter
;	c(AL)  = Date format bit to test
;	c(AH)  = Parameter index
;	c{EBX} = Pointer to message being built
;	c{ECX} = Bit to test (bit number)
;	c{EDX} = Offset of value for parameter
;	CALL	sparmdt

sparmdt:
	PUSHL	EDX
	MOVL	EDX, opx_frame1[EBP]
	TESTB	SS:opn_datefmt[EDX], AL ;Have DOS format date/time value?
	POPL	EDX
	JNE	sparm4.S		;Yes - store 4 byte value
sparm8:	ADDL	EDX, opx_frame1[EBP]	;No
	MOVB	AL, #8			;Get value length
	BTL	SS:xffNdValue1##, ECX	;Getting value?
	JNC	10$.S			;No
	ORB	AL, #40h		;Yes
10$:	BTL	SS:xffHvValue1##, ECX	;Setting value?
	JNC	12$.S			;No
	ORB	AL, #80h		;Yes
12$:	PUSHL	EDX
	CALL	xfpputword
	POPL	EDX
	JC	ret010
	TESTB	AL, #80h		;Need value?
	JE	ret010			;No - finished here
	MOVL	EAX, SS:4[EDX]		;Yes - store first 4 bytes of value
	PUSHL	EDX
	CALL	xfpputlong
	JC	ret010
	POPL	EDX
	MOVL	EAX, SS:[EDX]		;Store second 4 bytes of value
	JMP	xfpputlong
.PAGE


xfpputbyte:
	CMPL	EBX, #SNDSIZE - 1	;Room for more?
	JG	4$
	MOVB	opx_sndbufr[EBP+EBX], AL
	INCL	EBX
	CLC
	RET

4$:	MOVL	EAX, #ER_REC2L
	STC
	RET

xfpputword:
	CMPL	EBX, #SNDSIZE - 2	;Room for more?
	JG	4$
	XCHGB	AL, AH
	MOVW	opx_sndbufr[EBP+EBX], AX
	ADDL	EBX, #2
	RET

xfpputlong:
	CMPL	EBX, #SNDSIZE - 4	;Room for more?
	JG	4$

;;;;	BSWAPL	EAX

	XCHGB	AL, AH
	RORL	EAX, #16t
	XCHGB	AL, AH
	MOVL	opx_sndbufr[EBP+EBX], EAX
	ADDL	EBX, #4
10$:	RET


xfpputblk:
	LEAL	EAX, [EBX+ECX]
	CMPL	EAX, #SNDSIZE
	JG	4$
	PUSHL	EDI
	PUSHL	ESI
	PUSHL	SS
	POPL	ES
	MOVL	ESI, EDX
	LEAL	EDI, opx_sndbufr[EBP+EBX]
	ADDL	EBX, ECX
	CLD
	RMOVSB	[EDI], SS:[ESI]
	POPL	ESI
	POPL	EDI
	CLC
	RET

;Subroutine to store variable length value
;	c{EAX} = Value to store
;	c{EBX} = Index to buffer

xfpputvalue:
	TESTL	EAX, #0xFFFFFF80	;Will it fit in 1 byte?
	JE	xfpputbyte		;Yes
	TESTL	EAX, #0xFFFFC000	;No - will it fit in 2 bytes?
	JNE	14$			;No
	ORB	AH, #0x80		;Yes
	JMP	xfpputword

14$:	TESTL	EAX, #0xFFE00000	;Will it fit in 3 bytes?
	JNE	16$			;No
	PUSHL	EAX
	SHRL	EAX, #16t
	ORB	AL, #0xC0
	CALL	xfpputbyte
	JC	18$
	POPL	EAX
	JMP	xfpputword

16$:	ORL	EAX, #0xE0000000
	JMP	xfpputlong
	
18$:	POPL	ECX
	RET


;Subroutine to send buffered XFP bytes
;	c{EDX} = Offset of first byte in buffer to send
;	c{EBX} = Offset of last byte to send + 1
;	CALL	xfpsend
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

xfpsend:CMPL	EBX, EDX
	JLE	10$
	MOVL	ECX, EBX
	SUBL	ECX, EDX
	LEAL	EBX, opx_sndbufr[EBP+EDX]
	PUSHL	SS
	POPL	ES
	JMP	xostcpPutBlk##

	.SBTTL	xfppush - Subroutine to send XFP message

;Subroutine to send XFP message
;	c{EDI} = Offset of DCB
;	CALL	xfppush

xfppush:CALL	xostcpPush##		;Send the packet
	MOVL	EAX, dcb_ipsdpdb[EDI]	;Count the output message
;;;;	ADDL	dpdb_tcpxfpcntbyteout[EAX], ECX
	INCL	dpdb_tcpxfpcntmsgout[EAX]
	RET
.PAGE
	.SBTTL	xfprcvblk - Subroutine to get received XFP message

;Subroutine to get received XFP mesage - must be called in extended fork
;  context
;	c{EDI} = Offset of DCB
;	c{ESI} = Offset of IDB
;	CALL	xfprcvblk
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Response value
;	  c(BL)  = Message type
;	  c(BH)  = Header bits + channel number
;	  c{ECX} = Bytes remaining in message
;  Note: The error return is only given if there is an error reading the
;	 response or if the format of the response is bad. Errors returned
;	 by the server are indicated in the response value. If no error is
;	 returned from the server the response value is always 0.


$$$=!0
FRM xrb_header,4t
xrb_SIZE=!$$$

xfprcvblk:
	ENTER	xrb_SIZE, 0
	CALL	xostcpGetLong##		;Get the 4 header bytes
	JC	xrbdone
	MOVL	xrb_header[EBP], EAX	;Save them
	SHRL	EAX, #16t		;Get the message length
	MOVL	EDX, dcb_ipsdpdb[EDI]	;Count the received message
	INCL	dpdb_tcpxfpcntmsgin[EDX]
	ADDL	dpdb_tcpxfpcntbytein[EDX], EAX
	CLRL	EAX			;Assume no error return
	TESTB	xrb_header+0[EBP], #0x80 ;Right?
	JE	4$			;Yes
	SUBW	xrb_header+2[EBP], #4t	;No - have an error code?
	JL	10$
	CALL	xostcpGetLong##		;Get the error code value
	JC	xrbdone
4$:	MOVB	BL, xrb_header+1[EBP]
	ANDB	BL, #0x0F
	MOVB	BH, xrb_header+0[EBP]
	MOVZWL	ECX, xrb_header+2[EBP]
xrbdone:LEAVE
ret012:	RET

10$:	LEAVE
	JMP	proterr

.PAGE
	.SBTTL	xfpgetvalue - Subroutine to get variable length value

;Subroutine to get variable length value
;	CALL	xfpgetvalue
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Value

xfpgetvalue:
	DECL	opx_rspsz[EBP]		;Have another byte?
	JS	proterr			;No - fail
	CALL	xostcpGetByte##		;Get first byte
	JC	14$
	BTZL	EAX, #7t		;1-byte value?
	JNC	14$			;Yes
	BTZL	EAX, #6t		;No - 2-byte value?
	JNC	16$			;Yes
	BTZL	EAX, #5t		;No - 3-byte value?
	JNC	8$			;Yes
	BTZL	EAX, #4t		;No - 4-byte value?
	JNC	4$

;Here if this is a 5-byte value (only 32 bits are used)

	SUBL	opx_rspsz[EBP], #4	;Have 4 more bytes
	JNS	xostcpGetLong##		;Yes - get the 4-byte value
	JMP	proterr			;No - fail

;Here if this is a 4-byte value

4$:	SUBL	opx_rspsz[EBP], #3	;Have 3 more bytes?
	JS	proterr			;No - fail
	SHLL	EAX, #24t
	PUSHL	EAX
	CALL	xostcpGetByte##
	JC	12$
	SHLL	EAX, #16t
	ORL	[ESP], EAX
	JMP	10$

;Here if this is a 3-byte value

8$:	SUBL	opx_rspsz[EBP], #2	;Have 2 more bytes?
	JS	proterr			;No - fail
	SHLL	EAX, #16t
	PUSHL	EAX
10$:	CALL	xostcpGetWord##
12$:	POPL	EDX
	JC	14$
	ORL	EAX, EDX
14$:	RET

;Here if this is a 2-byte value

16$:	DECL	opx_rspsz[EBP]		;Have another byte?
	JS	proterr			;No - fail
	SHLL	EAX, #8t
	PUSHL	EAX
	CALL	xostcpGetByte##
	POPL	EDX
	JC	14$
	ORL	EAX, EDX
ret020:	RET
.PAGE
	.SBTTL	xfpparm - Subroutine to process received XFP parameters

;Subroutine to process received XFP parameters
;	CALL	xfpparm
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

2$:	CLC
	RET

xfpparm:DECL	opx_rspsz[EBP]		;Any more left in message?
	JS	2$			;No - finished with parameters
	DECL	opx_rspsz[EBP]		;Must have at least two bytes here
	JS	proterr
	CALL	xostcpGetByte##		;Yes - get parameter index
	JC	ret020
	PUSHL	EAX
	CALL	xostcpGetByte##		;Get bits and first part of count
	JC	14$
	PUSHL	EAX
	TESTB	AL, #0x40		;Need another count byte?
	JE	4$			;No
	DECL	opx_rspsz[EBP]		;Yes - make sure have it
	JS	8$
	PUSHL	EAX
	CALL	xostcpGetByte##		;Get second part of count
	POPL	EDX
	JC	12$
	MOVB	AH, DL
	ANDL	EAX, #0x3FFF
4$:	SUBL	opx_rspsz[EBP], EAX	;Reduce count, make sure have enough
	JS	8$			;If not enough there
	MOVL	ECX, EAX
	POPL	EAX			;Restore error bit
	POPL	EDX			;Restore parameter index
	MOVZBL	EDX, DL
	CMPB	DL, #MAXXFPPAR		;Legal parameter index?
	JA	proterr			;No
	CALLI	xfppartbl[EDX*4]	;Yes - dispatch on the parameter
	JNC	xfpparm
	RET

;Here if error

8$:	POPL	EAX			;Fix up the stack
	POPL	EAX
proterr:MOVL	EAX, dcb_ipsdpdb[EDI]	;Count the protocol error
	INCL	dpdb_tcpxfpcntproerr[EAX]
	MOVL	EAX, #ER_NPERR
	JMP	xostcpFatal##

12$:	POPL	ECX
14$:	POPL	ECX
	RET

	DATA

xfppartbl:
	.LONG	proterr		;		 = 0   - Illegal
	.LONG	proterr		;XFPPAR_FILOPTN  = 1   - File option bits
	.LONG	xfpparfilspec	;XFPPAR_FILSPEC  = 2   - File specification
	.LONG	xfppardevsts	;XFPPAR_DEVSTS   = 3   - Device status
	.LONG	xfpparunitnum	;XFPPAR_UNITNUM  = 4   - Unit number
	.LONG	xfpparglbid	;XFPPAR_GLBID    = 5   - Global device ID
	.LONG	proterr		;XFPPAR_NUMOPN   = 6   - Number of times device
				;			   is open
	.LONG	proterr		;		 = 7   - Illegal
	.LONG	proterr		;		 = 8   - Illegal
	.LONG	proterr		;		 = 9   - Illegal
	.LONG	proterr		;		 = 10  - Illegal
	.LONG	proterr		;		 = 11  - Illegal
	.LONG	xfppardirhndl	;XFPPAR_DIRHNDL  = 12  - Directory handle for
				;			   search
	.LONG	proterr		;		 = 13  - Illegal
	.LONG	xfpparsrcattr	;XFPPAR_SRCATTR  = 14  - File attributes for
				;			   search
	.LONG	xfpparfilattr	;XFPPAR_FILATTR  = 15  - File attributes for
				;			   file
	.LONG	xfppardirofs	;XFPPAR_DIROFS   = 16  - Dir offset for srch
	.LONG	xfppariopos	;XFPPAR_ABSPOS   = 17  - Absolute pos in file
	.LONG	xfppariopos	;XFPPAR_RELPOS   = 18  - Relative pos in file
	.LONG	xfppariopos	;XFPPAR_EOFPOS   = 19  - Pos relative to EOF
	.LONG	proterr		;		 = 20  - Illegal
	.LONG	xfpparlength	;XFPPAR_LENGTH   = 21  - Written length of file
	.LONG	xfpparalloc	;XFPPAR_REQALLOC = 22  - Request allocation
	.LONG	xfpparalloc	;XFPPAR_RQRALLOC = 23  - Require allocation
	.LONG	xfppargrpsize	;XFPPAR_GRPSIZE  = 24  - Allocation group size
	.LONG	xfpparadate	;XFPPAR_ADATE    = 25  - Last access date/time
	.LONG	xfpparcdate	;XFPPAR_CDATE    = 26  - Creation date/time
	.LONG	xfpparmdate	;XFPPAR_MDATE    = 27  - Modify date/time
	.LONG	xfpparprot	;XFPPAR_PROT     = 28  - File protection
	.LONG	xfpparowner	;XFPPAR_OWNER    = 29  - Owner name
	.LONG	proterr		;		 = 30  - Illegal
	.LONG	xfpsetlock	;XFPPAR_SETLOCK	 = 31  - Set record lock
	.LONG	xfpclrlock	;XFPPAR_CLRLOCK	 = 32  - Clear record lock
	.LONG	proterr		;		 = 33  - Illegal
	.LONG	proterr		;		 = 34  - Illegal
	.LONG	proterr		;		 = 35  - Illegal
	.LONG	proterr		;		 = 36  - Illegal
	.LONG	proterr		;		 = 37  - Illegal
	.LONG	proterr		;		 = 38  - Illegal
	.LONG	proterr		;		 = 39  - Illegal
	.LONG	proterr		;		 = 40  - Illegal
	.LONG	proterr		;		 = 41  - Illegal
	.LONG	proterr		;		 = 42  - Illegal
	.LONG	proterr		;		 = 43  - Illegal
	.LONG	proterr		;		 = 44  - Illegal
	.LONG	proterr		;		 = 45  - Illegal
	.LONG	proterr		;		 = 46  - Illegal
	.LONG	proterr		;		 = 47  - Illegal
	.LONG	proterr		;		 = 48  - Illegal
	.LONG	proterr		;		 = 49  - Illegal
	.LONG	proterr		;		 = 50  - Illegal
	.LONG	proterr		;		 = 51  - Illegal
	.LONG	proterr		;		 = 52  - Illegal
	.LONG	proterr		;		 = 53  - Illegal
	.LONG	proterr		;		 = 54  - Illegal
	.LONG	proterr		;		 = 55  - Illegal
	.LONG	proterr		;		 = 56  - Illegal
	.LONG	proterr		;		 = 57  - Illegal
	.LONG	proterr		;		 = 58  - Illegal
	.LONG	proterr		;		 = 59  - Illegal
	.LONG	proterr		;		 = 60  - Illegal
	.LONG	proterr		;		 = 61  - Illegal
	.LONG	proterr		;		 = 62  - Illegal
	.LONG	proterr		;		 = 63  - Illegal
	.LONG	proterr		;		 = 64  - Illegal
	.LONG	proterr		;		 = 65  - Illegal
	.LONG	proterr		;		 = 66  - Illegal
	.LONG	proterr		;		 = 67  - Illegal
	.LONG	proterr		;		 = 68  - Illegal
	.LONG	proterr		;		 = 69  - Illegal
	.LONG	proterr		;		 = 70  - Illegal
	.LONG	proterr		;		 = 71  - Illegal
	.LONG	proterr		;		 = 72  - Illegal
	.LONG	proterr		;		 = 73  - Illegal
	.LONG	proterr		;		 = 74  - Illegal
	.LONG	proterr		;		 = 75  - Illegal
	.LONG	proterr		;		 = 76  - Illegal
	.LONG	proterr		;		 = 77  - Illegal
	.LONG	proterr		;		 = 78  - Illegal
	.LONG	proterr		;		 = 79  - Illegal
	.LONG	proterr		;		 = 80  - Illegal
	.LONG	proterr		;		 = 81  - Illegal
	.LONG	proterr		;		 = 82  - Illegal
	.LONG	proterr		;		 = 83  - Illegal
	.LONG	proterr		;		 = 84  - Illegal
	.LONG	proterr		;		 = 85  - Illegal
	.LONG	proterr		;		 = 86  - Illegal
	.LONG	proterr		;		 = 87  - Illegal
	.LONG	proterr		;		 = 88  - Illegal
	.LONG	proterr		;		 = 89  - Illegal
	.LONG	proterr		;		 = 90  - Illegal
	.LONG	proterr		;		 = 91  - Illegal
	.LONG	proterr		;		 = 92  - Illegal
	.LONG	proterr		;		 = 93  - Illegal
	.LONG	proterr		;		 = 94  - Illegal
	.LONG	proterr		;		 = 95  - Illegal
	.LONG	xfpfstype	;XFPPAR_FSTYPE   = 96  - File system type
	.LONG	xfpsectsize	;XFPPAR_SECTSIZE = 97  - Sector size
	.LONG	xfpclssize	;XFPPAR_CLSSIZE  = 98  - Cluster size
	.LONG	xfpttlspace	;XFPPAR_TTLSPACE = 99  - Total space
	.LONG	xfpavlspace	;XFPPAR_AVLSPACE = 100 - Available space
	.LONG	xfpnumhead	;XFPPAR_NUMHEAD  = 101 - Number of heads
	.LONG	xfpnumsect	;XFPPAR_NUMSECT  = 102 - Number of sectors
	.LONG	xfpnumcyln	;XFPPAR_NUMCYLN  = 103 - Number of cylinders
MAXXFPPAR=!{$-xfppartbl}/4-1

	CODE
.PAGE
;Here with all parameters from the response processed - now we must process
;  the user's parameter list again to give him any values we got (but only
;  if we acutally got one or more values)

xfppar2:CMPL	SS:xffParm##, #0	;Have a parameter list?
	JE	4$.S			;No
	MOVL	EBX, #ioparms		;Yes - process parameters a final time
	MOVL	ECX, #knlComDPParms##
	LFSL	EDX, SS:xffParm##
	CALL	knlProcDevParm##
	CLC				;Ignore errors here (should not be any!)
4$:	RET				;Finished
.PAGE
	.MOD	4

	.LONG	PARMMAX
ioparms:.LONG	iogenparms	 ;IOPAR_xxxxxx = 00xx - Generic IO parameters
	.LONG	iofilparms	 ;IOPAR_FILxxx = 01xx - File system IO
				 ;			  parameters
	.LONG	knlNullTrmParms##;IOPAR_TRMxxx = 02xx - Terminal IO parameters
	.LONG	iodskparms	 ;IOPAR_DSKxxx = 03xx - Disk IO parameters
PARMMAX=!{$-ioparms}/4

	.LONG	PARMGENMAX	;Size of table
iogenparms:
	.LONG	0		;		   = 0000h
	.LONG	ioparfiloptn	;IOPAR_FILOPTN     = 0001h
	.LONG	ioparfilspec	;IOPAR_FILSPEC     = 0002h
	.LONG	iopardevsts	;IOPAR_DEVSTS      = 0003h
	.LONG	ioparunitnum	;IOPAR_UNITNUM     = 0004h
	.LONG	ioparglbid	;IOPAR_GLBID       = 0005h
	.LONG	knlIopDelay##	;IOPAR_DELAY       = 0006h
	.LONG	knlIopTimeOut##	;IOPAR_TIMEOUT     = 0007h
	.LONG	knlIopIoSts##	;IOPAR_INPSTS      = 0008h
	.LONG	knlIopIoSts##	;IOPAR_OUTSTS      = 0009h
	.LONG	knlIopInpQLmt##	;IOPAR_INPQLMT     = 000Ah
	.LONG	knlIopOutQLmt##	;IOPAR_OUTQLMT     = 000Bh
	.LONG	0		;IOPAR_SIVECT1     = 000Ch
	.LONG	0		;IOPAR_SIVECT2     = 000Dh
	.LONG	0		;IOPAR_SIDATA      = 000Eh
	.LONG	knlIopNumOpen##	;IOPAR_NUMOPEN     = 000Fh
	.LONG	knlIopBufrLmt##	;IOPAR_BUFRLMT	   = 0010h
PARMGENMAX=!{$-iogenparms}/4

	.LONG	PARMFILMAX
iofilparms:
	.LONG	0		;		   = 0100h
	.LONG	iopardirhndl	;IOPAR_DIRHNDL     = 0101h
	.LONG	ioparsrcattr	;IOPAR_SRCATTR     = 0102h
	.LONG	ioparfilattr	;IOPAR_FILATTR     = 0103h
	.LONG	iopardirofs	;IOPAR_DIROFS      = 0104h
	.LONG	iopariopos	;IOPAR_ABSPOS      = 0105h
	.LONG	iopariopos	;IOPAR_RELPOS      = 0106h
	.LONG	iopariopos	;IOPAR_EOFPOS      = 0107h
	.LONG	0		;IOPAR_VBOF	   = 0108h
	.LONG	ioparlength	;IOPAR_LENGTH      = 0109h
	.LONG	ioparalloc	;IOPAR_REQALLOC    = 010Ah
	.LONG	ioparalloc	;IOPAR_RQRALLOC    = 010Bh
	.LONG	iopargrpsize	;IOPAR_GRPSIZE     = 010Ch
	.LONG	ioparadate	;IOPAR_ADATE       = 010Dh
	.LONG	ioparcdate	;IOPAR_CDATE       = 010Eh
	.LONG	ioparmdate	;IOPAR_MDATE       = 010Fh
	.LONG	ioparprot	;IOPAR_PROT        = 0110h
	.LONG	ioparowner	;IOPAR_OWNER       = 0111h
	.LONG	0		;		   = 0112h
	.LONG	ioparlock	;IOPAR_SETLOCK     = 0113h
	.LONG	ioparlock	;IOPAR_CLRLOCK     = 0114h
	.LONG	0		;IOPAR_CLSTIME     = 0115h
	.LONG	0		;IOPAR_CLSNAME     = 0116h
	.LONG	0		;IOPAR_CLSMSG	   = 0117h
	.LONG	0		;IOPAR_SHRPARMS    = 0118h
PARMFILMAX=!{$-iofilparms}/4

	.LONG	PARMDSKMAX
iodskparms:
	.LONG	0		;		   = 0300h
	.LONG	ioparfstype	;IOPAR_DSKFSTYPE   = 0301h
	.LONG	ioparsectsize	;IOPAR_DSKSECTSIZE = 0302h
	.LONG	ioparclssize	;IOPAR_DSKCLSSIZE  = 0303h
	.LONG	ioparttlspace	;IOPAR_DSKTTLSPACE = 0304h
	.LONG	ioparavlspace	;IOPAR_DSKAVLSPACE = 0305h
	.LONG	ioparnumhead	;IOPAR_DSKNUMHEAD  = 0306h
	.LONG	ioparnumsect	;IOPAR_DSKNUMSECT  = 0307h
	.LONG	ioparnumcyln	;IOPAR_DSKNUMCYLN  = 0308h
PARMDSKMAX=!{$-iodskparms}/4
.PAGE
;Here for the XFPPAR_FILSPEC parameter - File specification string

xfpparfilspec:
	TESTB	AL, #PAR$ERROR
	JE	2$.S
	BTSL	opx_parmerr1[EBP], #IOV1%FILSPEC
2$:	TESTL	SS:xffPVFilOpt##, #FO$NODENUM|FO$NODENAME
					;Want node specification?
	JE	10$.S			;No
	BTL	SS:xffHvValue1##, #IOV1%DIRHNDL ;Yes - searching open directory?
	JC	10$.S			;Yes
	CMPB	SS:xffRtdName##+0, #0	;No - have rooted name pending?
	JNE	10$.S			;Yes
	PUSHL	ECX			;No
	BTL	SS:xffPVFilOpt##, #FO%NOPREFIX
	JC	3$.S
	MOVB	AL, #FS_NODENUM
	CALL	knlGivUChr##
3$:	MOVL	ECX, #4
	LEAL	EBX, dcb_ipsrmtaddr[EDI]
4$:	MOVZBL	EAX, [EBX]
	INCL	EBX
	CALL	knlGivUNum##
	DECL	ECX
	JREGZ	ECX, 6$
	MOVB	AL, #'.'
	CALL	knlGivUChr##
	JMP	4$.S

6$:	MOVB	AL, #':'
	CALL	knlGivUChr##
	MOVB	AL, #':'
	CALL	knlGivUChr##
	POPL	ECX
10$:	JREGZ	ECX, 22$		;If no data
12$:	PUSHL	ECX			;Save count
	CALL	xostcpGetByte##		;Get a byte
	JC	24$.S			;If error
	CMPB	AL, #FS_XOSNAME		;Device?
	JNE	14$.S			;No
	MOVB	AL, #FS_RXOSNAME	;Yes - change to remove device?
14$:	CMPB	AL, #FS_DOSNAME		;DOS device?
	JNE	15$.S			;No
	MOVB	AL, #FS_RDOSNAME	;Yes - change to remote DOS device
15$:	CMPB	AL, #FS_VOLNAME		;Volume device?
	JNE	16$.S			;No
	MOVB	AL, #FS_RVOLNAME	;Yes - change to remote volume device
16$:	CMPB	AL, #FS_MIN		;Prefix code?
	JB	18$.S			;No
	BTL	SS:xffPVFilOpt##, #FO%NOPREFIX ;Yes - do we want it?
	JNC	19$.S			;Yes
	JMP	20$.S			;No

;Here if data 

18$:	CMPB	SS:xffRtdName##+0, #0	;Have outstanding rooted name?
	JNE	20$.S			;Yes - don't give him the character
19$:	CALL	knlGivUChr##		;No - give him the character
	JC	24$.S			;If error
20$:	POPL	ECX			;Restore count
	LOOP	ECX, 12$		;Continue if more
22$:	CLC
	RET

;Here if fatal error

24$:	POPL	ECX
	RET
.PAGE
;Here for the XFPPAR_DEVSTS parameter - Device status

xfppardevsts:
	TESTB	AL, #PAR$ERROR
	JE	8$.S
	BTSL	opx_parmerr1[EBP], #IOV1%DEVSTS
8$:	CALL	getparmval		;Get up to 32 bits of value
	JC	10$.S
	MOVL	opx_devsts[EBP], EAX	;Save it
10$:	RET

;Here for the XFPPAR_UNITNUM parameter - Unit number

xfpparunitnum:
	TESTB	AL, #PAR$ERROR
	JE	12$.S
	BTSL	opx_parmerr1[EBP], #IOV1%UNITNUM
12$:	CALL	getparmval		;Get up to 32 bits of value
	JC	14$.S
	MOVL	opx_unitnum[EBP], EAX	;Save it
14$:	RET

;Here for the XFPPAR_GLBID parameter - Global device ID

xfpparglbid:
	TESTB	AL, #PAR$ERROR
	JE	16$.S
	BTSL	opx_parmerr1[EBP], #IOV1%GLBID
16$:	LEAL	EBX, opx_glbid[EBP]
	JMP	getparmv16b		;Get up to 16 bytes of value

;Here for the XFPPAR_DIRHNDL parameter - Directory handle

xfppardirhndl:
	TESTB	AL, #PAR$ERROR
	JE	17$.S
	BTSL	opx_parmerr1[EBP], #IOV1%DIRHNDL
17$:	JMP	getparmval

;Here for the XFPPAR_SRCATTR parameter - Search attributes

xfpparsrcattr:
	TESTB	AL, #PAR$ERROR
	JE	18$.S
	BTSL	opx_parmerr1[EBP], #IOV1%SRCATTR
18$:	JMP	getparmval

;Here for the XFPPAR_FILATTR parameter - File attributes

xfpparfilattr:
	TESTB	AL, #PAR$ERROR
	JE	19$.S
	BTSL	opx_parmerr1[EBP], #IOV1%FILATTR
19$:	CALL	getparmval		;Get up to 32 bits of value
	JC	20$.S
	MOVL	opx_filattr[EBP], EAX	;Save it
20$:	RET

;Here for the XFPPAR_DIROFS parameter - Directory offset for search

xfppardirofs:
	TESTB	AL, #PAR$ERROR
	JE	22$.S
	BTSL	opx_parmerr1[EBP], #IOV1%DIROFS
22$:	CALL	getparmval		;Get up to 32 bits of value
	JC	24$.S
	MOVL	EDX, opx_frame1[EBP]
	MOVL	SS:opn_dirofs[EDX], EAX ;Save it
24$:	RET

;Here for the XFPPAR_ABSPOS, XFPPAR_RELPOS, or XFPPAR_EOFPOS parameter - Position
;  in file

xfppariopos:
	TESTB	AL, #PAR$ERROR
	JE	26$.S
	BTSL	opx_parmerr1[EBP], #IOV1%ABSPOS
26$:	CALL	getparmval		;Get up to 32 bits of value
	JC	28$.S
	MOVL	EDX, opx_frame1[EBP]
	MOVL	SS:opn_iopos[EDX], EAX	;Save it
28$:	RET

;Here for the XFPPAR_LENGTH parameter - Written length of file

xfpparlength:
	TESTB	AL, #PAR$ERROR
	JE	30$.S
	BTSL	opx_parmerr1[EBP], #IOV1%LENGTH
30$:	CALL	getparmval		;Get up to 32 bits of value
	JC	32$.S
	MOVL	EDX, opx_frame1[EBP]
	MOVL	SS:opn_length[EDX], EAX ;Save it
32$:	RET

;Here for the XFPPAR_REQALLOC or XFPPAR_RQRALLOC parameter - Allocated size of
;  file

xfpparalloc:
	TESTB	AL, #PAR$ERROR
	JE	34$.S
	BTSL	opx_parmerr1[EBP], #IOV1%REQALLOC
34$:	CALL	getparmval		;Get up to 32 bits of value
	JC	36$.S
	MOVL	EDX, opx_frame1[EBP]
	MOVL	SS:opn_reqalloc[EDX], EAX ;Save it
36$:	RET

;Here for the XFPPAR_GRPSIZE parameter - Allocation group size

xfppargrpsize:
	TESTB	AL, #PAR$ERROR
	JE	38$.S
	BTSL	opx_parmerr1[EBP], #IOV1%GRPSIZE
38$:	CALL	getparmval		;Get up to 32 bits of value
	JC	40$.S
	MOVL	EDX, opx_frame1[EBP]
	MOVL	SS:opn_grpsize[EDX], EAX ;Save it
40$:	RET

;Here for the XFPPAR_ADATE parameter - Last access date/time

xfpparadate:
	TESTB	AL, #PAR$ERROR
	JE	42$.S
	BTSL	opx_parmerr1[EBP], #IOV1%ADATE
42$:	CALL	getparmdt		;Get up to 64 bits of value
	JC	44$.S
	MOVL	ECX, opx_frame1[EBP]
	MOVL	SS:opn_adate+0[ECX], EAX ;Save it
	MOVL	SS:opn_adate+4[ECX], EDX
44$:	RET

;Here for the XFPPAR_CDATE parameter - Creation date/time

xfpparcdate:
	TESTB	AL, #PAR$ERROR
	JE	46$.S
	BTSL	opx_parmerr1[EBP], #IOV1%CDATE
46$:	CALL	getparmdt		;Get up to 64 bits of value
	JC	48$.S
	MOVL	ECX, opx_frame1[EBP]
	MOVL	SS:opn_cdate+0[ECX], EAX ;Save it
	MOVL	SS:opn_cdate+4[ECX], EDX
48$:	RET

;Here for the XFPPAR_MDATE parameter - Modify date/time

xfpparmdate:
	TESTB	AL, #PAR$ERROR
	JE	50$.S
	BTSL	opx_parmerr1[EBP], #IOV1%MDATE
50$:	CALL	getparmdt		;Get up to 64 bits of value
	JC	52$.S
	MOVL	ECX, opx_frame1[EBP]
	MOVL	SS:opn_mdate+0[ECX], EAX ;Save it
	MOVL	SS:opn_mdate+4[ECX], EDX
52$:	RET

;Here for the XFPPAR_PROT parameter - File protection

xfpparprot:
	TESTB	AL, #PAR$ERROR
	JE	54$.S
	BTSL	opx_parmerr1[EBP], #IOV1%PROT
54$:	CALL	getparmval		;Get up to 32 bits of value
	JC	56$.S
	MOVL	EDX, opx_frame1[EBP]
	MOVL	SS:opn_prot[EDX], EAX	;Save it
56$:	RET

;Here for the XFPPAR_OWNER parameter - Owner name

xfpparowner:
	TESTB	AL, #PAR$ERROR
	JE	58$.S
	BTSL	opx_parmerr1[EBP], #IOV1%OWNER
58$:	MOVL	EBX, opx_frame1[EBP]
	ADDL	EBX, #opn_owner

	CRASH	????

	JMP	getparmv16b		;Get up to 16 bytes of value
.PAGE
;Here for the XFPPAR_SETLOCK parameter - Set record lock

xfpsetlock:
	TESTB	AL, #PAR$ERROR		;Error?
	JE	4$.S			;No
	BTSL	opx_parmerr1[EBP], #IOV1%SETLOCK ;Yes
	JMP	4$.S

;Here for the XFPAR_CLRLOCK parameter - Clear record lock

xfpclrlock:
	TESTB	AL, #PAR$ERROR		;Error?
	JE	4$.S			;No
	BTSL	opx_parmerr1[EBP], #IOV1%CLRLOCK ;Yes
4$:	MOVL	EBX, opx_frame1[EBP]
	ADDL	EBX, #opn_lockval
	JMP	getparmval		;Get the value
.PAGE
;Here for the XFPPAR_FSTYPE parameter - File system type

xfpfstype:
	TESTB	AL, #PAR$ERROR
	JE	4$.S
	BTSL	opx_parmerr2[EBP], #IOV2%FSTYPE
4$:	CALL	getparmval		;Get up to 32 bits of value
	JC	6$.S
	MOVL	EDX, opx_frame1[EBP]
	MOVB	SS:opn_fstype[EDX], AL	;Save it
6$:	RET

;Here for the XFPAR_SECTSIZE parameter - Sector size

xfpsectsize:
	TESTB	AL, #PAR$ERROR
	JE	7$.S
	BTSL	opx_parmerr2[EBP], #IOV2%SECTSIZE
7$:	CALL	getparmval		;Get up to 32 bits of value
	JC	6$.S
	MOVL	EDX, opx_frame1[EBP]
	MOVW	SS:opn_sectsize[EDX], AX ;Save it
	RET

;Here for the XFPPAR_CLSSIZE parameter - Cluster size

xfpclssize:
	TESTB	AL, #PAR$ERROR
	JE	8$.S
	BTSL	opx_parmerr2[EBP], #IOV2%CLSSIZE
8$:	CALL	getparmval		;Get up to 32 bits of value
	JC	6$.S
	MOVL	EDX, opx_frame1[EBP]
	MOVB	SS:opn_clssize[EDX], AL	;Save it
	RET

;Here for the XFPPAR_TTLSPACE parameter - Total space (in clusters)

xfpttlspace:
	TESTB	AL, #PAR$ERROR
	JE	10$.S
	BTSL	opx_parmerr2[EBP], #IOV2%TTLSPACE
10$:	CALL	getparmval		;Get up to 32 bits of value
	JC	6$.S
	MOVL	EDX, opx_frame1[EBP]
	MOVL	SS:opn_ttlspace[EDX], EAX ;Save it
	RET

;Here for the XFPPAR_AVLSPACE parameter - Available space (in clusters)

xfpavlspace:
	TESTB	AL, #PAR$ERROR
	JE	12$.S
	BTSL	opx_parmerr2[EBP], #IOV2%AVLSPACE
12$:	CALL	getparmval		;Get up to 32 bits of value
	JC	6$.S
	MOVL	EDX, opx_frame1[EBP]
	MOVL	SS:opn_avlspace[EDX], EAX ;Save it
	RET

;Here for the XFPPAR_NUMHEAD parameter - Number of heads

xfpnumhead:
	TESTB	AL, #PAR$ERROR
	JE	14$.S
	BTSL	opx_parmerr2[EBP], #IOV2%NUMHEAD
14$:	CALL	getparmval		;Get up to 32 bits of value
	JC	16$.S
	MOVL	EDX, opx_frame1[EBP]
	MOVW	SS:opn_numhead[EDX], AX	;Save it
16$:	RET

;Here for the XFPPAR_NUMSECT parameter - Number of sectors

xfpnumsect:
	TESTB	AL, #PAR$ERROR
	JE	18$.S
	BTSL	opx_parmerr2[EBP], #IOV2%NUMSECT
18$:	CALL	getparmval		;Get up to 32 bits of value
	JC	16$.S
	MOVL	EDX, opx_frame1[EBP]
	MOVW	SS:opn_numsect[EDX], AX	;Save it
	RET

;Here for the XFPPAR_NUMCYLN parameter - Number of cylinders

xfpnumcyln:
	TESTB	AL, #PAR$ERROR
	JE	20$.S
	BTSL	opx_parmerr2[EBP], #IOV2%NUMCYLN
20$:	CALL	getparmval		;Get up to 32 bits of value
	JC	16$.S
	MOVL	EDX, opx_frame1[EBP]
	MOVW	SS:opn_numcyln[EDX], AX	;Save it
	RET
.PAGE
;Subroutine to get 32 bit parameter value
;	c{ECX} = Number of value bytes available
;	CALL	getparmval
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Value

getparmval:
	JREGZ	ECX, 8$			;If no value to get
	CMPL	ECX, #4			;Have too many value bytes?
	JBE	4$.S			;No
	PUSHL	ECX			;Yes - discard one
	CALL	xostcpGetByte##
	POPL	ECX
	JC	10$.S			;If error
	LOOP	ECX, getparmval		;Continue

;Here with 4 or less value bytes left

4$:	PUSHL	#0			;Clear the value
	LEAL	EBX, [ESP+ECX]		;Point to high order byte
6$:	PUSHL	EBX
	PUSHL	ECX
	CALL	xostcpGetByte##		;Get a value byte
	POPL	ECX
	POPL	EBX
	JC	12$.S			;If error
	DECL	EBX
	MOVB	SS:[EBX], AL		;Store the byte in the value
	LOOP	ECX, 6$
	POPL	EAX			;Get value
8$:	CLC
10$:	RET				;Return with it

;Here if error getting byte

12$:	POPL	ECX			;Fix up the stack
	RET
.PAGE
;Subroutine to get 64 bit parameter value (date and time value) - this is
;  a numeric value which is byte reversed
;	c{ECX} = Number of value bytes available
;	c{EBX} = Offset to receive value
;	CALL	getparmdt
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EDX,EAX} = Value

getparmdt:
	CMPL	ECX, #8			;Have too many value bytes?
	JBE	4$.S			;No
	PUSHL	ECX			;Yes - discard one
	CALL	xostcpGetByte##
	POPL	ECX
	JC	10$.S			;If error
	LOOP	ECX, getparmdt		;Continue

;Here with 8 or fewer value bytes

4$:	PUSHL	#0
	PUSHL	#0
	MOVL	EBX, ESP
	ADDL	EBX, ECX		;Point to high order byte
6$:	JREGZ	ECX, 10$
8$:	PUSHL	EBX
	PUSHL	ECX
	CALL	xostcpGetByte##		;Get a value byte
	POPL	ECX
	POPL	EBX
	JC	12$.S			;If error
	DECL	EBX
	MOVB	SS:[EBX], AL		;Store the byte in the value
	LOOP	ECX, 8$
	POPL	EAX
	POPL	EDX
10$:	RET				;Finished

12$:	POPL	EDX
	POPL	EDX
	RET
.PAGE
;Subroutine to get 16 byte parameter value - this is a byte string value which
;  is not byte reversed
;	c{ECX} = Number of value bytes available
;	c{EBX} = Offset to receive value
;	CALL	getparmdt
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

getparmv16b:
	CMPL	ECX, #16t		;Have too many value bytes?
	JBE	4$.S			;No
	PUSHL	EBX
	PUSHL	ECX			;Yes - discard one
	CALL	xostcpGetByte##
	POPL	ECX
	POPL	EBX
	JC	8$.S			;If error
	LOOP	ECX, getparmv16b	;Continue

;Here with 16 or fewer value bytes

4$:	JREGZ	ECX, 8$
6$:	PUSHL	EBX
	PUSHL	ECX
	CALL	xostcpGetByte##		;Get a value byte
	POPL	ECX
	POPL	EBX
	JC	8$.S			;If error
	MOVB	SS:[EBX], AL		;Store the byte in the value
	INCL	EBX
	LOOP	ECX, 6$
8$:	RET				;Finished
.PAGE
;Here for IOPAR_FILOPTN - File specification options

	DPARMHDR  SET, HEXV
ioparfiloptn:
	BTL	opx_parmerr1[EBP], #IOV1%FILOPTN
	JC	4$.S
	RET

;Here for IOPAR_FILSPEC - File specification

	DPARMHDR  GET, STR
ioparfilspec:
	BTL	opx_parmerr1[EBP], #IOV1%FILSPEC
	JC	4$.S
	RET

;Here for IOPAR_DEVSTS - Device status

	DPARMHDR  GET, HEXV
iopardevsts:
	BTL	opx_parmerr1[EBP], #IOV1%DEVSTS
	JC	4$.S
	MOVL	EAX, opx_devsts[EBP]
	JMP	knlStrParm4##

;Here for IOPAR_UNITNUM - Unit number

	DPARMHDR  GET, HEXV
ioparunitnum:
	BTL	opx_parmerr1[EBP], #IOV1%UNITNUM
	JC	4$.S
	MOVL	EAX, opx_unitnum[EBP]
	JMP	knlStrParm4##

;Here for IOPAR_DIRHNDL - Directory handle for search

	DPARMHDR  SET, HEXV
iopardirhndl:
	BTL	opx_parmerr1[EBP], #IOV1%DIRHNDL
	JC	4$.S
	RET

;Here for IOPAR_SRCATTR - Search attributes

	DPARMHDR  BOTH, HEXV
ioparsrcattr:
	BTL	opx_parmerr1[EBP], #IOV1%SRCATTR
	JC	4$.S
2$:	RET

;Here for IOPAR_FILATTR - File attributes for file

	DPARMHDR  BOTH, HEXV
ioparfilattr:
	BTL	opx_parmerr1[EBP], #IOV1%FILATTR
	JC	4$.S
	TESTB	AH, #PAR$GET
	JE	2$.S
	MOVL	EAX, opx_filattr[EBP]
	JMP	knlStrParm4##

;Here for IOPAR_DIROFS - Directory offset for file

	DPARMHDR  BOTH, DECV
iopardirofs:
	BTL	opx_parmerr1[EBP], #IOV1%DIROFS
	JC	4$.S
	TESTB	AH, #PAR$GET
	JE	2$.S
	MOVL	EAX, opx_frame1[EBP]
	MOVL	EAX, SS:opn_dirofs[EAX]
	JMP	knlStrParm4##

;Here for IOPAR_ABSPOS, IOPAR_RELPOS, and IOPAR_EOFPOS - Position in file

	DPARMHDR  BOTH, DECV
iopariopos:
	BTL	opx_parmerr1[EBP], #IOV1%ABSPOS
4$:	JC	6$.S
	TESTB	AH, #PAR$GET
	JE	2$.S
	MOVL	EAX, opx_frame1[EBP]
	MOVL	EAX, SS:opn_iopos[EAX]
	JMP	knlStrParm4##

;Here for IOPAR_LENGTH - Written length of file

	DPARMHDR  BOTH, DECV
ioparlength:
	BTL	opx_parmerr1[EBP], #IOV1%LENGTH
	JC	6$.S
	TESTB	AH, #PAR$GET
	JE	2$.S
	MOVL	EAX, opx_frame1[EBP]
	MOVL	EAX, SS:opn_length[EAX]
	JMP	knlStrParm4##

;Here for IOPAR_REQALLOC or IOPAR_RQRALLOC - File allocation

	DPARMHDR  BOTH, DECV
ioparalloc:
	BTL	opx_parmerr1[EBP], #IOV1%REQALLOC
	JC	6$.S
	TESTB	AH, #PAR$GET
	JE	8$.S
	MOVL	EAX, opx_frame1[EBP]
	MOVL	EAX, SS:opn_reqalloc[EAX]
	JMP	knlStrParm4##

;Here for IOPAR_GRPSIZE - Allocation group size

	DPARMHDR  BOTH, DECV
iopargrpsize:
	BTL	opx_parmerr1[EBP], #IOV1%GRPSIZE
	JC	6$.S
	TESTB	AH, #PAR$GET
	JE	8$.S
	MOVL	EAX, opx_frame1[EBP]
	MOVL	EAX, SS:opn_grpsize[EAX]
	JMP	knlStrParm4##

6$:	MOVL	EAX, #ER_PARMV
8$:	RET

;Here for IOPAR_ADATE - Last access date/time

	DPARMHDR  BOTH, HEXV
ioparadate:
	BTL	opx_parmerr1[EBP], #IOV1%ADATE
	JC	6$.S
	TESTB	AH, #PAR$GET
	JE	8$.S
	MOVL	EAX, #opn_adate
	JMP	10$.S

;Here for IOPAR_CDATE - Creation date/time

	DPARMHDR  BOTH, HEXV
ioparcdate:
	BTL	opx_parmerr1[EBP], #IOV1%CDATE
	JC	6$.S
	TESTB	AH, #PAR$GET
	JE	8$.S
	MOVL	EAX, #opn_cdate
	JMP	10$.S

;Here for IOPAR_MDATE - Modify date/time

	DPARMHDR  BOTH, HEXV
ioparmdate:
	BTL	opx_parmerr1[EBP], #IOV1%MDATE
	JC	6$.S
	TESTB	AH, #PAR$GET
	JE	8$.S
	MOVL	EAX, #opn_mdate
10$:	ADDL	EAX, opx_frame1[EBP]
	MOVL	EDX, SS:4[EAX]
	MOVL	EAX, SS:[EAX]
	JMP	knlStrParm8##

;Here for IOPAR_PROT - File protection

	DPARMHDR  BOTH, HEXV
ioparprot:
	BTL	opx_parmerr1[EBP], #IOV1%PROT
12$:	JC	6$.S
	TESTB	AH, #PAR$GET
	JE	8$.S
	MOVL	EAX, opx_frame1[EBP]
	MOVL	EAX, SS:opn_prot[EAX]
	JMP	knlStrParm4##

14$:	RET

;Here for IOPAR_OWNER - Owner name

	DPARMHDR  BOTH, TEXT
ioparowner:
	BTL	opx_parmerr1[EBP], #IOV1%OWNER
	JC	12$.S
	TESTB	AH, #PAR$GET
	JE	14$.S
	MOVL	ESI, #opn_owner
	JMP	16$.S
16$:	ADDL	ESI, opx_frame1[EBP]
18$:	PUSHL	SS
	POPL	FS
	MOVL	EAX, #16t
	JMP	knlStrParmLng##

;Here for IOPAR_GLBID - Global device ID

	DPARMHDR  GET, HEXV
ioparglbid:
	BTL	opx_parmerr1[EBP], #IOV1%GLBID
	JC	12$.S
	LEAL	ESI, opx_glbid[EBP]
	JMP	18$.S
.PAGE
;Here for IOPAR_qqqqq

;Here for IOPAR_SETLOCK or IOPAR_CLRLOCK - Set or clear record lock

	DPARMHDR  BOTH, HEXV
ioparlock:
	TESTL	opx_parmerr1[EBP], #IOV1$SETLOCK|IOV1$CLRLOCK
	JNE	4$.S
2$:	RET

4$:	STC
6$:	MOVL	EAX, #ER_PARMV
	RET

;Here for IOPAR_FSTYPE - File system type

	DPARMHDR  GET, DECV
ioparfstype:
	BTL	opx_parmerr2[EBP], #IOV2%FSTYPE
	JC	6$.S
	MOVL	EAX, opx_frame1[EBP]
	MOVZBL	EAX, SS:opn_fstype[EAX]
	JMP	knlStrParm4##

;Here for IOPAR_SECTSIZE - Sector size

	DPARMHDR  GET, DECV
ioparsectsize:
	BTL	opx_parmerr2[EBP], #IOV2%SECTSIZE
	JC	6$.S
	MOVL	EAX, opx_frame1[EBP]
	MOVZWL	EAX, SS:opn_sectsize[EAX]
	JMP	knlStrParm4##

;Here for IOPAR_CLSSIZE - Cluster size

	DPARMHDR  GET, DECV
ioparclssize:
	BTL	opx_parmerr2[EBP], #IOV2%CLSSIZE
	JC	6$.S
	MOVL	EAX, opx_frame1[EBP]
	MOVZBL	EAX, SS:opn_clssize[EAX]
	JMP	knlStrParm4##

;Here for IOPAR_TTLSPACE - Total space

	DPARMHDR  GET, DECV
ioparttlspace:
	BTL	opx_parmerr2[EBP], #IOV2%TTLSPACE
	JC	6$.S
	MOVL	EAX, opx_frame1[EBP]
	MOVL	EAX, SS:opn_ttlspace[EAX]
	JMP	knlStrParm4##

;Here for IOPAR_AVLSPACE - Available space

	DPARMHDR  GET, DECV
ioparavlspace:
	BTL	opx_parmerr2[EBP], #IOV2%AVLSPACE
10$:	JC	6$.S
	MOVL	EAX, opx_frame1[EBP]
	MOVL	EAX, SS:opn_avlspace[EAX]
	JMP	knlStrParm4##

;Here for IOPAR_NUMHEAD - Number of heads

	DPARMHDR  GET, DECV
ioparnumhead:
	BTL	opx_parmerr2[EBP], #IOV2%NUMHEAD
	JC	10$.S
	MOVL	EAX, opx_frame1[EBP]
	MOVZWL	EAX, SS:opn_numhead[EAX]
	JMP	knlStrParm4##

;Here for IOPAR_NUMSECT - Number of sectors

	DPARMHDR  GET, DECV
ioparnumsect:
	BTL	opx_parmerr2[EBP], #IOV2%NUMSECT
	JC	10$.S
	MOVL	EAX, opx_frame1[EBP]
	MOVZWL	EAX, SS:opn_numsect[EAX]
	JMP	knlStrParm4##

;Here for IOPAR_NUMCYLN - Number of cylinders

	DPARMHDR  GET, DECV
ioparnumcyln:
	BTL	opx_parmerr2[EBP], #IOV2%NUMCYLN
	JC	10$.S
	MOVL	EAX, opx_frame1[EBP]
	MOVZWL	EAX, SS:opn_numcyln[EAX]
	JMP	knlStrParm4##
.PAGE
	DATA

xfpccb:	    .LONG 'CCB*'	;XFP CCB
	    .BLKB ccb_SIZE-4
xfpdpdbhead:.LONG 0		;Offset of first XFP DPDB

	LKEEND
