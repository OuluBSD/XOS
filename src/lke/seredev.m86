	.TITLE	seredev - Serial port device driver for PCI 16550 devices

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

.IF NE 0
;Define IO ports for the serial ports (8250 except where noted)

P_COM1BASE  =!3F8h	;        Base value for COM1
P_COM2BASE  =!2F8h	;        Base value for COM2
P_COMRDATA  =!0h	;(read)  Receive data
P_COMXDATA  =!0h	;(write) Transmit data
P_COMBRLSB  =!0h	;(both)  Baud rate LDB value
P_COMINTENB =!1h	;(write) Interrupt enable register
P_COMBRMSB  =!1h	;(both)  Baud rate MSB value
P_COMINTID  =!2h	;(read)  Interrupt ID register
P_COMFIFOCTL=!2h	;(write) FIFO control register (16550 only)
P_COMLINECON=!3h	;(both)  Line control register
P_COMMODMCON=!4h	;(both)  Modem control register
P_COMLINESTS=!5h	;(read)  Line status register
P_COMMODMSTS=!6h	;(read)  Modem status register
P_COMSCRATCH=!7h	;(both)  Scratch register

;Define bits in the FIFO control register (16550 only)

CMFC$RCVRLVL=!0C0h	;Receiver trigger level
CMFC$DMA    =! 08h	;DMA mode select
CMFC$XMITRST=! 04h	;Xmit FIFO reset
CMFC$RCVRRST=! 02h	;Receiver FIFO reset
CMFC$ENABLE =! 01h	;FIFO enable

;Define bits in the interrupt enable register (P_COMINTENB)

CMINT$MODSTS=!08h	;Modem status change
CMINT$RCVSTS=!04h	;Receiver status change
CMINT$TRNEMP=!02h	;Transmitter holding register empty
CMINT$RCVAVL=!01h	;Received data available

;Define bits in the modem control register (P_COMMODMCON)

CMMDC$OUT2=!08h		;Output 2
CMMDC$OUT1=!04h		;Output 1
CMMDC$RTS =!02h		;RTS
CMMDC$DTR =!01h		;DTR
.ENDC

	.PROC	80486
	.INCLUD	XOSINC:\XMAC\XOS.PAR
	.INCLUD	XOSINC:\XMAC\XOSX.PAR
	.INCLUD	XOSINC:\XMAC\XOSTIME.PAR
	.INCLUD	XOSINC:\XMAC\XOSERR.PAR
	.INCLUD	XOSINC:\XMAC\XOSTRM.PAR
	.INCLUD	XOSINC:\XMAC\XOSXTRM.PAR
	.INCLUD	XOSINC:\XMAC\PCAT.PAR
	.INCLUD	XOSINC:\XMAC\XOSLKE.PAR
	.INCLUD	XOSINC:\XMAC\XOSXLKE.PAR

MAJV   =!1t
MINV   =!0t
EDITNUM=!0t

	LKEHEAD	SEREDEV, MAJV, MINV, EDITNUM, LKETYPE_DEVICE

;Define fork function codes

FF_RDATA  =!0t		;Received data
FF_LINESTS=!4t		;Line status report
FF_MODMSTS=!8t		;Modem status report

;Define offsets for device dependent part of the TDB for serial ports

$$$=!tdb_SIZE
BLK tdb_saoutrtak , 4t		;Output ring buffer taker pointer
BLK tdb_saoutrput , 4t		;Output ring buffer putter pointer
BLK tdb_saoutrsize, 4t		;Size of the output ring buffer
BLK tdb_saoutring , 4t		;Offset of start of output ring buffer
BLK tdb_salncon   , 1t		;Bits for line control register
BLK tdb_samdcon   , 1t		;Bits for modem control registesr
BLK tdb_saintenb  , 1t		;Bits for interrupt enable register
BLK tdb_saouttoc  , 1t		;Output time-out counter
BLK tdb_sahungcnt , 4t		;Hung output count
BLK tdb_saclkfreq , 4t		;Clock frequency
BLK tdb_sauart    , 1t		;UART type
BLK tdb_safifo    , 1t		;Fifo fill count (for use by fork routine)
BLK tdb_sageckobrk, 1t		;Non-zero if break should invoke exec mode Gecko
BLK               , 1t
BLK tdb_saintrbsl , 4t		;Interrupt ring buffer stop level
BLK tdb_saintrbpl , 4t		;Interrupt ring buffer panic level
BLK tdb_saintrheld, 4t		;Interrupt ring buffer held character count
BLK tdb_saintrlost, 4t		;Interrupt ring buffer lost character count
BLK tdb_saintrcnt , 4t		;Interrupt ring buffer item count
BLK tdb_saintrtak , 4t		;Interrupt ring buffer taker pointer
BLK tdb_saintrput , 4t		;Interrupt ring buffer putter pointer
BLK tdb_saintrsize, 4t		;Size of the interrupt ring buffer
BLK tdb_saintring , 0t		;The interrupt level input ring buffer
tdb_saSIZE=!{$$$+3}&0FFFCh

;Define values for the tdb_sauart byte (UART type)

TRMU_8250 =!1t			;Old 8250
TRMU_16450=!2t			;8250A/16450
TRMU_16550=!3t			;16550 with 16 byte FIFO

	CODE

	.LONG	0		;tf_virtacs   = -44.
	.LONG	knlIFnDev##	;tf_enable    = -40. - Enable video
	.LONG	knlIFnDev##	;tf_disable   = -36. - Disable video
	.LONG	knlIFnDev##	;tf_curtyp    = -32. - Get/set cursor type
	.LONG	knlIFnDev##	;tf_curpos    = -28. - Get/set cursor position
	.LONG	knlIFnDev##	;tf_dsppag    = -24. - Set display page
	.LONG	knlIFnDev##	;tf_scroll    = -20. - Scroll window
	.LONG	knlIFnDev##	;tf_getatc    = -16. - Get attribute and char.
	.LONG	knlIFnDev##	;tf_setatc    = -12. - Set attribute and char.
	.LONG	knlIFnDev##	;tf_setchr    =  -8. - Set character only
	.LONG	knlIFnDev##	;tf_attrib    =  -4. - Get or set attributes
serdsp:	.LONG	knlRtnZero##	;tf_transfer  =   0. - Transfer device
	.LONG	knlRtnZero##	;tf_opena     =   4. - Open additional
	.LONG	seropen		;tf_open1     =   8. - Open first time
	.LONG	knlRtnZero##	;tf_stop      =  12. - Stop output
	.LONG	serclrout	;tf_clrout    =  16. - Clear output buffer
	.LONG	serechchr	;tf_echchr    =  20. - Echo character
	.LONG	sereoutchr	;tf_doutchr   =  24. - Direct output character
	.LONG	sereoutblk	;tf_doutblk   =  28. - Direct output block
	.LONG	sereoutstr	;tf_doutstr   =  32. - Direct output string
	.LONG	knlIFnDev##	;tf_qoutchr   =  36. - Queued output character
	.LONG	serqoutblk	;tf_qoutblk   =  40. - Queued output block
	.LONG	serqoutstr	;tf_qoutstr   =  44. - Queued output string
	.LONG	seridle		;tf_idle      =  48. - Set to idle state
	.LONG	serresume	;tf_resume    =  52. - Resume output
	.LONG	knlIFnDev##	;tf_mapscn    =  56. - Map screen buffer
	.LONG	notmapped	;tf_rmset     =  60. - Setup terminal for real
				;			 mode
	.LONG	knlRtnZero##	;tf_rmupd     =  64. - Update page 0 for real
				;			 mode
	.LONG	ret006		;tf_rmuse     =  68. - Use real mode page 0 data
	.LONG	serdspmode	;tf_d86mode   =  72. - Get or set display mode
	.LONG	sereaddunit	;tf_addunit   =  76. - Add unit
	.LONG	knlIFnDev##	;tf_ssread    =  80. - Screen symbiont read
	.LONG	knlIFnDev##	;tf_sswrite   =  84. - Screen symbiont write
	.LONG	knlIFnDev##	;tf_sswitch   =  88. - Screen symbiont switch
	.LONG	knlIFnDev##	;tf_ssdone    =  92. - Screen symbiont done
	.LONG	knlIFnDev##	;tf_ssopnal   =  96. - Open alarm window
	.LONG	knlIFnDev##	;tf_sswrtalm  = 100. - Write to alarm window
	.LONG	knlIFnDev##	;tf_ssclsalm  = 104. - Close alarm window
	.LONG	knlRtnZero##	;tf_ssstatus  = 108. - Report screen status to
				;			 screen symbiont
	.LONG	knlIFnDev##	;tf_ssgetmod  = 112. - Get display page modified
				;			 bits
	.LONG	knlIFnDev##	;tf_dspcur    = 116. - Low level display cursor
				;			 routine
	.LONG	knlRtnZero##	;tf_updpbms   = 120. - Update page changed bits
				;			 for single msect
	.LONG	sersetdtr	;tf_setdtr    = 124. - Set or clear DTR output
	.LONG	sersetrts	;tf_setrts    = 128. - Set or clear RTS output
	.LONG	sergetdsb	;tf_getdsb    = 132. - Get data set bits
	.LONG	serfinout	;tf_finout    = 136. - Ensure output is finished
	.LONG	ret006		;tf_imodechng = 140. - Input mode change
	.LONG	ret006		;tf_omodechng = 144. - Output mode change
	.LONG	knlIFnDev##	;tf_mapphys   = 148. - Map physical display


skeydsp:.LONG	knlIFnDev##	;kf_vdinb    =  0. - INB instruction for
				;		       keyboad in real mode
	.LONG	knlIFnDev##	;kf_vdoutb   =  4. - OUTB instruction for
				;		       keyboard in real mode
	.LONG	knlIFnDev##	;kf_keyint   =  8. - Attempt to execut keyboard
				;		       interrupt routine in real
				;		       mode
	.LONG	knlIFnDev##	;kf_clrkeyi  = 12. - Clear keyboard interrupt
	.LONG	ret006		;kf_tolites  = 16. - Update keyboard lites

;Device characteristics for SERA devices

	DATA

	.MOD	4
seredctbl:
 DCHARBGN  1, knlDCharValCom##
 DCHARENT  CLASS   , TEXT, ,  8, knlDcMsgClass##    , knlDcGetClass##   , knlDcSetClass##   , 0
 DCHARENT  TYPE    , TEXT, ,  4, knlDcMsgType##     , knlDcGet4Byte##   , 0                 , dcb_typename
 DCHARENT  UART    , TEXT, ,  8, msguart            , getuart           , 0                 , tdb_sauart
 DCHARENT  SESSION , TEXT, ,  8, knlTrmMsgSession## , knlTrmGetSession##, knlTrmSetSession##, 0
 DCHARENT  MSGDST  , STR , , 16, knlTrmMsgMsgDst##  , knlTrmGetText##   , knlTrmSetText##   , tdb_msgdst
 DCHARENT  PROGRAM , STR , , 16, knlTrmMsgProgram## , knlTrmGetText##   , knlTrmSetText##   , tdb_program
 DCHARENT  ACCESS  , TEXT, ,  4, knlDcMsgAccess##   , knlTrmGet4Byte##  , knlTrmSetAccess## , tdb_access
 DCHARENT  PASSWORD, STR , ,  8, knlTrmMsgPWrd##    , knlTrmGetText##   , knlTrmSetText##   , tdb_password
 DCHARENT  GECKOBRK, TEXT, ,  4, msggeckobrk        , getgeckobrk       , setgeckobrk       , 0
 DCHARENT  IOUTFLOW, TEXT, ,  8, knlTrmMsgIOFlow##  , knlTrmGetOFlow##  , setoflow          , tdb_iflow
 DCHARENT  IINFLOW , TEXT, ,  8, knlTrmMsgIIFlow##  , knlTrmGetIFlow##  , setiiflow         , tdb_iflow
 DCHARENT  IRATE   , DECV, ,  4, msgirate           , knlTrmGet4Byte##  , setirate          , tdb_ioutr
 DCHARENT  IOUTRATE, DECV, ,  4, msgioutrate        , knlTrmGet4Byte##  , setirate          , tdb_ioutr
 DCHARENT  IINRATE , DECV, ,  4, msgiinrate         , knlTrmGet4Byte##  , knlRtnZero##      , tdb_ioutr
 DCHARENT  CLKFREQ , DECV, ,  4, msgclkfreq         , knlTrmGet4Byte##  , setclkfreq        , tdb_saclkfreq
 DCHARENT  IDBITS  , DECV, ,  1, msgidbits          , getdbits          , setdbits          , tdb_icsize
 DCHARENT  ISBITS  , DECV, ,  1, msgisbits          , getsbits          , setsbits          , tdb_icsize
 DCHARENT  IPARITY , TEXT, ,  8, msgiparity         , getparity         , setparity         , tdb_ipar
 DCHARENT  IMODEM  , TEXT, ,  8, knlTrmMsgIModem##  , knlTrmGetModem##  , knlTrmSetModem##  , tdb_imodem
 DCHARENT  OUTFLOW , TEXT, ,  8, knlTrmMsgOFlow##   , knlTrmGetOFlow##  , setoflow          , tdb_flow
 DCHARENT  INFLOW  , TEXT, ,  8, knlTrmMsgIFlow##   , knlTrmGetIFlow##  , setiflow          , tdb_flow
 DCHARENT  RATE    , DECV, ,  4, msgrate            , knlTrmGet4Byte##  , setrate           , tdb_outr
 DCHARENT  OUTRATE , DECV, ,  4, msgoutrate         , knlTrmGet4Byte##  , setrate           , tdb_outr
 DCHARENT  INRATE  , DECV, ,  4, msginrate          , knlTrmGet4Byte##  , knlRtnZero##      , tdb_outr
 DCHARENT  DBITS   , DECV, ,  1, msgdbits           , getdbits          , setdbits          , tdb_csize
 DCHARENT  SBITS   , DECV, ,  1, msgsbits           , getsbits          , setsbits          , tdb_csize
 DCHARENT  PARITY  , TEXT, ,  8, msgparity          , getparity         , setparity         , tdb_par
 DCHARENT  MODEM   , TEXT, ,  8, knlTrmMsgModem##   , knlTrmGetModem##  , knlTrmSetModem##  , tdb_modem
 DCHARENT  BUS     , DECV, ,  4, xospciMsgBus##     , knlTrmGet1Byte##  , 0                 , tdb_pcibus
 DCHARENT  SLOT    , DECV, ,  4, xospciMsgSlot##    , knlTrmGet1Byte##  , 0                 , tdb_pcislot
 DCHARENT  INDEX   , DECV, ,  4, msgindex           , knlTrmGet1Byte##  , 0                 , tdb_index
 DCHARENT  IOREG   , HEXV, ,  4, knlDcMsgIoReg##    , knlTrmGet4Byte##  , 0                 , tdb_bioreg
 DCHARENT  INT     , DECV, ,  1, knlDcMsgInt##      , knlTrmGet1Byte##  , 0                 , tdb_intlvl
 DCHARENT  INTRS   , DECV, ,  2, msgintrs           , knlTrmGet4Byte##  , 0                 , tdb_saintrsize
 DCHARENT  INTRSL  , DECV, ,  2, msgintrsl          , knlTrmGet4Byte##  , knlTrmSet4Byte##  , tdb_saintrbsl
 DCHARENT  INTRPL  , DECV, ,  2, msgintrpl          , knlTrmGet4Byte##  , knlTrmSet4Byte##  , tdb_saintrbpl
 DCHARENT  INTRHELD, DECV, ,  4, msgintrheld        , knlTrmGet4Byte##  , knlTrmSet4Byte##  , tdb_saintrheld
 DCHARENT  INTRLOST, DECV, ,  4, msgintrlost        , knlTrmGet4Byte##  , knlTrmSet4Byte##  , tdb_saintrlost
 DCHARENT  INRBS   , DECV, ,  2, knlTrmMsgInRBS##   , knlTrmGet4Byte##  , 0                 , tdb_irsize
 DCHARENT  INRBSL  , DECV, ,  2, knlTrmMsgInRBSL##  , knlTrmGet4Byte##  , knlTrmSet4Byte##  , tdb_irbsl
 DCHARENT  INRBPL  , DECV, ,  2, knlTrmMsgInRBPL##  , knlTrmGet4Byte##  , knlTrmSet4Byte##  , tdb_irbpl
 DCHARENT  INRBHELD, DECV, ,  4, knlTrmMsgInRBHeld##, knlTrmGet4Byte##  , knlTrmSet4Byte##  , tdb_irheld
 DCHARENT  INRBLOST, DECV, ,  4, knlTrmMsgInRBLost##, knlTrmGet4Byte##  , knlTrmSet4Byte##  , tdb_irlost
 DCHARENT  INLBS   , DECV, ,  2, knlTrmMsgInLBS##   , knlTrmGet4Byte##  , 0                 , tdb_ibsize
 DCHARENT  OUTRS   , DECV, ,  2, msgoutrs           , knlTrmGet4Byte##  , 0                 , tdb_saoutrsize
 DCHARENT  CHAROUT , DECV, ,  4, knlTrmMsgCharOut## , knlTrmGet4Byte##  , knlTrmSet4Byte##  , tdb_charout
 DCHARENT  CHARIN  , DECV, ,  4, knlTrmMsgCharIn##  , knlTrmGet4Byte##  , knlTrmSet4Byte##  , tdb_charin
 DCHARENT  KBCHAR  , DECV, ,  4, knlTrmMsgKbChar##  , knlTrmGet4Byte##  , knlTrmSet4Byte##  , tdb_kbchar

	CODE

msguart:    DCHARINFO  {UART type}
msggeckobrk:DCHARINFO  {Invoke exec mode GECKO on break}
msgirate:   DCHARINFO  {Initial baud rate}
msgioutrate:DCHARINFO  {Initial output baud rate}
msgiinrate: DCHARINFO  {Initial input baud rate (not used)}
msgclkfreq: DCHARINFO  {UART clock frequence}
msgidbits:  DCHARINFO  {Initial number of data bits}
msgisbits:  DCHARINFO  {Initial number of stop bits}
msgiparity: DCHARINFO  {Initial parity handling}
msgrate:    DCHARINFO  {Current baud rate}
msgoutrate: DCHARINFO  {Current output baud rate}
msginrate:  DCHARINFO  {Current input baud rate (not used)}
msgdbits:   DCHARINFO  {Current number of data bits}
msgsbits:   DCHARINFO  {Current number of stop bits}
msgparity:  DCHARINFO  {Current parity handling}
msgintrs:   DCHARINFO  {Interrupt ring buffer size}
msgintrsl:  DCHARINFO  {Interrupt ring buffer stop level}
msgintrpl:  DCHARINFO  {Interrupt ring buffer panic level}
msgintrheld:DCHARINFO  {Interrupt ring buffer held count}
msgintrlost:DCHARINFO  {Interrupt ring buffer lost count}
msgoutrs:   DCHARINFO  {Output ring buffer size}
msgindex:   DCHARINFO  {Port index on device}
.PAGE
	.SBTTL	sereinit - Serial port driver initialization routine

	INITSUB	sereinit

sereinit:
	MOVL	EBX, #'SERE'		;Get terminal driver name
	MOVL	EDX, #serdsp		;Get offset of dispatch table
	CALL	knlTrmNewDriver##	;Register this terminal driver
	JC	4$
	CLRL	EAX
	CLRL	EDX
	MOVL	ECX, #codetop
4$:	RET

	CODE
.PAGE
	.SBTTL	sereaddunit - Subroutine to add serial port unit

;Subroutine to add serial port unit
;	c(AL) = Major unit number
;	c(AH) = Minor unit number
;	CALL	sereaddunit
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

$$$=!0
FRM sau_unit   , 4t	;Unit number
FRM sau_slot   , 4t	;PCI slot number
FRM sau_bus    , 4t	;PCI bus number
FRM sau_index  , 4t	;Index on card
FRM sau_intcode, 4t	;Interrupt routine offset
FRM sau_ioreg  , 4t	;Base IO register number
FRM sau_intlvl , 4t	;Interrupt level
FRM sau_intrbs , 4t	;Interrupt ring buffer size
FRM sau_inrbs  , 4t	;Input ring buffer size
FRM sau_inlbs  , 4t	;Input line buffer size
FRM sau_outrbs , 4t	;Output ring buffer size
FRM sau_pcib   , 4t
FRM sau_pcidata, 4t
FRM sau_inxmask, 4t
sau_SIZE=!$$$		;  lengths

;Description block for addunitchar

	DATA

	.MOD	4
sereaublk:
 DCHARBGN  2, knlDCharValCom##
 DCHARENT  UNIT   , DECV, , 4, 0, 0, retclc      , 0
 DCHARENT  TYPE   , TEXT, , 4, 0, 0, retclc      , 0
 DCHARENT  SLOT   , DECV, , 4, 0, 0, sereauslot  , 0
 DCHARENT  BUS    , DECV, , 4, 0, 0, sereaubus   , 0
 DCHARENT  INDEX  , DECV, , 4, 0, 0, sereauindex , 0
 DCHARENT  INTRS  , DECV, , 2, 0, 0, sereauintrbs, 0
 DCHARENT  INRBS  , DECV, , 2, 0, 0, sereauinrbs , 0
 DCHARENT  OUTRS  , DECV, , 2, 0, 0, sereauoutrbs, 0
 DCHARENT  INLBS  , DECV, , 2, 0, 0, sereauinlbs , 0

	CODE

sereaddunit::
	ENTER	sau_SIZE, 0		;Allocate our stack frame
	MOVB	sau_unit[EBP], AL	;Store unit number

	CALL	knlGetXRes##		;Get exec memory resource

	CLRL	EAX
	MOVL	sau_bus[EBP], EAX	;Default BUS is 0
	DECL	EAX
	MOVL	sau_slot[EBP], EAX	;Store illegal values for slot and
	MOVL	sau_index[EBP], EAX	;  index
	MOVL	sau_intrbs[EBP], #IIRSIZE ;Store default buffer sizes
	MOVL	sau_inrbs[EBP], #IRSIZE
	MOVL	sau_inlbs[EBP], #IBSIZE
	MOVL	sau_outrbs[EBP], #ORSIZE
	MOVL	EBX, #sereaublk		;Point to our description block
	MOVB	AL, #0			;Fail if bad name
	CALL	knlAddUnitChar##
	JC	auerr			;If error
	MOVL	sau_pcib[EBP], #0
	CMPL	sau_index[EBP], #-1	;Was INDEX specified?
	JE	20$			;No - fail
	CMPL	sau_slot[EBP], #-1	;Was SLOT specified?
	JNE	12$			;Yes - only look at the specified card

;Here to search for the first unused serial port of the correct type


10$:	PUSHL	SS
	LEAL	EAX, sau_pcib[EBP]
	PUSHL	EAX
	PUSHL	#7
	PUSHL	#0
	PUSHL	#2
	PUSHL	SS
	CALL	xospciFindByClass##
	TESTL	EAX, EAX
	JS	auerr
	MOVL	EAX, sau_pcib[EBP]
	MOVL	EAX, dct_pcidata[EAX]
	MOVL	sau_pcidata[EBP]

	MOVL	EAX, sau_inxmask[EBP]	;Is the port we want already in use?
	TESTL	sau_pcidata[EBP], EAX
	JNE	10$			;Yes - keep looking
	JMP	havedev			;Found it

;Here to only use the specified bus/slot

12$:	PUSHL	SS
	LEAL	EAX, sau_pcib[EBP]
	PUSHL	EAX
	PUSHL	sau_bus[EBP]
	PUSHL	sau_slot[EBP]
	PUSHL	#0
	PUSHL	SS
	LEAL	EAX, sau_pcidata[EBP]
	PUSHL	EAX
	CALL	xospciFindByAddr##
	TESTL	EAX, EAX
	JS	auerr
	MOVL	EAX, sau_inxmask[EBP]	;Is the port we want already in use?
	TESTL	sau_pcidata[EBP], EAX
	JE	havedev			;No - go on
	MOVL	EAX, #ER_PDADF		;Yes - fail
	JMP	auerr

;;;; SHOULD WE CHECK THE VENDOR AND DEVICE ID????

;Here if a required parameter is missing

20$:	MOVL	EAX, #ER_CHARM
	JMP	auerr

;Here if the device does not exist

22$:	MOVL	EAX, #ER_PDNAV		;Fail if does not exist
	JMP	auerr

;Here if have incorrect device type

24$:	MOVL	EAX, #ER_PDTYP
auerr:	PUSHL	EAX
	CALL	knlGiveXRes##		;Give up the exec memory resource
	POPL	EAX
	MOVL	EBX, #QSTS$DONE
	CLRL	ECX
	LEAVE
	TOFORK
	STC
	RET
.PAGE
;Here with the device located

havedev:PUSHL	sau_pcib[EBP]
	MOVL	EAX, sau_index[EBP]	;Get the base IO register address
	LEAL	EAX, 0x0C[EAX*4]
	PUSHL	EAX
	PUSHL	SS
	LEAL	EAX, sau_ioreg[EBP]
	PUSHL	EAX
	CALL	xospciReadCfgReg##
	TESTL	EAX, EAX
	JS	auerr
	TESTB	sau_ioreg[EBP], #0x01	;Is it really an IO address?
	JNE	2$			;Yes - go on
	MOVL	EAX, #ER_CFGER		;No - fail
	JMP	auerr

2$:	ANDL	sau_ioreg[EBP], #0xFFFFFFFC
	PUSHL	sau_pcib[EBP]
	PUSHL	#0x3C			;Get the IRQ number
	PUSHL	SS
	LEAL	EAX, sau_intlvl[EBP]
	PUSHL	EAX
	CALL	xospciReadCfgReg##
	TESTL	EAX, EAX
	JS	auerr
	ANDL	sau_intlvl[EBP], #0x7F
	MOVB	CL, sau_intlvl[EBP]	;Get interrupt number
	ORB	CL, #80h		;Indicate interrupt can be shared
	CALL	knlChkIRqAvl##		;See if the vector is available
	JC	auerr			;If not available
	MOVL	EDX, sau_ioreg[EBP]
	LEAL	ECX, 7[EDX]
	CALL	knlChkIORegs##
	JC	auerr
	MOVB	CL, sau_intlvl[EBP]	;Get interrupt number
	MOVL	ECX, #SERINTSZ		;Get space for interrupt code
	CALL	knlGetXCode##
	JC	auerr
	MOVL	sau_intcode[EBP], EDI	;Remember where code is going
	MOVL	ESI, #sereint		;Copy prototype interrupt routine
	SHRL	ECX, #2
	PUSHL	DS
	POPL	ES
	CLD
	RMOVSL	[EDI], [ESI]
	MOVL	ECX, sau_intrbs[EBP]	;Get total size for our TDB
	ADDL	ECX, ECX
	ADDL	ECX, #tdb_saSIZE
	ADDL	ECX, sau_outrbs[EBP]
	MOVB	DH, #0FFh		;No secondary unit number
	MOVB	DL, sau_unit[EBP]	;Get primary unit number
	MOVL	EAX, sau_inlbs[EBP]	;Get input line buffer and ring sizes
	SHLL	EAX, #16t
	MOVW	AX, sau_inrbs[EBP]
	MOVL	EBX, #'SERE'		;Get type name
	CALL	knlTrmMakeTdb##		;Make our TDB
	JNC	6$			;OK
	JMP	auerr

;Here with TDB allocated

6$:	MOVB	tdb_ifdsp[ESI], #TID$QOUT ;Indicate can do queued output
	MOVL	tdb_saclkfreq[ESI], #115200t ;Store default clock frequency
	MOVL	tdb_ddisp[ESI], #serdsp ;Store offset of our dispatch table
	MOVL	tdb_fdisp[ESI], #serfork ;Store offset of fork routine
	MOVL	tdb_devchar[ESI], #seredctbl ;Store offset of device
					     ;  characteristics table
	MOVL	EAX, sau_ioreg[EBP]
	MOVL	tdb_bioreg[ESI], EAX
	MOVL	EAX, sau_index[EBP]
	MOVB	tdb_index[ESI], AL
	MOVL	EAX, sau_slot[EBP]
	TESTL	EAX, EAX
	JNS	8$
	PUSHL	sau_pcib[EBP]
	CALL	xospciGetSlot##
8$:	MOVB	tdb_pcislot[ESI], AL
	MOVL	EAX, sau_bus[EBP]
	CMPL	sau_slot[EBP], #0
	JNS	10$
	PUSHL	sau_pcib[EBP]
	CALL	xospciGetBus##
10$:	MOVB	tdb_pcibus[ESI], AL
	MOVL	sereltdb, ESI		;Link into our list of TDBs
	MOVL	EAX, sereltdb
	TESTL	EAX, EAX
	JE	16$
	MOVL	tdb_nexts[EAX], ESI
	JMP	18$

16$:	MOVL	sereftdb, ESI
	MOVL	EBX, #seroas		;Setup our once-a-second routine
	CALL	knlSetupOAS##
18$:	MOVL	EDI, sau_intcode[EBP]	;Fix up the interrupt code
	MOVL	{fix1-sereint}+1[EDI], ESI
	MOVL	EAX, EDI
	SUBL	EAX, #sereint
	SUBL	{sereintexit-sereint}+1[EDI], EAX
	CMPB	sau_intlvl[EBP], #9t
	JGE	20$
	ADDL	ES:{sereintexit-sereint}+1[EDI], #knlIntDoneDiff##
20$:	MOVL	EAX, sau_outrbs[EBP]	;Store size of our output buffer
	MOVL	tdb_saoutrsize[ESI], EAX
	LEAL	EAX, tdb_saintring[ESI] ;Store offset of our output buffer
	ADDL	EAX, sau_intrbs[EBP]
	ADDL	EAX, sau_intrbs[EBP]
	MOVL	tdb_saoutring[ESI], EAX
	MOVL	EAX, sau_intrbs[EBP]	 ;Store size of the interrupt ring
	MOVL	tdb_saintrsize[ESI], EAX ;  buffer
	MOVL	EDX, sau_ioreg[EBP]
	MOVL	EAX, #TRMR_init		;Get baud rates
	MOVL	tdb_iinpr[ESI], EAX	;Store idle baud rate
	MOVL	tdb_ioutr[ESI], EAX
	CALL	setbaudrate		;Set baud rate in the hardware
	MOVB	tdb_icsize[ESI], #{TRMS_init<4}|TRMD_init
	MOVB	tdb_csize[ESI], #{TRMS_init<4}|TRMD_init
	MOVB	tdb_ipar[ESI], #TRMP_init
	MOVB	tdb_par[ESI], #TRMP_init
	CALL	setlhw			;Set line bits for the hardware
	LEAL	EBX, tdb_name[ESI]	;Register our IO registers
	MOVL	EDX, tdb_bioreg[ESI]
	LEAL	ECX, 7[EDX]
	CALL	knlRegIORegs##
	JC	auerr
	LEAL	EDX, tdb_name[ESI]
	MOVL	EBX, sau_intcode[EBP]	;Get address of interrupt routine
	LEAL	EAX, sereintexit-sereint[EBX] ;And of final JMP
	MOVB	CL, sau_intlvl[EBP]	;Get interrupt number
	MOVB	tdb_intlvl[ESI], CL	;Remember it
	ORB	CL, #80h		;Indicate interrupt is sharable
	MOVB	CH, #DT_TRAP+PL_0	;Set up our interrupt vector
	CALL	knlSetInt##
	JC	30$			;But we already check and this is OK!

	MOVL	EDX, tdb_bioreg[ESI]
	A2IOP	P_COMINTENB		;Point to interrupt enable regsiter
	MOVB	AL, #07h		;Enable all but dataset interrupts
	MOVB	tdb_saintenb[ESI], AL
	OUTB	[DX]
	IOPAUSE
	A2IOP	P_COMMODMCON-P_COMINTENB ;Point to modem control reg
	MOVB	AL, #0Ch		;Clear all modem outputs and set master
	OUTB	[DX]			;  interrupt enable bit
	MOVB	tdb_samdcon[ESI], AL	;Remember current state of these bits
	PUSHL	sau_pcib[EBP]		;Set the PCI data bit that indicates
	PUSHL	sau_inxmask[EBP]	;  that the port is in use
	CALL	xospciSetData##
	CALL	knlGiveXRes##		;Give up the exec memory resource
	PUSHL	#1			;Assume this will work
	MOVL	ECX, #8			;Try to reset it up to 8 times!
22$:	MOVL	EDX, tdb_bioreg[ESI]
	INB	[DX]			;Read the input data register
	IOPAUSE
	A2IOP	P_COMLINESTS-P_COMRDATA	;Read the line status register
	INB	[DX]
	IOPAUSE
	A2IOP	P_COMMODMSTS-P_COMLINESTS
	INB	[DX]			;Read the modem status register
	IOPAUSE
	A2IOP	P_COMINTID-P_COMMODMSTS	;Read the interrupt ID register
	INB	[DX]
	IOPAUSE
	INB	[DX]			;Twice
	TESTB	AL, #01			;Is the device idle?
	JNE	24$			;Yes
	LOOP	ECX, 22$		;No - try again if should
	MOVL	[ESP], #0		;Can't make it idle - return 0
24$:	MOVL	EAX, tdb_saintrsize[ESI] ;Calculate interrupt buffer stop
	CMPL	EAX, #1024t		 ;  level
	JBE	26$
	MOVL	EAX, #512t
26$:	SHRL	EAX, #2
	MOVL	tdb_saintrbsl[ESI], EAX
	SHRL	EAX, #2			;Calculate interrupt buffer panic level
	MOVL	tdb_saintrbpl[ESI], EAX
	MOVL	EAX, tdb_irsize[ESI]	;Calculate input buffer stop level
	CMPL	EAX, #1024t
	JBE	28$
	MOVL	EAX, #512t
28$:	SHRL	EAX, #2
	MOVL	tdb_irbsl[ESI], EAX
	SHRL	EAX, #2			;Calculate input buffer panic level
	MOVL	tdb_irbpl[ESI], EAX
	MOVB	tdb_sauart[ESI], #TRMU_16550
	MOVL	ECX, sau_intlvl[EBP]	;Enable our interrupt
	CALL	knlEnableInt##
	CLRL	EAX
audone:	POPL	ECX			;Get our return value
	MOVL	EBX, #QSTS$DONE
	LEAVE
	TOFORK
	RET

30$:	CRASH	CSIV			;[Can't Set Interrupt Vector]
.PAGE
;Subroutine called by addunitchar for the "BUS" characteristic

sereaubus:
	CMPL	EAX, #0xFF		;Valid value?
	JA	knlBadCharV##
	MOVL	sau_bus[EBP], EAX
	CLC
	RET

;Subroutine called by addunitchar for the "SLOT" characteristic

sereauslot:
	CMPL	EAX, #0x1F		;Valid value?
	JA	knlBadCharV##		;No
	MOVL	sau_slot[EBP], EAX	;Yes
	CLC
	RET
 
;Subroutine called by addunitchar for the "INDEX" characteristic

sereauindex:
	TESTL	EAX, EAX		;Valid value?
	JE	knlBadCharV##
	CMPL	EAX, #0x02
	JA	knlBadCharV##		;No
	MOVL	sau_index[EBP], EAX	;Yes
	LEAL	ECX, -1[EAX]
	MOVL	EAX, #1
	SHLL	EAX, CL
	MOVL	sau_inxmask[EBP], EAX
	CLC
	RET
 
;Subroutine called by addunitchar for the "OUTRBS" characteristic

sereauoutrbs:
	ANDB	AL, #0FCh		;Make sure even number of longs
	MOVL	sau_outrbs[EBP], EAX
6$:	CMPL	EAX, #1000h		;Is this a reasonable value?
8$:	JAE	knlBadCharV##		;No - fail
retclc:	CLC
	RET

;Subroutine called by addunitchar for the  "INTRBS" characteristic

sereauintrbs:
	ANDB	AL, #0FCh		;Make sure even number of longs
	CMPL	EAX, #40t		;Is it too small?
	JA	10$			;No
	MOVB	AL, #40t		;Yes - use minimum
10$:	MOVL	sau_intrbs[EBP], EAX
	JMP	6$			;Continue

;Subroutine called by addunitchar for the "INRBS" characteristic

sereauinrbs:
	ANDB	AL, #0FCh		;Make sure even number of longs
	CMPL	EAX, #40t		;Is it too small?
	JA	12$			;No
	MOVB	AL, #40t		;Yes - use minimum
12$:	MOVL	sau_inrbs[EBP], EAX
	JMP	6$

;Subroutine called by addunitchar for the "INLBS" characteristic

sereauinlbs:
	ANDB	AL, #0FCh		;Make sure even number of longs
	CMPL	EAX, #40t		;Is it too small?
	JA	14$			;No
	MOVB	AL, #40t		;Yes - use minimum
14$:	MOVL	sau_inlbs[EBP], EAX
	JMP	6$
.PAGE
;Here to get the value of the GECKOBRK characteristic

getgeckobrk:
	CALL	knlGetTdb##
	JC	2$
	MOVL	EAX, #'No'
	CMPB	tdb_sageckobrk[ESI], #0
	JE	2$
	MOVL	EAX, #'Yes'
	RET

;Here to get the value of the UART characteristic

getuart:CALL	knlGetTdb##
	JC	2$
	MOVZBL	EBX, [ESI+EBX]
	MOVL	EAX, CS:urtname+0-8[EBX*8]
	MOVL	EDX, CS:urtname+4-8[EBX*8]
2$:	RET

	.MOD	4
urtname:.LONG	'8250', 0	;TRMU_8250  = 1 - Original 8250
	.LONG	'1645', '0'	;TRMU_16450 = 2 - 8250A/16450
	.LONG	'1655', '0'	;TRMU_16550 = 3 - 16550

;Here to get the value of the RATE characteristic

getrate:CALL	knlGetTdb##
	JC	4$
	MOVL	EAX, tdb_ioutr[ESI]
	CLRL	EDX
4$:	RET

;Here to get the value of the DBITS characteristic

getdbits:
	CALL	knlGetTdb##
	JC	4$
	MOVZBL	EAX, [ESI+EBX]
	ANDB	AL, #0Fh
	CLRL	EDX
	RET

;Here to get the value of the SBITS characteristic

getsbits:
	CALL	knlGetTdb##
	JC	8$
	MOVZBL	EAX, [ESI+EBX]
	SHRB	AL, #4
	CLRL	EDX
	RET

;Here to get the value of the PARITY characteristic

getparity:
	CALL	knlGetTdb##
	JC	8$
	MOVZBL	EBX, [ESI+EBX]
	ANDB	BL, #0Fh
	MOVL	EAX, CS:parname+0-8[EBX*8]
	MOVL	EDX, CS:parname+4-8[EBX*8]
8$:	RET

	.MOD	4
parname:.LONG	'None', 0	;TRMP_NONE  = 1 - No parity bit
	.LONG	'Mark', 0	;TRMP_MARK  = 2 - Mark parity
	.LONG	'Spac', 'e'	;TRMP_SPACE = 3 - Space parity
	.LONG	'Odd' , 0	;TRMP_ODD   = 4 - Odd parity
	.LONG	'Even', 0	;TRMP_EVEN  = 5 - Even parity
PARNAMESZ=!{$-parname}/8
.PAGE
;Here to set the value of the GECKOBRK characteristic

setgeckobrk:
	CALL	knlGetTdb##
	JC	4$
	CALL	knlGetYesNo##
	JC	4$
	JE	2$
	MOVB	tdb_sageckobrk[ESI], #0
	RET

2$:	MOVB	tdb_sageckobrk[ESI], #1
4$:	RET

;Here to set the value of the CLKFREQ characteristic - This is the value of
;  the UART clock / 16.

setclkfreq:
	CMPL	EAX, #1000t		;Make sure not too small
	JB	knlBadCharV##
	CMPL	EAX, #50000000t		;Or too big
	JA	knlBadCharV##
	CALL	knlGetTdb##
	JC	4$
	MOVL	tdb_saclkfreq[ESI], EAX ;Store new value
	MOVL	EAX, tdb_outr[ESI]	;Update the hardware
	JMP	setbaudrate2

;Here to set the value of the IOUTFLOW or OUTFLOW characteristic

setoflow:
	CALL	knlGetTdb##
	JC	8$
	PUSHL	EBX
	MOVL	ECX, #knlTRMOFLOWTBLSZ##
	MOVL	EBX, #knlTrmOFlowTbl##
	CALL	knlGetDcVal2##
	POPL	EBX
	JC	8$
	ANDB	[ESI+EBX], #0Fh
	ORB	[ESI+EBX], AL		;Store new value
	CMPL	EBX, #tdb_iflow	;Setting initial value?
	JE	4$			;Yes - finished now
	JMP	setinte			;No - make sure interrupt enables are
					;  right

;Here to set the value of the IINFLOW characteristic

setiiflow::
	CALL	knlGetTdb##
	JC	8$
	PUSHL	EBX
	MOVL	ECX, #knlTRMIFLOWTBLSZ##
	MOVL	EBX, #knlTrmIFlowTbl##
	CALL	knlGetDcVal2##
	POPL	EBX
	JC	8$
	ANDB	[ESI+EBX], #0F0h
	ORB	[ESI+EBX], AL		;Store new value
8$:	RET

;Here to set the value of the IINFLOW or INFLOW characteristic

setiflow::
	CALL	setiiflow
	JC	4$
	TESTB	AL, #TFC$IDTR		;Have DTR flow control?
	JE	10$			;No
	MOVL	EBX, #sersetdtr		;Yes - get function to set DTR
	JMP	12$

10$:	TESTB	AL, #TFC$IRTS		;Have RTS flow control?
	JE	ret002			;No - finished here
	MOVL	EBX, #sersetrts		;Yes - get function to set RTS
12$:	MOVB	AL, #0FF		;Assume not holding output
	TESTB	tdb_stsout[ESI], #TSO$HOLDS|TSO$HOLDP
					;Are we holding output now?
	JE	18$			;No
	NOTB	AL			;Yes
18$:	TESTB	tdb_flow[ESI], #TFC$IREV ;Is the flow control state reversed?
	JE	20$			;No
	NOTB	AL			;Yes
20$:	CALLI	EBX			;Set or clear the modem control bit
	CLC
ret002:	RET
.PAGE
;Here to set the value of the RATE or OUTRATE characteristic

setrate:CALL	knlGetTdb##
	JC	ret002
	CALL	actrate			;Calculate actual rate
setbaudrate:
	MOVL	tdb_outr[ESI], EAX	;Store this as the current rate
	MOVL	tdb_inpr[ESI], EAX
setbaudrate2:
	CMPL	EAX, #134t		;Did he say 134 baud?
	JNE	4$			;No
	MOVL	EAX, #857t		;Yes - make it 134.5!
	JMP	6$

4$:	MOVL	ECX, EAX		;Calculate rate divisor
	SHRL	EAX, #1
	ADDL	EAX, tdb_saclkfreq[ESI]
	CLRL	EDX
	DIVL	ECX
6$:	PUSHL	EAX			;Save divisor value
	MOVL	EDX, tdb_bioreg[ESI]	;Point to the line control register
	A2IOP	P_COMLINECON
	MOVB	AL, tdb_salncon[ESI]	;Enable access to the baud rate
	ORB	AL, #80h		;  registers
	CLI				;Can't have interrupts while have the
	OUTB	[DX]			;  baud rate registers enabled
	IOPAUSE
	POPL	EAX			;Restore divisor value
	A2IOP	P_COMBRLSB-P_COMLINECON	;Point to divisor LSB register
	OUTB	[DX]			;Output LSB
	IOPAUSE
	MOVB	AL, AH			;Get high byte
	A2IOP	P_COMBRMSB-P_COMBRLSB	;Point to divisor MSB register
	OUTB	[DX]			;Output MSB
	IOPAUSE				;Point to the line control
	A2IOP	P_COMLINECON-P_COMBRMSB	;  register again
	MOVB	AL, tdb_salncon[ESI]	;Enable access to the data registers now
	OUTB	[DX]
	STI				;Interrupts are OK now
	CLC
	RET

;Here to set the value of the IRATE or IOUTRATE characteristic

setirate:
	CALL	knlGetTdb##
	JC	8$
	CALL	actrate			;Calculate actual rate
	MOVL	tdb_ioutr[ESI], EAX	;And store this as the initial rate
	MOVL	tdb_iinpr[ESI], EAX
	CLC
8$:	RET
.PAGE
;Subroutine to calculate actual baud rate
;	c{EAX} = Desired baud rate
;	CALL	actrate
;	c{EAX} = Actual baud rate

actrate:TESTL	EAX, EAX		;Cannot be 0!
	JNE	4$
	INCL	EAX
4$:	CMPL	EAX, tdb_saclkfreq[ESI]
	JBE	6$
	MOVL	EAX, tdb_saclkfreq[ESI]
6$:	CMPL	EAX, #134t		;Did he say 134 baud?
	JE	12$			;Yes - leave it at that
	MOVL	ECX, EAX		;No - calculate rate divisor
	SHRL	EAX, #1
	ADDL	EAX, tdb_saclkfreq[ESI]
	CLRL	EDX
	DIVL	ECX
	TESTL	EAX, EAX		;Make sure not zero
	JNE	8$
	INCL	EAX
8$:	CMPL	EAX, #0FFFFh		;Make sure divisor is not too big
	JBE	10$
	MOVL	EAX, #0FFFFh
10$:	MOVL	ECX, EAX		;Now calculate actual baud rate that
	MOVL	EAX, tdb_saclkfreq[ESI] ;  this divisor will generate
	CLRL	EDX
	DIVL	ECX
12$:	RET
.PAGE
;Here to set the value of the DBITS characteristic

setdbits:
	CALL	knlGetTdb##
	JC	12$
	CMPL	EAX, #8	;Make sure legal value (must be 5, 6, 7, or 8)
	JA	knlBadCharV##
	CMPL	EAX, #5
	JB	knlBadCharV##
	ANDB	[ESI+EBX], #0F0h
	ORB	[ESI+EBX], AL	;Store new value
	JMP	10$		;Continue

;Here to set the value of the SBITS characteristic

setsbits:
	CALL	knlGetTdb##
	JC	12$
	CMPL	EAX, #2	;Make sure legal value (must be 1 or 2)
	JA	knlBadCharV##
	TESTL	EAX, EAX
	JE	knlBadCharV##
	SHLB	AL, #4
	ANDB	[ESI+EBX], #0Fh
	ORB	[ESI+EBX], AL	;Store new value
10$:	CMPL	EBX, #tdb_icsize ;Changing current value?
	JNE	setlhw	;Yes - go do that
12$:	RET

;Here to set the value of the PARITY characteristic

setparity:
	CALL	knlGetTdb##
	JC	12$
	PUSHL	EBX
	MOVL	ECX, #PARNAMESZ
	MOVL	EBX, #parname
	CALL	knlGetDcVal1##		;Search the keyword table
	POPL	EBX
	JC	12$			;If error
	INCL	EAX
	ANDB	[ESI+EBX], #0F0h
	ORB	[ESI+EBX], AL		;Store new value
	CMPL	EBX, #tdb_ipar 	;Changing current value?
	JE	12$			;No - finished
setlhw:	MOVB	AL, tdb_csize[ESI] 	;Yes - must update hardware state
	ANDB	AL, #0Fh		;Get number of data bits
	SUBB	AL, #5			;Get value for interface
	TESTB	tdb_csize[ESI], #20h	;Want two stop bits?
	JE	16$			;No
	ORB	AL, #04h		;Yes
16$:	MOVZBL	EBX, tdb_par[ESI]	;Get current parity value
	ANDB	BL, #0Fh
	ORB	AL, CS:parvalue-1[EBX]	;Add in the parity bits
	MOVB	tdb_salncon[ESI], AL	;Remember these bits
	MOVL	EDX, tdb_bioreg[ESI]	;Point to the line control register
	A2IOP	P_COMLINECON
	OUTB	[DX]
	RET

parvalue:
	.BYTE	00h		;TRMP_NONE  = 1 - No parity bit
	.BYTE	28h		;TRMP_MARK  = 2 - Mark parit
	.BYTE	38h		;TRMP_SPACE = 3 - Space parity
	.BYTE	08h		;TRMP_ODD   = 4 - Odd parity
	.BYTE	18h		;TRMP_EVEN  = 5 - Even parity

notmapped:
	CLRL	EAX			;Return 0 as mapped size
	CLRL	EDX			;And 0 as offset
	RET
.PAGE
	.SBTTL	Serial port interrupt routines

;The following is a prototype for the interrupt service routine entry code
;  - this code is copied for each unit by sereddunit

;WARNING: The overall structure of this code must not be changed. The
;         interrupt chaining logic counts on it!

sereint:INTENTR
fix1:	MOVL	EDI, #0			;Get offset of TDB for this port
4$:	MOVL	EDX, tdb_bioreg[EDI]	;Get base IO register for serial port
	A2IOP	P_COMINTID		;Point to interrupt ID register
	INB	[DX]
	SHRL	EAX, #1
	JC	sereintexit
	ANDL	EAX, #03h
	CALLI	CS:comidsp[EAX*4]	;Dispatch on the interrupt
	JMP	4$

sereintexit:
	JMP	knlIntDoneHigh##	;All finished here (this will be
SERINTSZ=!$-sereint			;  modified to point to knlIntDoneLow
					;  if necessary)

;Interrupt dispatch table

	.MOD	4
comidsp:.LONG	mdmchg		;000 - Modem status change
	.LONG	xmtdone		;010 - Xmit done
	.LONG	inpavl		;100 - Input available
	.LONG	inperr		;110 - Input error
.PAGE
;Here for input error interrupt

inperr:	A2IOP	P_COMLINESTS-P_COMINTID	;Point to line status register
	MOVB	AH, #FF_LINESTS		;Indicate have line status bits
	INB	[DX]			;Get the data byte
	TESTB	AL, #10h		;Do we have a break?
	JE	2$			;No
	CMPB	tdb_sageckobrk[EDI], #0 ;Yes - should we invoke Gecko?
	JE	2$			;No - go process the break
sereGeckoBrk::
	INT3				;Yes
	RET				;Discard the break after calling Gecko

;Here for input available interrupt

inpavl:	SUBL	EDX, #2			;Point to data register
	MOVB	AH, #FF_RDATA		;Indicate have received data
	INB	[DX]			;Get the data byte
2$:	MOVL	EBX, tdb_saintrsize[EDI] ;Room for more in the interrupt
	CMPL	tdb_saintrcnt[EDI], EBX  ;  ring buffer?
	JAE	10$			;No - forget it!
toring:	MOVL	EBX, tdb_saintrput[EDI] ;Yes - get putter pointer
	MOVW	tdb_saintring[EDI+EBX*2], AX ;Store code in ring
	INCL	EBX			;Bump pointer
	CMPL	EBX, tdb_saintrsize[EDI] ;Past end of ring?
	JB	4$			;No
	CLRL	EBX			;Yes - reset pointer
4$:	MOVL	tdb_saintrput[EDI], EBX ;Update pointer
	INCL	tdb_saintrcnt[EDI]	;Bump count
	CALL	knlReqFork##		;Request fork
6$:	MOVL	EAX, tdb_saintrsize[EDI] ;Is the interrupt ring past the stop
	SUBL	EAX, tdb_saintrbsl[EDI]  ;  level?
	JLE	8$
	CMPL	tdb_saintrcnt[EDI], EAX
	JA	12$			;Yes
8$:	RET

;Here if the interrupt ring is full - discard the character

10$:	INCL	tdb_saintrlost[EDI]	;Count the lost character
	JMP	14$			;Continue

;Here if interrupt ring is past the stop level - try to stop input if we can

12$:	INCL	tdb_saintrheld[EDI]	;Count this
14$:	TESTB	tdb_flow[EDI], #TFC$IDTR ;Is DTR flow control enabled?
	JE	16$			;No
	ANDB	tdb_samdcon[EDI], #~CMMDC$DTR ;Yes - clear DTR
	JMP	20$

;Here DTR flow control is not enabled

16$:	TESTB	tdb_flow[EDI], #TFC$IRTS ;Is RTS flow control enabled?
	JE	22$			;No
	MOVB	AL, #0			;Yes - assume should clear RTS
	TESTB	tdb_flow[EDI], #TFC$IREV ;Is the sense reversed?
	JE	18$			;No
	ORB	tdb_samdcon[EDI], #CMMDC$RTS ;Yes - set RTS
	JMP	20$

18$:	ANDB	tdb_samdcon[EDI], #~CMMDC$RTS ;Yes - clear RTS
20$:	MOVL	EDX, tdb_bioreg[EDI]
	A2IOP	P_COMMODMCON		;Point to modem control reg
	MOVB	AL, tdb_samdcon[EDI]	;Set the hardware register
	OUTB	[DX]
	JMP	28$

;Here if CTS/RTS flow control is not enabled

22$:	TESTB	tdb_flow[EDI], #TFC$IXONXOFF ;Is XON/XOFF flow control
					     ;  enabled?
	JE	30$			;No - just quietly discard character!
	TESTB	tdb_stsinp+1[EDI], #{TSI$INTHELD|TSI$IRBHELD}>8
					;Is input held off now?
	JE	24$			;No
	MOVL	EAX, tdb_saintrsize[EDI] ;Yes - is the interrupt ring past the
	SUBL	EAX, tdb_saintrbpl[EDI]  ;  panic level?
	JLE	28$
	CMPL	tdb_saintrcnt[EDI], EAX
	JBE	28$			;No - nothing more needed yet
24$:	TESTB	tdb_stsout[EDI], #TSO$OUTA ;Yes - is output active?
	JE	26$			;No
	TESTB	tdb_stsout+1[EDI], #TSO$OUTD>8 ;Yes - is output done?
	JNE	26$			;Yes
	ORB	tdb_stsout+1[EDI], #TSO$FRCXOFF>8 ;No - indicate need XOFF
	JMP	28$				  ;  next

;Here if output is not active - output XOFF now

26$:	MOVB	AL, #XOF		;Get the XOFF character
	MOVL	EDX, tdb_bioreg[EDI]	;Point to the data register
	OUTB	[DX]			;Output the character
	ORB	tdb_stsout[EDI], #TSO$OUTA
	ANDB	tdb_stsout+1[EDI], #~{TSO$OUTD>8t}
	MOVB	tdb_saouttoc[ESI], #2	;Start the output time-out
28$:	ORB	tdb_stsinp+1[EDI], #TSI$INTHELD>8 ;Indicate input held off
30$:	RET
.PAGE
;Here for xmit done interrupt

xmtdone:ORB	tdb_stsout+1[EDI], #TSO$OUTD>8 ;Indicate output is done
2$:	CALL	knlReqFork##		;Request fork
	RET				;Continue

;Here for modem status change interrupt

mdmchg:	A2IOP	P_COMMODMSTS-P_COMINTID	;Point to modem status register
	MOVB	AH, #FF_MODMSTS		;Indicate have modem status bits
	INB	[DX]			;Get the modem status byte
	MOVL	EBX, tdb_saintrsize[EDI] ;Room for more in the interrupt
	CMPL	tdb_saintrcnt[EDI], EBX  ;  ring buffer?
	JB	6$			;Yes - store data

;Here if interrupt ring is full.  We always want to report the current modem
;  status to fork level, so instead of discarding this item, we remove the
;  last item from the ring and always store this one.

	INCL	tdb_saintrlost[EDI]	;Count the lost character
	DECL	tdb_saintrput[EDI]	;Remove the last item from the ring
	JNS	4$
	DECL	EBX
	MOVL	tdb_saintrput[EDI], EBX
4$:	DECL	tdb_saintrcnt[EDI]
6$:	MOVL	EBX, tdb_saintrput[EDI] ;Get putter pointer
	MOVW	tdb_saintring[EDI+EBX*2], AX ;Store code in ring
	INCL	EBX			;Bump pointer
	CMPL	EBX, tdb_saintrsize[EDI] ;Past end of ring?
	JB	8$			;No
	CLRL	EBX			;Yes - reset pointer
8$:	MOVL	tdb_saintrput[EDI], EBX ;Update pointer
	INCL	tdb_saintrcnt[EDI]	;Bump count
	JMP	2$
.PAGE
	.SBTTL	serfork - Serial port fork routine

;Here at fork level for serial port

serfork:MOVL	ESI, EDI		;Get TDB offset in right register
2$:	CMPB	tdb_saintrcnt[ESI], #0 ;Anything in the interrupt ring?
	JE	6$			;No - nothing more to do here
	MOVZBL	EDX, tdb_saintrtak[ESI] ;Yes - get taker pointer
	MOVZWL	EAX, tdb_saintring[ESI+EDX*2] ;Get data
	INCL	EDX			;Bump pointer
	CMPB	DL, tdb_saintrsize[ESI] ;Past end of ring?
	JB	4$			;No
	CLRL	EDX			;Yes
4$:	MOVB	tdb_saintrtak[ESI], DL
	DECB	tdb_saintrcnt[ESI]	;Reduce ring count
	MOVZBL	EBX, AH			;Get function
	CALLI	forkdsp[EBX]		;Dispatch on the function
	TESTB	tdb_stsinp+1[ESI], #TSI$INTHELD>8 ;Is input held off now?
	JE	2$			;No
	MOVL	EAX, tdb_saintrsize[ESI] ;Is the interrupt ring buffer more
	SHRL	EAX, #2			 ;  than 1/4 full?
	CMPL	tdb_saintrcnt[ESI], EAX
	JA	2$			;Yes
	ANDB	tdb_stsinp+1[ESI], #~{TSI$INTHELD>8} ;No - indicate not held
	TESTB	tdb_stsinp+1[ESI], #TSI$IRBHELD>8 ;Is the input ring buffer
						  ;  held too?
	JNE	2$			;Yes
	ORB	tdb_stsout+1[ESI], #TSO$FRCXON>8 ;No - indicate need XON
	BTSL	tdb_stsout[ESI], #TSO%OUTA ;Is output active?
	JNE	2$			;Yes
	ORB	tdb_stsout+1[ESI], #TSO$OUTD>8 ;No - fake up output done
	JMP	2$

;Here with all input stuff handled

6$:	TESTB	tdb_stsout+1[ESI], #TSO$OUTD>8 ;Is output done?
	JNE	seroutrdy		;Yes - go handle that
	RET				;No - nothing needed here

;Fork level function dispatch table

	DATA

forkdsp:.LONG	frkrdata	;FF_RDATA   = 0 - Received data
	.LONG	frklinsts	;FF_LINESTS = 4 - Line status report
	.LONG	frkmodsts	;FF_MODMSTS = 8 - Modem status report

	CODE

	.SBTTL	frkrdata - Received data

;Here at fork level for received data

frkrdata:
	BTSL	EAX, #KB%IMAGE		;Set bit to indicate ASCII value
	TESTB	tdb_stsinp+1[ESI], #TSI$CARDET>8 ;Do we have carrier now?
	JE	knlTrmInp##		;No
	BTSL	EAX, #KB%CARDET		;Yes - indicate that
	JMP	knlTrmInp##		;Process the input character
.PAGE
	.SBTTL	frklinsts - Line status report

;Here at fork level for line status report

frklinsts:
	TESTB	AL, #10h		;Did we have a break?
	JE	ret004			;No - ignore the rest of this
	JMP	knlTrmBreak##		;Yes - report it

	.SBTTL	frkmodsts - Modem status report

;Here at fork level for modem status report

frkmodsts:
	MOVL	EDI, tdb_dcb[ESI]	;Do we have a DCB?
	TESTL	EDI, EDI
	JE	2$			;No
	CMPL	dcb_trmcsvect[EDI], #0	;Yes - does he want an MC signal?
	JNE	knlTrmMCSignal##	;Yes - this overrides everything else
2$:	TESTB	AL, #04h		;No - do we have ring indicate?
	JE	4$			;No
	PUSHL	EAX			;Yes
	CALL	knlTrmRing##		;Report it
	POPL	EAX
4$:	TESTB	AL, #08h		;Has carrier detect changed state?
	JE	10$			;No
	PUSHL	EAX			;Yes
	TESTB	AL, #80h		;Do we have carrier now?
	JE	6$			;No
	CALL	knlTrmCarDet##		;Yes
	JMP	8$

6$:	CALL	knlTrmCarLoss##
8$:	POPL	EAX
10$:	TESTB	AL, #02h		;Has DSR changed state?
	JE	16$			;No
	PUSHL	EAX			;Yes
	TESTB	AL, #20h		;Is DSR on now?
	JE	12$			;No
	CALL	knlTrmDsrOn##		;Yes
	JMP	14$

12$:	CALL	knlTrmDsrOff##
14$:	POPL	EAX
16$:	TESTB	AL, #01h		;Has CTS changed state?
	JE	ret004			;No
	TESTB	AL, #10h		;Is CTS on now?
	JE	knlTrmCtsOff##		;No
	JMP	knlTrmCtsOn##		;Yes
.PAGE
	.SBTTL	seroutrdy - Subroutine to process output ready interrupt

;Here if TSO$OUTD is not set when get here.  The only way this can happen if
;  for the interrupt level code to clear it after the test in serfork!  This
;  can happen if we decide to output an X-OFF character after an output done
;  interrupt but before the fork routine executes.  This is unlikely, but
;  possible!

2$:	STI				;Just enable interrupts and ignore this
ret004:	RET

;Subroutine to process output ready interrupt from terminal

seroutrdy:
	CLI				;No interrupts here
	TESTB	tdb_stsout+1[ESI], #TSO$OUTD>8 ;Is output still done?
	JE	2$			;No!
	ANDB	tdb_stsout+1[ESI], #~{TSO$OUTD>8} ;Yes - but not now
	STI				;Interrupts are OK now
	TESTB	tdb_stsout[ESI], #TSO$OUTA ;Is output still active?
	JE	12$			;No - no more output wanted
serresume:				;Yes - need immediate XOFF or XON?
	TESTB	tdb_stsout+1[ESI], #{TSO$FRCXOFF|TSO$FRCXON}>8
	JNE	16$			;Yes
	TESTB	tdb_stsout[ESI], #TSO$HOLDS|TSO$HOLDP
					;No - should we hold output?
	JNE	22$			;Yes
	TESTB	tdb_flow[ESI], #TFC$ODSR|TFC$OCTS
					;Using DSR or CTS flow control?
	JE	6$			;No
	MOVB	AH, #20			;Yes - assume using DSR
	TESTB	tdb_flow[ESI], #TFC$OCTS ;Right?
	JE	4$			;Yes
	MOVB	AH, #10			;No - using CTS
4$:	MOVL	EDX, tdb_bioreg[ESI]	;Read the modem status register
	A2IOP	P_COMMODMSTS
	INB	[DX]
	TESTB	AL, AH			;Is the bit set?
	JE	20$			;No - hold output
6$:	CMPL	tdb_outrcnt[ESI], #0	;Have anything to output now?
	JE	knlTrmDoEcho##		;No - go see if need to echo now

;;	CMPB	tdb_sauart[ESI], #TRMU_16550
;;	JNE	9$
;;	CMPL	tdb_outrcnt[ESI], #17	;Would outputting 16 bytes leave only
;;					; one?
;;	JG	8$			;No, its safe to do 16 bytes
;;	MOVB	tdb_safifo[ESI], #15	;Must leave 2 bytes to output in case
;;					; of 16550 FIFO bug.
;;	JMP	9$
;;
;;8$:
;; *****
;;9$:

	MOVL	EBX, tdb_saoutrtak[ESI] ;Yes - get taker pointer
	MOVL	EAX, tdb_saoutring[ESI]
	MOVB	AL, [EAX+EBX]		;Get character
	INCL	EBX			;Bump pointer
	CMPL	EBX, tdb_saoutrsize[ESI] ;At end of ring?
	JB	8$			;No
	CLRL	EBX			;Yes
8$:	MOVL	tdb_saoutrtak[ESI], EBX
	DECL	tdb_outrcnt[ESI]
10$:	MOVL	EDX, tdb_bioreg[ESI]	;Point to the data register
	OUTB	[DX]			;Output the character
	ORB	tdb_stsout[ESI], #TSO$OUTA

;;	CMPB	tdb_sauart[ESI], #TRMU_16550
;;	JNE	20$
;; *****
;;20$:

	MOVB	tdb_saouttoc[ESI], #2	;Start the output time-out
	INCL	tdb_charout[ESI]	;Count the character
12$:	TESTB	tdb_stsout+1[ESI], #TSO$FLOUT>8 ;Are we flushing output?
	JNE	14$			;Yes - don't wake up unless empty
	CMPL	tdb_outrcnt[ESI], #12t  ;Is output buffer almost empty?
	JBE	knlTrmOutDone##		;Yes - see if should wake up someone
	RET				;No

14$:	CMPL	tdb_outrcnt[ESI], #0	;Is output buffer EMPTY?
	JE	knlTrmOutDone##		;Yes - go wake up someone
	RET

;Here if need immediate XOFF output

16$:	MOVB	AL, #XOF		;Assume need XOFF character
	TESTB	tdb_stsout+1[ESI], #TSO$FRCXON>8 ;Right?
	JE	18$			;Yes
	MOVB	AL, #XON		;No - need XON
18$:	ANDB	tdb_stsout+1[ESI], #~{{TSO$FRCXOFF|TSO$FRCXON}>8}
	JMP	10$			;Output the character

;Here if should hold output

20$:	ORB	tdb_stsout[ESI], #TSO$HOLDS
22$:	ANDB	tdb_stsout[ESI], #{~TSO$OUTA}&0FFh
	MOVB	tdb_saouttoc[ESI], #0	;Stop the output time-out
	RET				;Output not active now
.PAGE
	.SBTTL	tf_open - seropen - Open device

;Here for the tf_open dispatch - Open device - this routine sets the baud rate
;  to the initial value and sets up the DTR and RTS modem control outputs as
;  follows:
;    RTS: reverse RTS flow control: CLEAR
;         otherwise:                SET
;    DTR: reverse DTR flow control: CLEAR
;         full modem control:       CLEAR
;         otherwise:                SET
;	c{ESI} = Offset of TDB
;	CALL	seropen
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

seropen:CALL	seridle			;Make sure set to idle state
	BTL	SS:xffCmd##, #O%PHYS	;Are we open for physical I/O?
	JC	setinte			;Yes - skip ctl lines
	MOVB	AL, #0FFh		;Assume should set RTS
	TESTB	tdb_flow[ESI], #TFC$IRTS ;RTS flow control?
	JE	2$			;No - always set RTS
	TESTB	tdb_flow[ESI], #TFC$IREV ;Is it reversed?
	JE	2$			;No
	NOTB	AL			;Yes
2$:	CALL	sersetrts
	MOVB	AL, #0			;Assume should clear DTR
	TESTB	tdb_modem[ESI], #TMC$MODEM ;Modem control?
	JNE	6$			;Yes - clear DTR
	TESTB	tdb_flow[ESI], #TFC$IDTR ;No - DTR flow control?
	JE	4$			;No - set DTR
	TESTB	tdb_flow[ESI], #TFC$IREV ;Yes - is it reversed
	JNE	6$			;Yes - clear DTR
4$:	NOTB	AL			;No - set DTR
6$:	CALL	sersetdtr
setinte:MOVB	tdb_saintenb[ESI], #07h ;Assume no dataset interrupts
	TESTB	tdb_modem[ESI], #TMC$MODEM ;Modem control?
	JNE	8$			;Yes - enable dataset interrupts
	TESTB	tdb_flow[ESI], #TFC$ODSR|TFC$OCTS
					;No - using dataset inputs for output
					;  flow control?
	JE	10$			;No
8$:	MOVB	tdb_saintenb[ESI], #0Fh ;Yes - enable dataset interrupts
10$:	MOVL	EDX, tdb_bioreg[ESI]	;Point to interrupt enable register
	A2IOP	P_COMINTENB
	MOVB	AL, tdb_saintenb[ESI]
	OUTB	[DX]			;Enable desired interrupts
	ANDB	tdb_stsinp+1[ESI], #~{TSI$CARDET>8} ;Assume don't have carrier
	A2IOP	P_COMMODMSTS-P_COMINTENB ;Point to the modem status register
	INB	[DX]			;Get modem status bits
	TESTB	AL, #80h		;Do we have carrier?
	JE	12$			;No
	ORB	tdb_stsinp+1[ESI], #TSI$CARDET>8 ;Yes - indicate that
12$:	RET
.PAGE
	.SBTTL	tf_idle - seridle - Set to idle state

;Here for the tf_idle dispatch - Set to idle state
;	c{ESI} = Offset of TDB
;	CALL	seridle
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

seridle:MOVB	AL, tdb_icsize[ESI]	;Set parameters to their idle values
	MOVB	tdb_csize[ESI], AL
	MOVB	AL, tdb_ipar[ESI]
	MOVB	tdb_par[ESI], AL
	MOVL	EAX, tdb_ioutr[ESI]
	MOVL	tdb_outr[ESI], EAX
	CALL	setbaudrate		;Set the hardware to match
	MOVL	EAX, tdb_iinpr[ESI]
	MOVL	tdb_inpr[ESI], EAX
	CLRL	EAX
	TESTB	tdb_stsmisc[ESI], #TSM$SESSION ;Are sessions enabled?
	JE	4$			;No - take ctl lines down
	MOVB	AL, #0FFh		;Yes - put ctl lines up
4$:	PUSHL	EAX
	CALL	sersetrts
	POPL	EAX
	TESTB	tdb_modem[ESI], #TMC$MODEM ;Is this a modem line?
	JE	6$			;No
	CLRL	EAX			;Yes - force DTR low!
6$:	CALL	sersetdtr
	JMP	setlhw			;And return
.PAGE
	.SBTTL	tf_doutchr - sereoutchr - Output character at main program level

;Here for the tf_doutchr dispatch - Output character at main program level
;	c(AL)  = Character to output
;	c{ESI} = Offset of TDB
;	CALL	sereoutchr
;	c{EAX} = Error code
;	c{ECX} = Number of bytes output
;	c{EBX} = Status bits

sereoutchr:
	TESTB	tdb_stsout[ESI], #TSO$JUNK|TSO$JUNKX|TSO$HOLDS|TSO$HOLDP
					;Should we junk or hold output?
	JNE	6$			;Yes
2$:	CALL	soutchr			;No - store character in output buffer
	JC	10$
4$:	CLRL	EAX			;Indicate output 1 character
	MOVL	ECX, #1
	MOVL	EBX, #QSTS$DONE
ret006:	RET				;Finished

;Here if should junk or hold character

6$:	TESTB	tdb_stsout[ESI], #TSO$JUNK|TSO$JUNKX ;Holding output?
	JNE	4$			;No
10$:	CLRL	EAX			;Nothing output, indicate should
	CLRL	ECX			;  wait
	MOVL	EBX, #QSTS$WAIT
	RET
.PAGE
	.SBTTL	tf_doutblk - sereoutblk - Output block at main program level

;Here for the tf_doutblk dispatch - Output block at main program level - must
;  be called at main program level raised to fork level
;	c{ECX}    = Number of characters to output
;	c{ES:EBX} = Address of block
;	c{ESI}    = Offset of TDB
;	CALL	sereoutblk
;	c{EAX} = Error code
;	c{ECX} = Number of bytes output
;	c{EBX} = Status bits

sereoutblk:
	CLRL	EDX			;Initialize count
2$:	FROMFORK
	IFFAULT	outae
	MOVB	AL, ES:[EBX]		;Get character
	TOFORK
	TESTB	tdb_stsout[ESI], #TSO$JUNK|TSO$JUNKX|TSO$HOLDS|TSO$HOLDP
					;Are we junking or holding output?
	JNE	6$			;Yes
4$:	CALL	soutchr			;No - store character in output buffer
	JC	outwt			;If no more room
	INCL	EBX			;Bump pointer
	INCL	EDX			;Bump count
	LOOP	ECX, 2$			;Loop if more to output
outdn:	MOVL	EBX, #QSTS$DONE
outrtn:	MOVL	ECX, EDX		;Get count in right register
	CLRL	EAX
	RET				;Finished

;Here if junking or holding output

6$:	TESTB	tdb_stsout[ESI], #TSO$JUNK|TSO$JUNKX ;Holding output?
	JE	outwt			;Yes
8$:	ADDL	EDX, ECX		;No - report that everything was ouput
	JMP	outdn

;Here if should hold output

outwt:	MOVL	EBX, #QSTS$WAIT		;Indicate should wait
	JMP	outrtn

;Here if address error

	FAULTHDR
outae:	TOFORK
	MOVL	EAX, #ER_ADRER
	MOVL	ECX, EDX
	MOVL	EBX, #QSTS$DONE
	RET
.PAGE
	.SBTTL	tf_doutstr - sereoutstr - Output string at main program level

;Here for the tf_doutstr dispatch - Output string at main program level
;	c{ES:EBX} = Address of string
;	c{ESI}    = Offset of TDB
;	CALL	sereoutstr
;	c{EAX} = Error code
;	c{ECX} = Number of bytes output
;	c{EBX} = Status bits

sereoutstr:
	CLRL	EDX			;Initialize count
2$:	FROMFORK
	IFFAULT	outae
	MOVB	AL, ES:[EBX]		;Get character
	TOFORK
	TESTB	AL, AL			;End?
	JE	outdn			;Yes
	TESTB	tdb_stsout[ESI], #TSO$JUNK|TSO$JUNKX|TSO$HOLDS|TSO$HOLDP
					;No - junking or holding output?
	JNE	8$			;Yes
4$:	CALL	soutchr			;No - store character in output buffer
	JC	outwt			;If must wait
6$:	INCL	EBX			;Bump pointer
	INCL	EDX			;Bump count
	JMP	2$			;Continue

;Here if junking or holding output (get here at fork level)

8$:	TESTB	tdb_stsout[ESI], #TSO$JUNK|TSO$JUNKX ;Holding output?
	JE	outwt			;Yes
	JMP	6$			;No - must be junking output
.PAGE
	.SBTTL	tf_qoutblk - serqoutblk - Output block at fork level

;Here for the tf_qoutblk dispatch - Output block at fork level
;	c{ECX}    = Number of characters to output
;	c{ES:EBX} = Address of block
;	c{ESI}    = Offset of TDB
;	CALL	serqoutblk
;	c{EAX} = Error code
;	c{ECX} = Amount output
;	c{ESI} = Status bits

serqoutblk:
	CLRL	EDX			;Initialize count
	ORB	tdb_stsout+1[ESI], #TSO$QOWAIT>8
	TESTB	tdb_omode+3[ESI], #{TOM$PLP1|TOM$PLP2}>24t
					;Want PLP packet output?
	JNE	20$			;Yes
2$:	TESTB	tdb_stsout[ESI], #TSO$JUNK|TSO$JUNKX|TSO$HOLDS|TSO$HOLDP
					;Are we junking or holding output?
	JNE	12$			;Yes
	IFFAULT	knlRtnAdrEr##
4$:	MOVB	AL, ES:[EBX]		;Get character
	CALL	soutchr			;Store character in output buffer
	JC	14$			;If no more room
	INCL	EBX			;Bump pointer
	INCL	EDX			;Bump count
	LOOP	ECX, 4$			;Loop if more to output
6$:	CLRL	EAX			;Return 0
8$:	MOVL	ECX, EDX		;Get count in right register
10$:	MOVL	EBX, #QSTS$DONE
	ANDB	tdb_stsout+1[ESI], #~{TSO$QOWAIT>8}
	RET				;Finished

;Here if want to junk or hold output

12$:	TESTB	tdb_stsout[ESI], #TSO$JUNK|TSO$JUNKX ;Holding output?
	JE	14$			;Yes
	ADDL	ECX, EDX		;No - just return and say we output
	CLRL	EAX			;  everything
	JMP	10$

;Here if need to wait

14$:	CALL	knlXfWaitNTO##		;Wait until have space
	JNC	2$			;Go on if OK
	JMP	8$			;If error

18$:	POPL	ECX
	JMP	8$

;Here to output PLP packets

20$:	MOVB	AL, #0F0h		;Get beginning of packet character
	CALL	soutchrw		;Store it
	JC	8$
	IFFAULT	knlRtnAdrEr##
22$:	MOVB	AL, ES:[EBX]		;Get character
	CMPB	AL, #'S'-40h		;Might this be XON or XOFF?
	JA	26$			;No
	JE	24$			;If XOFF
	CMPB	AL, #'Q'-40h		;XON?
	JNE	30$			;No - its not special
24$:	TESTB	tdb_omode+3[ESI], #TOM$PLP2>24t ;Should we prefix this?
	JE	30$			;No
	SUBB	AL, #13t		;Yes
	JMP	28$

26$:	CMPB	AL, #0F0h		;Special character?
	JB	30$			;No
	CMPB	AL, #0F2h		;Maybe
	JA	30$			;No
	SUBB	AL, #0EFh
28$:	PUSHL	EAX			;Yes - save character
	MOVB	AL, #0F2h		;Output prefix character
	CALL	soutchrw
	JC	18$
	POPL	EAX			;Get code
30$:	CALL	soutchrw		;Output it
	JC	8$
	INCL	EBX			;Bump pointer
	INCL	EDX			;Bump count
	LOOP	ECX, 22$		;Loop if more to output
	MOVB	AL, #0F1h		;Get end of packet character
	CALL	soutchrw		;Output it
	JNC	6$			;If OK
	JMP	8$			;If error
.PAGE

soutchrw:
	CALL	soutchr			;Output character
	JNC	6$			;If OK
	PUSHL	EAX			;Need to wait - save character
	CALL	knlXfWaitNTO##		;Wait
	JC	4$			;If error while waiting
	POPL	EAX			;OK - restore character
	JMP	soutchrw		;Try again

;Here if error

4$:	ADDL	ESP, #4t		;Discard character
	STC				;Indicate error
6$:	RET
.PAGE
	.SBTTL	tf_qoutstr - serqoutstr - Output string at fork level

;Here for the tf_qoutstr dispatch - Output string at fork level
;	c{ES:EBX} = Address of string
;	c{ESI}    = Offset of TDB
;	CALL	serqoutstr
;	c{EAX} = Error code
;	c{ECX} = Amount output
;	c{ESI} = Status bits

serqoutstr:
	CLRL	ECX			;Initialize count
	ORB	tdb_stsout+1[ESI], #TSO$QOWAIT>8
	IFFAULT	knlRtnAdrEr##
2$:	MOVB	AL, ES:[EBX]		;Get character
	CMPB	AL, #0			;Finished?
	JE	8$			;Yes
	TESTB	tdb_stsout[ESI], #TSO$JUNK|TSO$JUNKX ;Are we junking output?
	JNE	6$			;Yes
	TESTB	tdb_stsout[ESI], #TSO$HOLDS|TSO$HOLDP ;Are we holding output?
	JNE	14$			;Yes
	CALL	soutchr			;No - store character in output buffer
	JC	14$			;If no more room
6$:	INCL	EBX			;Bump pointer
	INCL	ECX			;Bump count
	JMP	2$			;Continue

;Here when finished

8$:	CLRL	EAX			;Return 0
10$:	MOVL	EBX, #QSTS$DONE
	ANDB	tdb_stsout+1[ESI], #~{TSO$QOWAIT>8}
	RET				;Finished

;Here if need to wait

14$:	CALL	knlXfWaitNTO##
	JNC	2$			;Go on if OK
	JMP	10$			;If error
.PAGE
	.SBTTL	tf_clrout - serclrout - Clear output ring buffer

;Here for the tf_clrout dispatch - Clear output ring buffer

serclrout:
	CLRL	EAX
	MOVL	tdb_saoutrput[ESI], EAX	;Reset putter and taker pointers
	MOVL	tdb_saoutrtak[ESI], EAX
	MOVL	tdb_outrcnt[ESI], EAX	;Clear the count
	RET
.PAGE
	.SBTTL	soutchr - Subroutine to store character in output ring

;Subroutine to store character in output ring - may only be called at fork level
;	c(AL) = Character
;	c{ESI} = Offset of TDB
;	CALL	soutchr
;	C:set = Must wait, no output done
;	C:clr = Normal
;  All registers are preserved

soutchr:PUSHL	EDX
	MOVL	EDX, tdb_saoutrsize[ESI] ;Room for more now?
	SUBL	EDX, #3
	CMPL	tdb_outrcnt[ESI], EDX
	JA	8$			;No
	MOVL	EDX, tdb_saoutrput[ESI] ;Get putter pointer
	PUSHL	ECX
	MOVL	ECX, tdb_saoutring[ESI]
	MOVB	[ECX+EDX], AL		;Store character in ring
	POPL	ECX
	INCL	EDX			;Bump pointer
	CMPL	EDX, tdb_saoutrsize[ESI]
	JB	2$
	CLRL	EDX
2$:	MOVL	tdb_saoutrput[ESI], EDX
	INCL	tdb_outrcnt[ESI]	;Bump count
	POPL	EDX
	BTSL	tdb_stsout[ESI], #TSO%OUTA ;Is output active now?
	JC	4$			;Yes
	PUSHAL				;No
	PUSHL	ES
	CALL	serresume		;Start output
	POPL	ES
	POPAL
4$:	CLC				;Indicate character stored
	RET				;And return

;Here if must wait

8$:	POPL	EDX
	STC				;Indicate must wait
ret008:	RET				;And return
.PAGE
	.SBTTL	sechchr - Subroutine to echo character

;Subroutine to echo character - may only be called at fork level
;	c(AL) = Character
;	c{ESI} = Offset of TDB
;	CALL	serechchr
;	C:set = Should stop echoing
;	C:clr = Can continue echoing if need to

serechchr:
	MOVL	EDX, tdb_saoutrsize[ESI] ;Room for more now?
	SUBL	EDX, #3
	CMPL	tdb_outrcnt[ESI], EDX
	JA	4$			;No
	MOVL	EDX, tdb_saoutrput[ESI] ;Yes - get putter pointer
	MOVL	ECX, tdb_saoutring[ESI]
	MOVB	[ECX+EDX], AL		;Store character in ring
	INCL	EDX			;Bump pointer
	CMPL	EDX, tdb_saoutrsize[ESI] ;At end of ring?
	JB	2$			;No
	CLRL	EDX			;Yes
2$:	MOVL	tdb_saoutrput[ESI], EDX ;Store updated putter pointer
	INCL	tdb_outrcnt[ESI]	;Bump count
	MOVL	EDX, tdb_saoutrsize[ESI] ;See if still have room
	SUBL	EDX, #4
	CMPL	tdb_outrcnt[ESI], EDX
4$:	CMC
	RET
.PAGE
	.SBTTL	tf_dspmode - serdspmode - Get or set display mode

;Here for the tf_dspmode dispatch - Get or set display mode
;	c{EAX}    = Display mode bits
;	c{ES:EBX} = Address of data block
;	CALL	serdspmode
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Current display mode

serdspmode:
	CMPB	AL, #0FFh		;Setting to "serial port" mode?
	JE	4$			;Yes - thats OK
	TESTB	AL, AL			;No - just want current mode?
	JNE	knlBadValue##		;No - fail
4$:	BTL	EAX, #DM%RTNDATA	;Want values returned?
	JNC	6$			;No
	CLRL	EAX			;Yes - zero stuff we don't support
	IFFAULT	knlRtnAdrEr##		;Clear dm_textres, dm_prifont, and
	MOVL	ES:[EBX], EAX		;  dm_secfont
	IFFAULT	knlRtnAdrEr##
	MOVL	ES:dm_disptype[EBX], EAX
	MOVL	ES:dm_horiz[EBX], EAX
	MOVL	ES:dm_vert[EBX], EAX
	MOVL	ES:dm_columns[EBX], #80t ;THESE SHOULD BE DYNAMIC!!!!!
	MOVL	ES:dm_rows[EBX], #24t
6$:	MOVL	EAX, #0FFh		;Yes - indicate "serial port" mode
	RET				;Thats all
.PAGE
	.SBTTL	tf_setdtr - sersetdtr - Set or clear the DTR output

;Here for the tf_setdtr dispatch - Set or clear the DTR modem control output
;	c(AL)  = New state for bit
;	c{ESI} = Offset of TDB
;	CALL	sersetdtr

sersetdtr:
	CMPB	AL, #0			;Want to set the bit?
	JNE	2$			;Yes
	ANDB	tdb_samdcon[ESI], #~CMMDC$DTR ;No - clear the bit
	JMP	8$

2$:	ORB	tdb_samdcon[ESI], #CMMDC$DTR ;Set the bit
	JMP	8$

	.SBTTL	tf_setrts - sersetrts - Set or clear the RTS output

;Here for the tf_setrts dispatch - Set or clear the RTS modem control output
;	c(AL)  = New state for bit
;	c{ESI} = Offset of TDB
;	CALL	sersetrts

sersetrts:
	CMPB	AL, #0			;Want to set the bit?
	JNE	6$			;Yes
	ANDB	tdb_samdcon[ESI], #~CMMDC$RTS ;No - clear the bit
	JMP	8$

6$:	ORB	tdb_samdcon[ESI], #CMMDC$RTS ;Set the bit
8$:	MOVL	EDX, tdb_bioreg[ESI]
	A2IOP	P_COMMODMCON		;Point to modem control reg
	MOVB	AL, tdb_samdcon[ESI]	;Set the hardware register
	OUTB	[DX]
	RET
.PAGE
	.SBTTL	tf_getdsb - sergetdsb - Get data set bits

;Here for the tf_getdsb dispatch - Get data set bits
;	c{ESI} = Offset of TDB
;	CALL	sergetdsb
;	c{EAX} = Current data set bits:
;		  Bit 4 = CTS
;		  Bit 5 = DTR
;		  Bit 7 = CD

sergetdsb:
	MOVL	EDX, tdb_bioreg[ESI]	;Get the current modem bits
	A2IOP	P_COMMODMSTS
	CLRL	EAX
	INB	[DX]
	ANDB	AL, #0B0h
	MOVL	ECX, EAX
	A2IOP	P_COMMODMCON-P_COMMODMSTS
	INB	[DX]
	ANDB	AL, #03h
	ORL	EAX, ECX
	RET
.PAGE
	.SBTTL	tf_finout - serfinout - Ensure that output is complete

;Here for the tf_finout dispatch - Ensure that output is complete
;	c{ESI} = Offset of TDB
;	CALL	serfinout

serfinout:
	MOVL	EAX, #TICKPERSEC/3	;Wait for about 1/3 second while the
	CLRL	EDX			;  UART empties out!
	JMP	knlXfTimeWait##
.PAGE
	.SBTTL	seroad - Once-a-second routine

;Once-a-second routine

seroas:	MOVL	ESI, sereftdb		;Point to our first TDB
2$:	CMPB	tdb_saouttoc[ESI], #0	;Are we timing output?
	JE	6$			;No
	DECB	tdb_saouttoc[ESI]	;Yes - count it down
	JNE	6$			;If not timed-out
	INCL	tdb_sahungcnt[ESI]	;Timed-out - count it
	TOFORK				;Fake up an output done interrupt
	CALL	seroutrdy
	MOVL	EDX, tdb_bioreg[ESI]	;Point to interrupt enable register
	A2IOP	P_COMINTENB
	MOVB	AL, tdb_saintenb[ESI]	;Make sure interrupts are enabled
	OUTB	[DX]
	FROMFORK
6$:	TESTB	tdb_stsout[ESI], #TSO$HOLDS|TSO$HOLDP
					;Are we holding output now?
	JE	14$			;No
	TESTB	tdb_flow[ESI], #TFC$OCTS|TFC$ODSR
					;Yes - using hardware flow control?
	JE	14$			;No
	MOVB	AH, #10h		;Assume using CTS
	TESTB	tdb_flow[ESI], #TFC$OCTS ;Right?
	JNE	8$			;Yes
	MOVB	AH, #20h		;No - using DTR
8$:	MOVL	EDX, tdb_bioreg[ESI]	;Get the current modem bits
	A2IOP	P_COMMODMSTS
	TOFORK
	INB	[DX]
	TESTB	tdb_flow[ESI], #TFC$OREV ;Is the sense reversed?
	JE	10$			;No
	NOTB	AL			;Yes
10$:	TESTB	AL, AH			;Is the bit still clear?
	JE	12$			;Yes
	ANDB	tdb_stsout[ESI], #~{TSO$HOLDS|TSO$HOLDP} ;No - restart output
	CALL	serresume
12$:	FROMFORK
14$:	MOVL	ESI, tdb_nexts[ESI]	;Advance to next TDB
	TESTL	ESI, ESI		;Any more?
	JNE	2$			;Yes - continue
	RET				;No - finished
.PAGE
	.SBTTL	Data

	DATA

	.MOD	4
sereftdb:.LONG	0		;Offset of first SERE TDB
sereltdb:.LONG	0		;Offset of last SERE TDB

	LKEEND
