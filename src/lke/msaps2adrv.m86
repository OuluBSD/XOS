	.TITLE	msaps2adrv - PS/2 mouse driver

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

	.PROC	80486
	.INCLUD	XOSINC:\XMAC\XOS.PAR
	.INCLUD	XOSINC:\XMAC\XOSX.PAR
	.INCLUD	XOSINC:\XMAC\XOSTIME.PAR
	.INCLUD	XOSINC:\XMAC\XOSERR.PAR
	.INCLUD	XOSINC:\XMAC\XOSTRM.PAR
	.INCLUD	XOSINC:\XMAC\XOSXTRM.PAR
	.INCLUD	XOSINC:\XMAC\PCAT.PAR
	.INCLUD	XOSINC:\XMAC\XOSLKE.PAR
	.INCLUD	XOSINC:\XMAC\XOSXLKE.PAR
	.INCLUD	XOSINC:\XMAC\XOSXMOUSEA.PAR

MAJV   =!1t
MINV   =!0t
EDITNUM=!0t

	LKEHEAD	MSAPADRV, MAJV, MINV, EDITNUM, LKETYPE_CLASS

;Define values for dcb_msepastate

MSAPA_ACK   =!0t		;ACK next
MSAPA_HEADER=!1t		;Header byte next
MSAPA_BYTE1 =!2t		;Byte 1 next
MSAPA_BYTE2 =!3t		;Byte 2 next
MSAPA_BYTE3 =!4t		;Byte 3 next
MSAPA_RECON2=!5t
MSAPA_RECON3=!6t
MSAPA_RESET1=!7t		;First reset response byte next
MSAPA_RESET2=!8t		;Seonnd reset response byte next
MSAPA_WHEEL =!9t		;ID byte after wheel setup next
MSAPA_FVBUT =!10t		;ID byte after 5-button setup next
MSAPA_TPID1 =!11t		;First touchpad byte for TP ID sequence
MSAPA_TPID2 =!12t		;Second touchpad byte for TP ID sequence
MSAPA_TPID3 =!13t		;Third touchpad byte for TP ID sequence
MSAPA_TPMID1=!14t		;First touchpad byte for model ID sequence
MSAPA_TPMID2=!15t		;Second touchpad byte for model ID sequence
MSAPA_TPMID3=!16t		;Third touchpad byte for model ID sequence
MSAPA_TPCAP1=!17t		;First touchpad byte for capabilities sequence
MSAPA_TPCAP2=!18t		;Second touchpad byte for capabilities sequence
MSAPA_TPCAP3=!19t		;Third touchpad byte for capabilities sequence
MSAPA_ERROR =!20t		;Fatal error has occured

;Define values for the dcb_msepauart byte (UART type)

TRMU_8250 =!1t			;Old 8250
TRMU_16450=!2t			;8250A/16450
TRMU_16550=!3t			;16550 with 16 byte FIFO

.IF EQ 1
	;
	; Use original definition
	;
	.MACRO IOPAUSEKBD
	 IOPAUSE
	.ENDM
.IFF
	.MACRO IOPAUSEKBD

	pushl	ecx
	movl	ecx, #1
	call	knlSDelay##
	popl	ecx

	.ENDM
.ENDC
.PAGE
	CODE

	.SBTTL	Driver function dispatch table

msapadsp:
	.LONG	msapaaddunit	;msaf_addunit = 0
	.LONG	0		;msaf_send    = 8
.PAGE
;Device characteristics for SERA mouse devices

	DATA

	.MOD	4
msapadctbl:
 DCHARBGN  1, knlDCharValCom##
 DCHARENT  CLASS , TEXT, , 8, knlDcMsgClass##  , knlDcGetClass##, knlDcSetClass##  , 0
 DCHARENT  TYPE  , TEXT, , 4, knlDcMsgType##   , knlDcGet4Byte##, 0                , dcb_type
 DCHARENT  MTYPE , STR , ,16, xosmsaMTypeMsg## , dcgetmtype     , 0                , 0
 DCHARENT  CONDEV, DECV, , 4, xosmsaConDevMsg##, knlDcGet4Byte##, xosmsaSetConDev##, dcb_msecondev

	CODE
.PAGE
	.SBTTL	mssainit - PS2 mouse driver initialization routine

	INITSUB	mssainit

mssainit:
	MOVL	EBX, #'PS2A'		;Get mouse driver name
	MOVL	EDX, #msapadsp		;Get offset of dispatch table
	CALL	xosmsaNewDriver##
	JC	10$.S			;This should not fail!
	MOVL	ECX, #codetop
	CLRL	EDX
	CLRL	EAX
10$:	MOVL	EBX, #QSTS$DONE
	RET

	CODE
.PAGE
	.SBTTL	mssaaddunit - Subroutine to add mouse port unit

;Subroutine to add mouse port unit
;	c{EAX}    = Unit number
;	c{FS:EDX} = Address of add-unit characteristics
;	CALL	msapaaddunit
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

$$$=!0
FRM mau_unit   , 4	;Unit number
FRM mau_introut, 4	;Interrupt routine offset
FRM mau_ioreg  , 4	;Base IO register number
FRM mau_int    , 4	;Interrupt level
mau_SIZE=!$$$

;Description block for addunitchar

	DATA

	.MOD	4
msapaaublk:
 DCHARBGN  2, knlDCharValCom##
 DCHARENT  TYPE , TEXT, , 4, 0, 0, knlRtnZero##, 0
 DCHARENT  UNIT , DECV, , 4, 0, 0, knlRtnZero##, 0

	CODE

msapaaddunit:
	CMPL	msapadcb, #0.B
	JNE	12$
	ENTER	mau_SIZE, 0		;Set up and initialize our stack frame
	MOVL	mau_unit.B[EBP], EAX	;Save unit number for now
	MOVL	EBX, #msapaaublk	;Point to our description block
	MOVB	AL, #0			;Fail if bad name
	CALL	knlAddUnitChar##
	JC	14$			;If error

;Here if the interface exists

	CALL	knlGetXRes##		;Get exec memory resource
	MOVL	ECX, #dcb_msepaSIZE	;OK - create a DCB
	MOVL	EBX, #msapadctbl
	MOVL	EDX, mau_unit[EBP]
	CALL	xosmsaMakeDcb##
	JC	14$
	MOVL	msapadcb, EDI
	CALL	knlGiveXRes##		;Give up the exec memory resource
	MOVL	dcb_type[EDI], #'PS2A'
	MOVL	dcb_msepainput[EDI], #inpavl ;Store address of input function
	MOVL	dcb_mseinit[EDI], #msapainit
	MOVB	dcb_msepastate[EDI], #MSAPA_ACK ;Set initial input state
	CLRL	EAX
	CLRL	ECX			;Get our return value
	MOVL	EBX, #QSTS$DONE
	LEAVE
	TOFORK
	RET

12$:	MOVL	EAX, #ER_PDADF
	JMP	16$

14$:	LEAVE
16$:	CLRL	ECX
	MOVL	EBX, #QSTS$DONE
	TOFORK
	STC
	RET
.PAGE

;Subroutine to initialize the mouse
;	c{EDI} = Address of mouse DCB
;	CALL	msapainit
;	C:set = Error
;	  c{EAX} = XOS error code
;	C:clr = Normal

msapainit:
	MOVB	DL, #0AD		;Disable the keyboard
	CALL	putcmd
	MOVB	DL,#20h			;Get the controller's command bits
	CALL	putcmd
	MOVL	ECX, #300t
	CALL	knlSDelay##
	INB	P_KEYDATA

	PUSHL	EAX
	MOVB	DL, #60h
	CALL	putcmd
	MOVL	ECX, #300t
	CALL	knlSDelay##
	POPL	EAX

	ORB	AL, #02			;Enable mouse interrupts
	ANDB	AL, #0DF		;Enable the mouse
	OUTB	P_KEYDATA
	MOVB	DL, #0AE		;Enable the keyboard
	CALL	putcmd
	MOVL	SS:pdaResponse##, #0
	MOVW	dcb_mseinitpda[EDI], SS
4$:	MOVL	EBX, #timeout
	MOVL	EAX, #SPPERSEC*5
	TOFORK
	CALL	knlWakeRequest##
	MOVL	dcb_mseinitwb[EDI], ESI

	MOVL	EAX, SS			;Requeue this process
	MOVL	ES, EAX
	MOVB	AL, #knlQX_SPND##
	CALL	knlRequeue##
	FROMFORK

;Start the initialization sequence. This first sends a reset command (0xFF).
;  If this is successful, the send the command to switch to "wheel" mode
;  (0xF3, 200, 0xF3, 100, 0xF3, 80) followed immediately by a read mouse ID
;  command (0xF2). The single response byte should be either 0 (standard
;  mouse) or 3 (some kind of wheel mouse). If we get 3, attempt to set to
;  5-button wheel mode by sending (0xF3, 200, 0xF3, 200, 0xF3, 80). This
;  is also followed by a read mouse ID command (0xF2). If the response is 4
;  we have a 5-button wheel mouse.

	MOVB	dcb_msepawheel[EDI], #0	;Assume we have a standard mouse
	MOVB	AL, #MSAPA_RESET1	;Send a reset command to the mouse
	MOVL	EBX, #resetstr
	MOVL	ECX, #1
	CALL	putstring
	CALLF	schedule		;Call the scheduler (this is an
					;  uninterruptable wait!)
	MOVL	ESI, dcb_mseinitwb[EDI]
	TESTL	ESI, ESI
	JE	12$
	MOVL	dcb_mseinitwb[EDI], #0
	TOFORK
	CALL	knlWakeRemove##
	FROMFORK
12$:	MOVL	EAX, SS:pdaResponse##
	TESTL	EAX, EAX
	JE	4$
	MOVW	dcb_mseinitpda[EDI], #0
	JS	16$
	CLRL	EAX
	RET

16$:	STC
	RET

;Subroutine called if our time-out expires
;	c{EDI} = Address of our DCB

timeout:
	MOVL	dcb_mseinitwb[EDI], #0
	CMPW	dcb_mseinitpda[EDI], #0
	JE	20$
	MOVW	ES, dcb_mseinitpda[EDI]
	MOVL	ES:pdaResponse##, #ER_NORSP
	CALL	knlRRequeue##
	CLC
20$:	RET
.PAGE
dcgetmtype:
	MOVZBL	EAX, dcb_msepawheel[EDI]
	MOVL	EDX, CS:mtypename[EAX*4]
	JMP	knlGetSysStr##

	.MOD	4
mtypename:
	.LONG	txtnormal
	.LONG	txt3bwheel
	.LONG	txt5bwheel
	.LONG	txttprel
	.LONG	txttpabs
	.LONG	txttpabsw
.PAGE
;Subroutine to output a string to the mouse
;	c(AL)  = New state (set when output is complete)
;	c{EBX} = Offset of string
;	c{ECX} = Length of string
;	CALL	putstring

;NOTE: Each byte send generates an ACK (0xFA) response byte. Any data response
;      generated follows the ACK for the last byte sent.

putstring:
	MOVB	dcb_msepanewsta[EDI], AL
	MOVB	AH, [EBX]		;Get first character
	INCL	EBX
	DECL	ECX
	MOVL	dcb_msepaopnt[EDI], EBX
	MOVB	dcb_msepaocnt[EDI], CL
	MOVB	dcb_msepastate[EDI], #MSAPA_ACK
					;Fall into putbyte for first character

;Subroutine to output a byte to the mouse
;	c(AH) = Byte to output
;	CALL	putbyte

putbyte:
	PUSHL	EBX
	MOVL	EBX, debugpnt
	CMPL	EBX, #debugend
	JAE	4$.S
	MOVB	[EBX], #0FF
	MOVB	1.B[EBX], AH
	ADDL	debugpnt, #2.B
4$:	POPL	EBX

	MOVB	DL, #0D4h		;Indicate mouse data
	CALL	putcmd
	MOVL	ECX, #10000
8$:	INB	P_KEYSTS
	IOPAUSEKBD
	TESTB	AL, #02
	LOOPNE	ECX, 8$
	MOVB	AL, AH
	MOVB	dcb_msepabyte[EDI], AL
	OUTB	P_KEYDATA		;Output the data byte
	IOPAUSEKBD
	RET

;Subroutine to output a comand byte to the keyboard controller

putcmd:	MOVL	ECX, #10000
12$:	INB	P_KEYSTS
	IOPAUSEKBD
	TESTB	AL, #02
	LOOPNE	ECX, 12$
	MOVB	AL, DL
	OUTB	P_KEYCMD
;;;;	IOPAUSEKBD
	RET
.PAGE
;Here for input available interrupt
;	c(AL) = Mouse data byte

inpavl:	MOVZBL	ECX, dcb_msepastate[EDI] ;No - get our state

	MOVL	xxxdata, EAX
	MOVL	xxxstate, ECX

	JMPIL	statetbl[ECX*4]

	DATA

statetbl:
	.LONG	inpack		;MSAPA_ACK    = 0 - Expecting ACK
	.LONG	inpheader	;MSAPA_HEADER = 1 - Header byte next
	.LONG	inpbyte1	;MSAPA_BYTE1  = 2 - Byte 1 next
	.LONG	inpbyte2	;MSAPA_BYTE2  = 3 - Byte 2 next
	.LONG	inpbyte3	;MSAPA_BYTE3  = 4 - Byte 3 next
	.LONG	inprecon2	;MSAPA_RECON2 = 5
	.LONG	inprecon3	;MSAPA_RECON3 = 6
	.LONG	inpreset1	;MSAPA_RESET1 = 7 - First reset response byte
	.LONG	inpreset2	;MSAPA_RESET2 = 8 - Second reset response byte
	.LONG	inpwheel	;MSAPA_WHEEL  = 9 - ID byte after wheel setup
	.LONG	inpfvbut	;MSAPA_FVBUT  = 10 - ID byte after 5-button setup
	.LONG	inptpmode1	;MSAPA_TPID1  = 11
	.LONG	inptpmode2	;MSAPA_TPID2  = 12
	.LONG	inptphvid	;MSAPA_TPID3  = 13
	.LONG	inptpmode1	;MSAPA_TPMID1 = 14
	.LONG	inptpmode2	;MSAPA_TPMID2 = 15
	.LONG	inptphvmid	;MSAPA_TPMID3 = 16
	.LONG	inptpmode1x	;MSAPA_TPCAP1 = 17
	.LONG	inptpmode2x	;MSAPA_TPCAP2 = 18
	.LONG	inptphvcap	;MSAPA_TPCAP3 = 19
	.LONG	errstop		;MSAPA_ERROR  = 20

	CODE

;Here if have had unrecoverable error - disable the mouse and forget about it

errstop:INT3

	JMP	errstop

;Here if expecting ACK next

inpack:	CMPB	AL, #0FAh		;ACK?
	JNE	2$.S			;No
	CMPB	dcb_msepaocnt[EDI], #0	;Yes - have any data to send?
	JE	4$.S			;No
	MOVL	EBX, dcb_msepaopnt[EDI]	;Yes
	DECL	dcb_msepaocnt[EDI]
	INCL	dcb_msepaopnt[EDI]
	MOVB	AH, [EBX]
	CALL	putbyte
	JMP	intdone			;Thats all

2$:	CMPB	AL, #0FEh		;RESEND?
	JNE	3$.S			;No - ignore it
	MOVB	AH, dcb_msepabyte[EDI]	;Yes - resend the last byte
	CALL	putbyte
	JMP	intdone

3$:
;;;	INT3
	JMP	intdone

;Here when finished with output

4$:	MOVB	AL, dcb_msepanewsta[EDI] ;Update the input state
	MOVB	dcb_msepastate[EDI], AL
	CMPB	AL, #MSAPA_HEADER
	JNE	intdone
	MOVL	EAX, #1
	MOVL	EDX, EAX
	JMP	strdata
.PAGE
;Data is received in 3 or 4 byte packets. In standard PS2 mode, data
;  packets are 3 bytes. In wheel mode, data packets are 4 bytes.
;	Byte      Description
;	  0   Mouse header byte:
;		7: Y value overflow (0 in wheel mode)
;		6: X value overflow (0 in wheel mode)
;		5: Y value sign
;		4: X value sign
;		3: Always 1
;		2: Middle button status
;		1: Right button status
;		0: Left button status
;	  1   8-bit X value
;	  2   8-bit Y value
;	  3   In 3-button wheel mode:
;		8-bit Z value
;	      In 5-button wheel mode:
;		7:   0
;		6:   0
;		5:   B5 status
;		4:   B4 status
;		3-0: 4-bit Z value

;Here with a header byte

inpheader:
	CMPB	AL, #0xAA		;Might this be a reset (reconnect)
					;  indication?
	JE	chkreset		;Yes
	MOVB	dcb_msepahbits[EDI], AL	;No - assume normal start of packet
	MOVB	AH, AL
	SHLB	AH, #6
	ANDB	AH, #40h
	MOVB	DL, AL
	SHLB	DL, #3
	ANDB	DL, #20h
	SHLB	AL, #3
	ANDB	AL, #10h
	ORB	AL, AH
	ORB	AL, DL
	MOVB	dcb_msepaheader[EDI], AL
	MOVB	dcb_msepastate[EDI], #MSAPA_BYTE1 ;Update state
	MOVL	EAX, knlSchTime##
	MOVL	dcb_msepahdtcks[EDI], EAX
	JMP	intdone			;Finished

;Here this might be a reset (reconnect) indication instead of a normal start
;  of packet. We can't be sure since a packet can begin with 0xAA, although
;  this is not likely! A reset indication consists of the two bytes 0xAA and
;  0x00 only. If we see these two bytes and nothing else for about 100ms we
;  assume it is really a reset.

chkreset:
	MOVB	dcb_msepastate[EDI], #MSAPA_RECON2 ;Update state
	MOVL	EAX, knlSchTime##
	MOVL	dcb_msepahdtcks[EDI], EAX
	JMP	intdone			;Finished

;Here with the first byte following the header byte - This byte contains the
;  X distance value (without sign)

inpbyte1:
	CALL	checksync
	JNE	inpheader
	MOVZBL	EAX, AL
	TESTB	dcb_msepahbits[EDI], #10h
	JE	2$
	ORL	EAX, #0FFFFFF00h
2$:	MOVL	dcb_msepaxval[EDI], EAX
	INCB	dcb_msepastate[EDI]
	JMP	intdone

;Here with the second byte following the header byte - This byte contains the
;  Y distance value (without sign).

inpbyte2:
	CALL	checksync
	JNE	inpheader
	MOVZBL	EAX, AL
	TESTB	dcb_msepahbits[EDI], #20h
	JE	4$
	ORL	EAX, #0FFFFFF00h
4$:	NEGL	EAX
	MOVL	ECX, EAX
	CLRL	EBX
	CMPB	dcb_msepawheel[EDI], #0	;Is this a wheel mouse?
	JE	10$.S			;No - this is the last byte
	CMPB	dcb_msepawheel[EDI], #3
	JGE	10$.S			;No
	MOVL	dcb_msepayval[EDI], EAX	;Yes - save Y value
	INCB	dcb_msepastate[EDI]
	JMP	intdone


;Here with the third byte following the header byte - This byte contains the
;  Z value and, if in 5-button mode, the additional 2 button status bits.

inpbyte3:
	CALL	checksync
	JNE	inpheader
	CMPB	dcb_msepawheel[EDI], #2	;Is this a 5-button mouse?
	JNE	6$			;No
	MOVB	AH, AL			;Yes - store the additional button
	SHRB	AH, #2			;  bits
	ANDB	AH, #0x0Ch
	ORB	dcb_msepaheader[EDI], AH
	ANDL	EAX, #0x0F		;Assume Z value is positive
	TESTB	AL, #08h		;Right?
	JE	8$			;Yes
	ORL	EAX, #0FFFFFFF0		;No - extend the sign bit
	JMP	8$

6$:	MOVXBL	EAX, AL			;Sign extend the 8-bit Z value
8$:	MOVL	EBX, EAX
	MOVL	ECX, dcb_msepayval[EDI]
10$:	MOVL	EDX, dcb_msepaxval[EDI]
	CLRL	EAX
	MOVB	AH, dcb_msepaheader[EDI]
	MOVB	dcb_msepastate[EDI], #MSAPA_HEADER
strdata:CALL	xosmsaStoreData##
reqfork:CALL	knlReqFork##		;Request fork
intdone:MOVB	AL, #INT_EOI		;Release interrupt controller
	CLI
	OUTB	P_INC2P0		;Release 2nd interrupt controller
	OUTB	P_INC1P0		;Always release 1st interrupt controller
	JMP	knlDismissInt2##	;Check for scheduling and dismiss
.PAGE
;Here with the second byte of a possible reset (reconnect) sequence - It
;  should be 0

inprecon2:
	CMPB	AL, #0
	JE	4$
	MOVB	dcb_msepahbits[EDI], #0xAA
	MOVB	dcb_msepaheader[EDI], #0x01
	JMP	inpbyte2

4$:	MOVB	AL, #2
	MOVL	EBX, #inpreconto
	CALL	xosmsaReqTimer##
	INCB	dcb_msepastate[EDI]
	JMP	reqfork

;Here with a third byte while receiving what may be a reset (reconnect)
;  sequence - It is not a reset sequence! We don't both clearing the timer -
;  we will ignore it when it goes off since the state will be different

inprecon3:
	MOVB	dcb_msepahbits[EDI], #0xAA
	MOVB	dcb_msepaheader[EDI], #0x01
	JMP	inpbyte2

;Function called after reset (reconnect) timeout - NOTE: This is called at
;  main program level!

inpreconto:
	CMPB	dcb_msepastate[EDI], #MSAPA_RECON3
	JNE	10$

;Here if we really have a reset (reconnect). Start the mouse initialization
;  sequence.

	MOVB	dcb_msepawheel[EDI], #0	;Assume we have a standard mouse
	MOVB	AL, #MSAPA_RESET1	;Send a reset command to the mouse
	MOVL	EBX, #resetstr
	MOVL	ECX, #1
	JMP	putstring

10$:	RET
.PAGE
;Here with first reset response byte

inpreset1:
	CMPB	AL, #0AAh		;Is it correct?
	JNE	interr			;No
	INCB	dcb_msepastate[EDI]	;Yes
	JMP	intdone

;Here with second reset response byte

inpreset2:
	CMPB	AL, #0			;Is it correct?
	JNE	interr			;No
	MOVB	dcb_mseok[EDI], #1	;Yes - indicate operational

;Now see if we have a wheel mouse

	MOVB	AL, #MSAPA_WHEEL
	MOVL	EBX, #wheelstr		;Send wheel string
	MOVL	ECX, #7
	CALL	putstring
	JMP	intdone

;Here with set wheel mode response byte

inpwheel::
	CMPB	AL, #03			;Is this a wheel mouse?
	JNE	8$			;No
	MOVB	dcb_msepawheel[EDI], #1	;Yes
	MOVB	AL, #MSAPA_FVBUT	;See if it's also a 5 button mouse
	MOVL	EBX, #fvbutstr
	MOVL	ECX, #7
	CALL	putstring
	JMP	intdone

;Here with set 5-button wheel mode response byte

inpfvbut::
	CMPB	AL, #04			;Is this a five button mouse?
	JNE	strtdone		;No - its just a normal wheel mouse
	MOVB	dcb_msepawheel[EDI], #2	;Yes
strtdone:
	MOVB	AL, #MSAPA_HEADER
	MOVL	EBX, #enablestr		;Send the enable string
	MOVL	ECX, #2
	CALL	putstring
	JMP	intdone

;Here if unrecoverable error (we don't try very hard to recover in this
;  version!)

interr:	MOVB	dcb_msepastate[EDI], #MSAPA_ERROR
	MOVL	EAX, #1
	MOVL	EDX, #ER_DEVER
	JMP	strdata

;Here if not a wheel mouse - see if it's a touchpad

8$:	MOVB	AL, #MSAPA_TPID1
	MOVL	EBX, #tpidstr
	MOVL	ECX, #9
	CALL	putstring
	JMP	intdone

;Here with first mode byte when checking for a touchpad

inptpmode1:
	MOVB	dcb_msepamode1[EDI], AL
	JMP	12$

;Here with second mode byte when checking for a touchpad

inptpmode2:
	MOVB	dcb_msepamode2[EDI], AL
12$:	INCB	dcb_msepastate[EDI]
	JMP	intdone

;Here with first mode byte when checking for a touchpad

inptpmode1x:
	MOVB	dcb_msepamode1[EDI], AL
	JMP	13$

;Here with second mode byte when checking for a touchpad

inptpmode2x:
	MOVB	dcb_msepamode2[EDI], AL
13$:	INCB	dcb_msepastate[EDI]
	JMP	intdone

;Here with third mode byte when checking for a touchpad

inptphvid:
	MOVB	dcb_msepamode3[EDI],AL
	CMPB	dcb_msepamode2[EDI], #47h ;Is this a touchpad?
	JNE	strtdone		;No
	MOVB	dcb_msepawheel[EDI], #3	;Yes - get model ID bits
	MOVB	AL, #MSAPA_TPMID1
	MOVL	EBX, #tpmidstr
	MOVL	ECX, #9
	CALL	putstring
	JMP	intdone

;Here with the third mode byte when getting the touchpad model ID

inptphvmid:
	TESTB	AL, #80h		;Does this model support the new ABS
					;  format?
	JE	strtdone		;No - we will only use it in relative
					;  mode

;;;	MOVL	ECX, #1000t
;;;	CALL	knlSDelay##

	MOVB	dcb_msepawheel[EDI], #4	;Yes - get the capabilities bits

;;;	JMP	strtdone

	MOVB	AL, #MSAPA_TPCAP1	;  bits
	MOVL	EBX, #tpcapstr
	MOVL	ECX, #9
	CALL	putstring
	JMP	intdone

;Here with the third mode byte when getting the touchpad capabilities

inptphvcap:
	TESTB	dcb_msepamode1[EDI], #80h ;Are these bits meaningful?
	JE	strtdone		;No
	MOVB	dcb_msepawheel[EDI], #5	;Yes - indicate "W" mode is supported
	JMP	strtdone
.PAGE
;Subroutine to check packet sync. This checks the time since the header byte
;  was received.  If it is too long (more than about 100MS) we assume this
;  is the header for a new packet.
;	CALL	checksync
;	Z:set = Normal
;	Z:clr = New packet

checksync:
	MOVL	EDX, knlSchTime##
	SUBL	EDX, dcb_msepahdtcks[EDI]
	JNS	2$
	ADDL	EDX, #SPPERDAY
2$:	CMPL	EDX, #5t
	JG	8$.S
6$:	CLRL	EDX
8$:	RET
.PAGE
	.SBTTL	Data

	DATA

	.MOD	4
msapadcb:.LONG	0

xxxdata::.LONG 0
xxxstate::.LONG 0

debugpnt:.LONG	debugbfr
debugbfr:.BLKB	1000t
debugend:.LONG	0F0F0F0Fh

resetstr: .BYTE 0FFh
enablestr:.BYTE	0EAh, 0F4h		;Set stream mode, enable
wheelstr: .BYTE 0F3h, 200t, 0F3h, 100t, 0F3h, 80t, 0F2h
fvbutstr: .BYTE 0F3h, 200t, 0F3h, 200t, 0F3h, 80t, 0F2h
tpidstr:  .BYTE 0E8h, 0, 0E8h, 0, 0E8h, 0, 0E8h, 0, 0E9h
tpmidstr: .BYTE 0E8h, 0, 0E8h, 0, 0E8h, 0, 0E8h, 3, 0E9h
tpcapstr: .BYTE 0E8h, 0, 0E8h, 0, 0E8h, 0, 0E8h, 2, 0E9h

txtnormal:  .ASCIZ "Normal"
txt3bwheel: .ASCIZ "3 Button/Wheel"
txt5bwheel: .ASCIZ "5 Button/Wheel"
txttprel:   .ASCIZ "TP-Relative"
txttpabs:   .ASCIZ "TP-Absolute"
txttpabsw:  .ASCIZ "TP-Absolute/W"

ackcnt:: .LONG	0

	LKEEND
