	.TITLE	$_reqbpctrl

;*--------------------------------------------------------------------------*
;* reqbpctrl.m86
;*
;* Written by: John Goltz
;*
;* Edit History:
;*
;*--------------------------------------------------------------------------*

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

	.PROC	80486
	.INCLUD	xosinc:\xmac\xos.par
	.INCLUD	xosinc:\xmac\xosx.par
	.INCLUD	xosinc:\xmac\xoserr.par
	.INCLUD	geckot.par

	GTCODE

;Request format:
;  Offset Size Description
;     0     1  Function:
;		 1 = Set breakpoint
;		 2 = Clear breakpoint
;		 3 = Clear all breakpoints
;     1     4  Breakpoint address
;     5     4  Count (if setting a breakpoint)

;Response format:
;  Offset Size Description

	.ENTRY	$_reqbpctrl
$_reqbpctrl::
	CMPL	$_reqlength#, #1
 	JB	$_badlength#
	CMPB	$_dbbufr#+0, #3
	JA	$_baddata#
	JE	clearall
	CMPB	$_dbbufr#+0, #1
	JB	$_baddata#
	JE	setbp

;Here to clear a breakpoint

clearbp:CMPL	$_reqlength#, #5
	JB	$_badlength#
	MOVL	ECX, #BPMAX
	MOVL	EAX, #$_bptable#
	MOVL	EBX, $_dbbufr#+1
4$:	CMPL	EBX, bpt_addr[EAX]
	JE	10$
	ADDL	EAX, #bpt_SIZE
	LOOP	ECX, 4$
fail:	ORB	$_dbbufr#+0, #0x80
	JMP	done

10$:	MOVL	bpt_addr[EAX], #0
	MOVB	bpt_flags[EAX], #0
done:	PUSHL	#DBRQ_BPCTRL
	PUSHL	#5
	CALL	$_sendresponse#
	RET
.PAGE
;Here to set a breakpoint

setbp:	CMPL	$_reqlength#, #9
	JB	$_badlength#
	CLRL	EDI
	MOVL	ECX, #BPMAX
	MOVL	EAX, #$_bptable#
	MOVL	EBX, $_dbbufr#+1	;Get address or offset
20$:	TESTL	EDI, EDI
	JNE	22$
	CMPB	bpt_flags[EAX], #0	;Is it in use?
	JNE	22$			;Yes
	MOVL	EDI, EAX
22$:	CMPL	EBX, bpt_addr[EAX]	;Is it this one?
	JE	34$			;Yes
	ADDL	EAX, #bpt_SIZE
	LOOP	ECX, 20$

;Here if the breakpoint we want to set does not now exist

	TESTL	EDI, EDI		;Any space left?
	JE	fail			;No
	PUSHL	#0xCC			;Yes - store an INT3 and get the
	PUSHL	$_dbbufr#+1		;  current byte
	CALL	$_xchgmem#
	TESTL	EAX, EAX
	JNS	30$
	MOVL	$_dbbufr#+1, #0
	JMP	fail

30$:	MOVB	bpt_inst[EDI], AL	;Save the byte
	PUSHL	EAX			;Restore the instruction byte
	PUSHL	$_dbbufr#+1
	CALL	$_xchgmem#
	MOVL	EAX, $_dbbufr#+1
	MOVL	bpt_addr[EDI], EAX
	MOVL	bpt_pid[EDI], #0
	MOVB	bpt_flags[EDI], #1	;Indicate in use
	MOVL	EAX, EDI

;Here the breakpoint we want to set exists - just update the repeat count

34$:	MOVL	EDX, $_dbbufr#+5
	MOVL	bpt_count[EAX], EDX
	JMP	done
.PAGE
;Here to clear all breakpoints

clearall:
	MOVL	ECX, #BPMAX
	MOVL	EAX, #$_bptable#
	CLRL	EDX
4$:	MOVL	bpt_addr[EAX], EDX
	MOVB	bpt_flags[EAX], #0
	ADDL	EAX, #bpt_SIZE
	LOOP	ECX, 4$
	PUSHL	#DBRQ_BPCTRL
	PUSHL	#1
	CALL	$_sendresponse
	RET

	END
