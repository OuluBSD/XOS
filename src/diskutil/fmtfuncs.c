//++++
// This software is in the public domain.  It may be freely copied and used
// for whatever purpose you see fit, including commerical uses.  Anyone
// modifying this software may claim ownership of the modifications, but not
// the complete derived code.  It would be appreciated if the authors were
// told what this software is being used for, but this is not a requirement.

//   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
//   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
//   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
//   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
//   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
//   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
//   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//----

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <xcstring.h>
#include <malloc.h>
#include <xcmalloc.h>
#include <xos.h>
#include <xossvc.h>
#include <xosrun.h>
#include <xoserr.h>
#include <xoserrmsg.h>
#include <xosrtn.h>
#include <xosxdfs.h>
#include "fmtfuncs.h"


#include "bootblk.c"	// This is a generated file (generated by makedata)
						//   which contains the initial boot block in a 512
						//   byte character array. This is used for both FAT
						//   and XFS disks.

///static long clusters;

long   parthndl;
long   basehndl;
long   partofs;
long   blocks = -1;
long   rootsize = -1;
long   groupsize;

long   numheads;
long   numsects;
long   numcylns;

uchar  mbr[512];				// Buffer for the MBR
uchar  partinx;
uchar  lbamode;
uchar  active = ACT_NOCHNG;

int    fstype = -1;
int    prtntype;

POSPARM posparm =
{	{PAR_SET|REP_HEXV, 4, IOPAR_ABSPOS}
};

static struct
{   BYTE4PARM  optn;
    LNGSTRPARM spec;
    TEXT8PARM  class;
    char       end;
} opnparms =
{  {PAR_SET|REP_HEXV, 4, IOPAR_FILEOPTN, XFO_PHYDEV},
   {PAR_GET|REP_STR , 0, IOPAR_FILESPEC, physname, sizeof(physname),
        sizeof(physname)},
   {PAR_GET|REP_TEXT, 8, IOPAR_CLASS}
};

char physname[24];
char basename[24];

static struct
{	TEXT8CHAR  type;
	BYTE4CHAR  blocks;
    BYTE4CHAR  numheads;
    BYTE4CHAR  numsects;
    BYTE4CHAR  numcylns;
	TEXT4CHAR  lbamode;
	BYTE4CHAR  partinx;
	BYTE4CHAR  partofs;
	LNGSTRCHAR basedev;
    char       end;
} diskchars =
{	{PAR_GET|REP_TEXT, 8, "TYPE"},
	{PAR_GET|REP_DECV, 4, "CBLOCKS"},
	{PAR_GET|REP_DECV, 4, "CHEADS"},
	{PAR_GET|REP_DECV, 4, "CSECTS"},
	{PAR_GET|REP_DECV, 4, "CCYLNS"},
	{PAR_GET|REP_TEXT, 4, "LBAMODE"},
	{PAR_GET|REP_HEXV, 4, "PARTN"},
	{PAR_GET|REP_DECV, 4, "PARTOFF"},
	{PAR_GET|REP_STR , 0, "BASEDEV", basename, sizeof(basename),
			sizeof(basename)}
};


//*************************************************************
// Function: fmtsetupdisk - Do initial setup for disk partition
// Returned: TRUE if normal, FALSE if error
//*************************************************************

// The fmterror function is called before an error is returned.
// The diskname, parthndl, clussize, clusters, blocks, groupsize values
//   are set by this function.

int fmtsetupdisk(
	char *diskname)
{
	long rtn;

	basehndl = 0;
	if ((parthndl = svcIoOpen(XO_IN|XO_OUT|XO_PHYS, diskname, &opnparms)) < 0)
	{
		fmterror(parthndl, "Error opening disk partition %s", diskname);
		return (FALSE);
	}
	if (strcmp(opnparms.class.value, "DISK") != 0)
	{
		fmtfinish();
		fmterror(ER_NTDSK, "Device %s is not a disk", diskname);
		return (FALSE);
	}

	// Determine disk characteristics

	if ((rtn = svcIoDevChar(parthndl, &diskchars)) < 0)
	{
		fmtfinish();
		fmterror(rtn, "Error getting disk characteristics");
		return (FALSE);
	}

	if (blocks == -1)
		blocks = diskchars.blocks.value;
	numheads = diskchars.numheads.value;
	numsects = diskchars.numsects.value;
	numcylns = diskchars.numcylns.value;
	lbamode = (diskchars.lbamode.value[0] == 'Y');
	partinx = (uchar)diskchars.partinx.value;
	partofs = diskchars.partofs.value;

	// If have a base device (which means we are initializing a partition)
	//   open the base device

	if (basename[0] != 0)
	{
		strcat(basename, ":");
		if ((basehndl = svcIoOpen(XO_IN|XO_OUT|XO_PHYS, basename, NULL)) < 0)
		{
			fmtfinish();
			fmterror(basehndl, "Error opening base disk device");
			return (FALSE);
		}

		// Read the MBR

		posparm.pos.value = 0;
		if ((rtn = svcIoInBlockP(basehndl, mbr, 512, &posparm)) < 0)
		{
			fmtfinish();
			fmterror(rtn, "Error reading the MBR");		
			return (FALSE);
		}
	}
	else if (strncmp(diskchars.type.value, "FDK", 3) != 0)
	{
		fmtfinish();
 		fmterror(ER_PDTYP, "Device is not a partition or a diskette");
		return (FALSE);
	}
	return (TRUE);
}


int fmtfinish(void)
{
	long rtn;

	if ((rtn = svcIoClose(parthndl, 0)) < 0)
	{
 		fmterror(rtn, "Error closing partition");
		return (FALSE);
	}
	if (basehndl > 0)
	{
		if ((rtn = svcIoClose(basehndl, 0)) < 0)
		{
 			fmterror(rtn, "Error base disk device");
			return (FALSE);
		}
	}
	return (TRUE);
}


int fmtsetparttype(void)

{
	PARTENT *ppnt;
	long     rtn;

	ppnt = ((PARTENT *)(mbr + 0x1AE));
	if (active == ACT_SET)				// If we are setting our partition
	{									//   active, make sure no other
		ppnt[1].boot = 0;				//   partition is active
		ppnt[2].boot = 0;
		ppnt[3].boot = 0;
		ppnt[4].boot = 0;
	}
	ppnt += partinx;

	if (active != ACT_NOCHNG)
		ppnt->boot = (active == ACT_SET) ? 0x80 : 0;
	ppnt->type = prtntype;				// Set the partition type

	posparm.pos.value = 0;
	if ((rtn = svcIoOutBlockP(basehndl, mbr, 512, &posparm)) < 0)
	{
		fmtfinish();
		fmterror(rtn, "Error writing the master boot record");
		return (FALSE);
	}
    return (TRUE);
}



void fmterror(
	long  code,
	char *fmt, ...)

{
	va_list pi;
	char    text[300];

	if (fmt != NULL)
	{
    	va_start(pi, fmt);
    	vsprintf(text, fmt, pi);
	}
	else
		text[0] = 0;
	formaterror(code, text);
}
