	.TITLE	display

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

	.PROC	80386
	.INCLUD xosinc:\xmac\stdio.par
	.INCLUD	XOSINC:\XMAC\XOS.PAR
	.INCLUD XOSINC:\XMAC\XOSERR.PAR
	.INCLUD	XOSINC:\XMAC\XOSTRM.PAR
	.INCLUD XOSINC:\XMAC\CLIBX.PAR
	.INCLUD XOSINC:\XMAC\PROCARG.PAR
	.INCLUD	VID.PAR

	.STDSEGS

	.PSECT	_TEXT_p

stsmod=!2t		;Place to display modified flag

	.SBTTL	initscn - Subroutine to initialize the screen

;Subroutine to initialize the screen
;	c(BL) = Width of screen
;	c(BH) = Height of screen
;	CALL	initscn

initscn::
	MOVL	ESI, #wdb0#
	MOVL	cw, ESI
	MOVZBL	EAX, BH
	MOVL	sheight#, EAX		;Store screen height
	LEAL	ECX, -2[EAX]
	MOVL	w_vpos[ESI], ECX
	MOVL	w_height[ESI], #1
	MOVZBL	EBX, BL
	MOVL	swidth#, EBX		;And screen width
	MOVL	w_width[ESI], EBX
	ADDL	EBX, EBX
	MOVL	swidthx2#, EBX
	DECL	EAX			;Calculate offset of response line
	IMULL	EAX, EBX
	ADDL	EAX, #scrnbufr
	MOVL	rspline#, EAX
	SUBL	EAX, EBX		;Calculate offset of command line
	MOVL	cmdline#, EAX
	MOVL	w_scrnbufr[ESI], EAX	;Also store as offset of command window
	MOVB	insflg#, #1
	ADDL	EBX, rspline#
	LEAL	EAX, -2[EBX]
	MOVL	inspos#, EAX	;Store position for insert/overwrite indicator
	MOVB	DH, aslattrb#
	MOVB	DL, #' '
	MOVW	[EAX], DX
	SUBL	EAX, #2
	MOVL	litpos#, EAX	;Store position for literal indicator
	MOVW	[EAX], DX
	SUBL	EAX, #2
	MOVL	capspos#, EAX	;Store position caps lock indicator
	MOVW	[EAX], DX
	SUBL	EAX, #2
	MOVL	altpos#, EAX	;Store position for alt indicator
	MOVW	[EAX], DX
	SUBL	EAX, #2
	MOVL	cntrlpos#, EAX	;Store position for control indicator
	MOVW	[EAX], DX
	SUBL	EAX, #2
	MOVL	shiftpos#, EAX	;Store position for shift indicator
	MOVW	[EAX], DX
	MOVB	AL, cmdattrb#	;Store text attributes for the command window
	MOVB	w_txtattrb[ESI], AL
	MOVB	AL, invattrb#
	MOVB	w_invattrb[ESI], AL
	MOVL	w_curlinbuf[ESI], #cmdlinbuf#
	MOVB	w_curlincnt[ESI], #1
	JMP	dspins
.PAGE
	.SBTTL	initwindow - Subroutine to initialize a screen window

;Subroutine to initialize a screen window
;	c(BL)  = Width of window
;	c(BH)  = Height of window
;	c(DL)  = Column for upper left hand corner of window
;	c(DH)  = Row for upper left hand corner of window
;	CALL	initwindow
;	C:set = Error
;	  c{EDX} = Offset of error message string
;	C:clr = Normal
;	  c{ECX} = Offset of new window data block (WDB)
;	  c{ESI} = Offset of current window data block (WDB)

initwindow::
	MOVL	ECX, #WINMAX		;Get maximum number of windows
	MOVL	ESI, #wdb1#		;Point to first WDB
2$:	CMPL	f_fwdb[ESI], #0		;Is this one in use?
	JE	4$			;No - go use it
	ADDL	ESI, #w_SIZE		;Yes - bump pointer
	LOOP	ECX, 2$			;Continue if more to check
	MOVL	ESI, curwin#
	MOVL	EDX, #tmwmsg#		;No more - fail
	STC
	RET

;Here with an available WCB

4$:	MOVL	w_fdb[ESI], EDI		;Link to the file
	MOVL	ECX, f_fwdb[EDI]	;Get first WDB for file
	JREGZ	ECX, 6$			;If none
	MOVL	EAX, w_next[ECX]	;Link us into the ring
	MOVL	w_next[ECX], ESI
	MOVL	w_next[ESI], EAX
	JMP	8$

;Here if this is the first window for the file

6$:	MOVL	w_fdb[EDI], ESI
	MOVL	w_next[ESI], ESI
8$:	MOVB	w_hpos[ESI], DL		;Store window parameters
	MOVB	w_vpos[ESI], DH
	MOVB	w_width[ESI], BL
	MOVB	w_height[ESI], BH
	CALL	setwindow
	MOVL	ECX, ESI
	MOVL	ESI, curwin#
	CLC
	RET
.PAGE
setwindow::
	MOVB	BH, w_height[ESI]
	MOVB	AL, #4			;Assume window is 20 rows or more
	CMPB	BH, #20t		;Right?
	JAE	10$			;Yes
	MOVB	AL, #2			;No - now assume 10 rows or more
	CMPB	BH, #10t		;Right?
	JAE	10$			;Yes
	DECL	EAX			;No - less than 10 rows
10$:	MOVB	w_scrollt[ESI], AL	;Store top scrolling limit
	SUBB	BH, AL			;Calculate bottom scrolling limit
	MOVB	w_scrollb[ESI], BH	;And store it
	MOVZBL	EAX, w_vpos[ESI]	;Calculate address of start of window
	IMULL	EAX, swidthx2#
	ADDL	EAX, w_hpos[ESI]
	ADDL	EAX, w_hpos[ESI]
	ADDL	EAX, #scrnbufr
	MOVL	w_scrnbufr[ESI], EAX	;And store it
	MOVL	EAX, w_height[ESI]	;Calculate offset of status line
	IMULL	EAX, swidthx2#
	ADDL	EAX, w_scrnbufr[ESI]
	MOVL	w_stsline[ESI], EAX	
	MOVL	EBX, #table80#		;Assume we have a full width window
	LEAL	EDX, 10t[EAX]
	CMPL	w_width[ESI], #80t	;Right?
	JAE	12$			;Yes
	MOVL	EBX, #table40#		;No - assume it at least half size
	SUBL	EDX, #4
	CMPL	w_width[ESI], #39t	;Right?
	JAE	12$			;Yes
	MOVL	EBX, #table20#		;No - its less than half size
12$:	MOVL	w_stsfilpos[ESI], EDX	;Store position for file name
	ADDL	EAX, w_width[ESI]
	ADDL	EAX, w_width[ESI]
	LEAL	EDX, w_stshcppos[ESI]
	MOVL	ECX, #4
14$:	CMPL	[EBX], #0		;Use table to store the other positions
	JNE	16$
	MOVL	[EDX], #0
	JMP	18$

16$:	SUBL	EAX, [EBX]
	MOVL	[EDX], EAX
18$:	ADDL	EBX, #4
	SUBL	EDX, #4
	LOOP	ECX, 14$
	MOVB	AL, txtattrb#		;Store text attributes for window
	MOVB	w_txtattrb[ESI], AL
	MOVB	AL, invattrb#
	MOVB	w_invattrb[ESI], AL
	MOVL	w_curlinbuf[ESI], #curlinbuf#
ret001:	RET
.PAGE
	.SBTTL	chngwindow - Change current window

;Subroutine to change the current window
;	c{ECX} = Offset of WCB for new window
;	CALL	chngwindow

chngwindow::
	CMPL	[ECX], #0		;Is the desired window in use?
	JE	ret001			;No - do nothing
	PUSHL	ECX			;Yes

	CMPB	w_haveline[ESI], #0	;Need to save current line?
	JE	2$			;No
	CALL	updcurline		;Yes - update screen (REALLY NEEDED??)
	CALL	putlinef#		;And save current line
	JMP	4$

2$:	CALL	getline#		;Load line into line buffer so can
					;  figure out where to put second cursor
4$:	MOVB	AL, cmcattrb#
	CALL	cmdcuron		;Put second cursor on screen
	MOVB	w_haveline[ESI], #0	;Don't really want line in the buffer!

	MOVB	DH, islattrb#
	MOVB	DL, #0B3
	CALL	border			;Change border to inactive state
	POPL	ESI			;Make it the new current window
	MOVL	cw#, ESI
	MOVL	curwin#, ESI
	CALL	cmdcuroff
makecurwin::
	CALL	chkbind
	CALL	cursorset		;Put cursor in the window
	MOVB	DH, aslattrb#		;Change border to active state
	MOVB	DL, #0B3
	CALL	border
	MOVL	EDI, w_fdb[ESI]
	RET
.PAGE
border::MOVL	EDI, w_stsline[ESI]
	MOVL	ECX, w_width[ESI]
	PUSHL	DS
	POPL	ES
	CLD
	MOVB	AL, DH
2$:	INCL	EDI
	STOSB	[EDI]
	LOOP	ECX, 2$
	CMPL	w_hpos[ESI], #0		;Does this window have a left border?
	JE	10$			;No
	MOVL	EDI, w_scrnbufr[ESI]	;Yes
	SUBL	EDI, #2
	MOVL	ECX, w_height[ESI]
	MOVL	EAX, EDX
6$:	MOVW	[EDI], AX
	ADDL	EDI, swidthx2#
	LOOP	ECX, 6$
	MOVB	AL, #' '
	MOVW	[EDI], AX
10$:	MOVL	EAX, w_hpos[ESI]	;Does this window have a right border?
	ADDL	EAX, w_width[ESI]
	CMPL	EAX, swidth#
	JAE	18$			;No
	MOVL	EDI, w_scrnbufr[ESI]	;Yes
	ADDL	EDI, w_width[ESI]
	ADDL	EDI, w_width[ESI]
	MOVL	ECX, w_height[ESI]
	MOVL	EAX, EDX
12$:	MOVW	[EDI], AX
	ADDL	EDI, swidthx2#
	LOOP	ECX, 12$
	MOVB	AL, #' '
	MOVW	[EDI], AX
18$:	RET
.PAGE
	.SBTTL	updwindow - Subroutine to update the entire text window

;Subroutine to update the entire text window
;	c{w_toppnt} = Offset of line to display at top of window
;	CALL	updwindow

updwindow::
	MOVL	ESI, cw#
	PUSHL	ESI
2$:	MOVL	EDX, w_toppnt[ESI]	;Point to first line to display
	CMPL	EDX, w_dsptop[ESI]	;Same as last time we did this?
	JNE	4$			;No - update entire window
	MOVL	EBX, w_curlin[ESI]	;Yes - calculate position of current
	SUBL	EBX, w_toplin[ESI]	;  line in screen RAM
	IMULL	EBX, swidthx2#
	ADDL	EBX, w_scrnbufr[ESI]
	MOVL	EDX, w_curpnt[ESI]
	MOVL	EAX, w_curlin[ESI]
	CALL	updline			;Just update current line
	JMP	6$

4$:	CALL	updwin
6$:	MOVL	ESI, w_next[ESI]
	CMPL	ESI, [ESP]
	JNE	2$
	JMP	10$

;Enter here if should force update even if top of window has not moved

updwinfrc::
	MOVL	ESI, cw#
	PUSHL	ESI
8$:	CALL	updwin
	MOVL	ESI, w_next[ESI]
	CMPL	ESI, [ESP]
	JNE	8$
10$:	POPL	ESI
	JMP	cursorset
.PAGE
;Subroutine to update single window
;	CALL	updwin

updwin::MOVL	EDX, w_toppnt[ESI]
	MOVL	w_dsptop[ESI], EDX	;Remember where we are now
	MOVL	EBX, w_scrnbufr[ESI]	;Get position of top of window in
	MOVL	ECX, w_height[ESI]	;Get number of text lines
	PUSHL	w_toplin[ESI]
4$:	MOVL	EAX, [ESP]
	PUSHL	EDX			;Save pointer to line
	PUSHL	ECX
	PUSHL	EBX
	CALL	updline			;Display one line
	POPL	EBX
	ADDL	EBX, swidthx2#
	POPL	ECX
	POPL	EDX			;Point to start of line
	DECL	ECX			;More to do?
	JE	12$			;No - finished
	MOVZBL	EAX, [EDX]		;Yes - get size of this line
	ORB	AL, AL			;At end of file buffer?
	JE	8$			;Yes
	LEAL	EDX, 1[EDX+EAX]		;No - advance to next line
	INCL	[ESP]
	JMP	4$			;Continue

;Here when at end of file buffer - clear the rest of the window

8$:	PUSHL	ECX
	PUSHL	EBX
	MOVL	ECX, w_width[ESI]	;Yes - clear a line
	MOVB	AH, w_txtattrb[ESI]
	MOVB	AL, #' '
10$:	MOVW	[EBX], AX		;Display a space
	ADDL	EBX, #2			;Bump pointer
	LOOP	ECX, 10$
	POPL	EBX
	ADDL	EBX, swidthx2#
	POPL	ECX
	LOOP	ECX, 8$			;Loop if more lines
12$:	ADDL	ESP, #4t
	RET	
.PAGE
	.SBTTL	updline - Subroutine to update one line in a window

;Subroutine to update one line in a window
;	c{EAX} = Line number in file
;	c{EBX} = Offset of start of line in screen buffer
;	c{EDX} = Offset of start of line in file buffer (points to count
;		   byte)
;	CALL	updline

$$$=!0
FRM udl_left    , 4t
FRM udl_count   , 4t
FRM udl_line    , 4t
FRM udl_char    , 4t
FRM udl_lowchar , 4t
FRM udl_highchar, 4t
FRM udl_invattrb, 1t
FRM udl_txtattrb, 1t
FRM             , 2t
udl_SIZE=!$$$

updline::
	MOVL	ESI, cw#
	CMPL	w_label[ESI], #'WDB='
	JE	100$
	INT3

100$:	ENTER	udl_SIZE, 0
	MOVL	udl_line[EBP], EAX
	CMPL	EDX, w_curpnt[ESI]	;Is this the current line?
	JNE	2$			;No

;Here if this is known to be the current line

	CMPL	ESI, #wdb0#		;In command mode?
	JE	1$			;Yes
	CMPB	w_haveline[ESI], #0	;No - is it really in the line buffer?
	JE	2$			;No
	CMPL	ESI, curwin#		;Yes - is this the current window?
	JNE	2$			;No

;Here if this is known to be the current line and it is know to be in the
;  line buffer

1$:	MOVL	EDX, w_curlinbuf[ESI]	;Yes - point to line buffer
	MOVL	EAX, w_curlin[ESI]	;Get line number
	MOVL	udl_line[EBP], EAX
	MOVZBL	EAX, w_curlincnt[ESI]	;Get length of line
	JMP	4$

2$:	MOVZBL	EAX, [EDX]		;Get length of line
	INCL	EDX
4$:	MOVL	udl_count[EBP], EAX
	MOVB	AL, w_txtattrb[ESI]
	MOVB	udl_txtattrb[EBP], AL
	MOVB	AL, w_invattrb[ESI]
	MOVB	udl_invattrb[EBP], AL
	CMPB	w_hlstate[ESI], #HLS_NONE ;Is there a highlight region?
	JE	6$			;No
	MOVL	EAX, udl_line[EBP]	;Yes - is this line in the highlight
	CMPL	EAX, w_hllowline[ESI]	;  region?
	JL	6$			;No
	CMPL	EAX, w_hlhighline[ESI]	;Maybe
	JLE	8$			;Yes
6$:	MOVB	udl_invattrb[EBP], #0	;No - indicate that
	JMP	9$

$$$$01::
8$:	MOVL	udl_lowchar[EBP], #0	;Assume an internal line
	MOVL	udl_highchar[EBP], #7FFFFFFF
	CMPL	EAX, w_hllowline[ESI]
	JNE	85$
	MOVL	ECX, w_hllowchrv[ESI]
	MOVL	udl_lowchar[EBP], ECX
85$:	CMPL	EAX, w_hlhighline[ESI]
	JNE	9$
	MOVL	ECX, w_hlhighchrv[ESI]
	MOVL	udl_highchar[EBP], ECX
9$:	MOVB	CH, w_width[ESI]	;Get count
	MOVB	CL, #0			;Clear position in virtual line
	PUSHL	ESI
	PUSHL	EDI
	MOVL	EDI, EBX
	MOVL	EBX, w_left[ESI]	;Get number of characters before left
	MOVL	udl_left[EBP], EBX	;  edge
	MOVL	udl_char[EBP], #0
	MOVL	ESI, EDX
	CLD				;Make sure direction bit is clear
	PUSHL	DS
	POPL	ES
	MOVB	AH, udl_invattrb[EBP]
	DECL	udl_count[EBP]		;Is the count 0?
	JLE	40$			;Yes - just fill line with spaces

;Start of loop to store characters in the screen line

20$:	DECL	udl_count[EBP]		;More in line?
	JS	40$			;If end of line from file
	LODSB	[ESI]			;Get character and bump pointer
	CMPB	AL, #HT			;Is it a horizontal tab?
	JNE	30$			;No - go on

;Here if have horizontal tab character

24$:	INCB	CL			;Yes - increment position in virtual
					;  line
	DECL	udl_left[EBP]		;At left of window yet?
	JNS	28$			;No - nothing to do yet
	MOVB	AH, udl_txtattrb[EBP]	;Get attribute byte value (assume not
					;  in high-light region

	MOVB	AH, udl_txtattrb[EBP]	;Get attribute byte value (assume not
					;  in high-light region
	CMPB	udl_invattrb[EBP], #0	;Might it be in a highlight region?
	JE	26$			;No
	MOVL	EDX, udl_char[EBP]
	CMPL	EDX, udl_lowchar[EBP]
	JL	26$
	CMPL	EDX, udl_highchar[EBP]
	JG	26$
	MOVB	AH, udl_invattrb[EBP]
26$:	MOVB	AL, #' '		;Yes
	STOSW	[EDI]			;Store in screen RAM
	INCL	udl_char[EBP]
	DECB	CH			;Reduce number spaces left on line
	JE	34$			;Finished if at right now
28$:	TESTB	CL, tabmask#		;At tab stop now?
	JNE	24$			;No - continue outputting spaces
	JMP	20$			;Yes - go get next character
	
;Here if not horizontal tab

$$$$02::
30$:	INCB	CL			;Increment position in virtual line
	DECL	udl_left[EBP]		;At left yet?
	JNS	20$			;No - nothing to do yet
	MOVB	AH, udl_txtattrb[EBP]	;Get attribute byte value (assume not
					;  in high-light region
	CMPB	udl_invattrb[EBP], #0	;Might it be in a highlight region?
	JE	32$			;No
	MOVL	EDX, udl_char[EBP]
	CMPL	EDX, udl_lowchar[EBP]
	JL	32$
	CMPL	EDX, udl_highchar[EBP]
	JG	32$
	MOVB	AH, udl_invattrb[EBP]
32$:	STOSW	[EDI]			;Yes - store in screen RAM
	INCL	udl_char[EBP]
	DECB	CH			;Reduce number spaces left on line
	JNE	20$			;Go on if not at right edge now
34$:	POPL	EDI
	POPL	ESI
	MOVL	EAX, w_width[ESI]
36$:	MOVL	EBX, udl_line[EBP]	;Store length in the length table
	SUBL	EBX, w_toplin[ESI]
	MOVL	w_linelen[ESI+EBX*4], EAX
	LEAVE
	RET

;Here at end of line from file buffer - must fill rest of window line with
;  spaces

40$:	CMPB	udl_invattrb[EBP], #0	;Have highlight region?
	JE	42$			;No
	MOVL	EDX, udl_line[EBP]	;Yes - last line of region?
	MOVL	EBX, cw#
	CMPL	EDX, w_hlhighline[EBX]
	JNE	44$
42$:	MOVB	AH, udl_txtattrb[EBP]
44$:	MOVB	AL, #' '
46$:	STOSW	[EDI]			;Display a space
	MOVB	AH, udl_txtattrb[EBP]
	DECB	CH			;Is line fill yet?
	JNE	46$			;No - continue
	POPL	EDI
	POPL	ESI
	MOVL	EAX, udl_char[EBP]
	JMP	36$			;Yes - finished
.PAGE
	.SBTTL	updcurline - Subroutine to update current line in window

;Subroutine to update current line in window
;	CALL	updcurline

updcurline::
	MOVL	ESI, cw#
	MOVL	EBX, w_curlin[ESI]	;Get position of line in screen RAM
	SUBL	EBX, w_toplin[ESI]
	IMULL	EBX, swidthx2#
	ADDL	EBX, w_scrnbufr[ESI]
	MOVL	EDX, w_curpnt[ESI]
	CALL	updline			;Update the line
	MOVL	EBX, w_curlin[ESI]
	PUSHL	ESI
4$:	MOVL	ESI, w_next[ESI]	;Get next window
	CMPL	ESI, [ESP]		;Have another window?
	JE	10$			;No - finished here
	PUSHL	EBX			;Yes
	SUBL	EBX, w_toplin[ESI]	;Is the line in this window?
	JS	6$			;No
	CMPL	EBX, w_height[ESI]	;Maybe
	JAE	6$			;No
	MOVL	EAX, 4[ESP]		;Yes - update current line count for
	MOVB	AL, w_curlincnt[EAX]	;  this window
	MOVB	w_curlincnt[ESI], AL
	IMULL	EBX, swidthx2#		;Update line in this window too
	ADDL	EBX, w_scrnbufr[ESI]
	MOVL	EDX, w_curpnt[ESI]
	CALL	updline
	POPL	EBX
	CMPL	EBX, w_curlin[ESI]	;Is it the current line in this window?
	JNE	4$			;No
	PUSHL	EBX			;Yes
	CALL	chkbind
	MOVB	AL, cmcattrb#
	CALL	cmdcuron		;Put second cursor on screen
6$:	POPL	EBX
	JMP	4$			;Continue

;Here with all windows containing the line updated

10$:	POPL	ESI
cursorset::
	CALL	curchk			;Check position and calculate where
	MOVL	EBX, EAX
cursorst2:				;  cursor goes
	MOVL	EAX, EBX
	CLRL	EDX
	DIVL	swidth#
	PUSHL	#5
	PUSHL	#0
	PUSHL	EDX
	PUSHL	EAX
	CALL	svcTrmCurPos##
ret002:	RET				;Finished
.PAGE
	.SBTTL	dspcln - function to display number of current line

;Subroutine to display number of current line
;	void dspcurline(
;	    WDB *wdb);

dspcl_wdb=!12t

dspcurline::
	PUSHL	EDI
	PUSHL	ESI
	MOVL	ESI, dspcl_wdb[ESP]
	MOVL	EDI, w_fdb[ESI]
	MOVL	EBX, w_stslinpos[ESI]
	ORL	EBX, EBX
	JE	2$
	MOVL	EAX, w_curlin[ESI]	;Get number of current line
	CMPL	EAX, f_numlin[EDI]	;At end of file?
	JE	4$			;If at end of file
	INCL	EAX			;Not at end - adjust value
	PUSHL	EBX
	PUSHL	#6
	PUSHL	EAX
	CALL	dspnum			;Go display it
	ADDL	ESP, #12t
2$:	POPL	ESI
	POPL	EDI
	RET

;Here if at end of file

4$:	MOVL	EDX, #dspcem#		;Get offset of message
	CALL	dspstr			;Go display it
	POPL	ESI
	POPL	EDI
	RET
.PAGE
	.SBTTL	dspnumlines - Functionto display number of lines in file

;Function to display number of lines in file
;	void dspnumlines(
;	    WDB *wdb);

dspnl_wdb=!12t

dspnumlines::
	PUSHL	EDI
	PUSHL	ESI
	MOVL	ESI, dspnl_wdb[ESP]
	MOVL	EDI, w_fdb[ESI]
	MOVL	EDI, w_fdb[ESI]
	MOVL	EAX, f_numlin[EDI]	;Get value
	MOVL	EDX, #w_stsnlnpos	;Get position
	MOVL	ECX, #6			;Get field width
	JMP	2$

	.SBTTL	dspnch - FUnction to display number of characters in file

;Function to display number of characters in file
;	void dspnumchars(
;	    WDB *wdb);

dspnc_wdb=!12t

dspnumchars::
	PUSHL	EDI
	PUSHL	ESI
	MOVL	ESI, dspnc_wdb[ESP]
	MOVL	EDI, w_fdb[ESI]
	MOVL	EAX, f_numchr[EDI]	;Get value
	MOVL	EDX, #w_stschrpos	;Get position
	MOVL	ECX, #8			;Get field width
2$:	MOVL	ESI, f_fwdb[EDI]
4$:	MOVL	EBX, [ESI+EDX]		;Really want to do this?
	ORL	EBX, EBX
	JE	6$			;No
	PUSHL	EAX			;Yes
	PUSHL	ECX
	PUSHL	EDX
	PUSHL	EBX
	PUSHL	ECX
	PUSHL	EAX
	CALL	dspnum			;Display the value
	ADDL	ESP, #12t
	POPL	EDX
	POPL	ECX
	POPL	EAX
6$:	MOVL	ESI, w_next[ESI]
	CMPL	f_fwdb[EDI], ESI
	JNE	4$
	POPL	ESI
	POPL	EDI
	RET
.PAGE
	.SBTTL	dsplit - Subroutine to display LIT flag on screen

;Subroutine to display LIT flag on screen
;	CALL	dsplit

dsplit::MOVL	EBX, litpos#
	MOVB	[EBX], #'L'
	RET

	.SBTTL	rmvlit - Subroutine to remove LIT from from screen

;Subroutine to remove LIT flag from the screen
;	CALL	rmvlit

rmvlit::MOVL	EBX, litpos#
	MOVB	[EBX], #' '
	MOVB	litflg#, #0
	RET

	.SBTTL	dspmfg - Subroutine to put M flag on the screen

;Subroutine to put M flag on the screen
;	CALL	dspmfg

dspmfg::CMPB	f_modified[EDI], #0	;Is the flag already set?
	JNE	6$			;Yes - nothing needed here
	MOVB	f_modified[EDI], #1	;No - set it now
	MOVL	EDX, #mfgstr#
2$:	PUSHL	ESI
	MOVL	ESI, f_fwdb[EDI]
4$:	MOVL	EBX, w_stsline[ESI]
	ADDL	EBX, #stsmod		;And display the flag
	PUSHL	EDX
	CALL	dspstr
	POPL	EDX
	MOVL	ESI, w_next[ESI]
	CMPL	f_fwdb[EDI], ESI
	JNE	4$
	POPL	ESI
6$:	RET

;Subroutine to clear the modified state for a file
;	CALL	clrmfg

clrmfg::CMPB	f_modified[EDI], #0	;Is the flag already clear?
	JE	6$			;Yes - nothing needed here
	MOVB	f_modified[EDI], #0	;No - clear it now
	MOVL	EDX, #blkstr#		;And clear the flag on the status line
	JMP	2$

	.SBTTL	dspins - Subroutine to put I or O flag on the screen

;Subroutine to put I or O flag on the screen
;	CALL	dspins

dspins::MOVL	EBX, inspos#
	MOVB	AL, #'I'		;Assume insert mode
	CMPB	insflg, #0		;Right?
	JNE	10$			;Yes
	MOVB	AL, #'O'		;No - mode is overstrike
10$:	MOVB	[EBX], AL		;Store character
	RET
.PAGE
	.SBTTL	cmdrspclr - Subroutine to clear command and response lines

;Subroutine to clear command and response lines
;	CALL	cmdrspclr

cmdrspclr::
	CALL	cmdclr			;Clear the command line
					;Fall into rspclr to clear response line

	.SBTTL	rspclr - Subroutine to clear response line

;Subroutine to clear response line
;	CALL	rspclr

rspclr::PUSHL	EDI
	MOVL	EDI, rspline#		;Setup pointer
	MOVL	ECX, swidth#		;Get count
	SUBL	ECX, #6
	MOVB	AH, rspattrb#		;Get attributes
	JMP	2$

	.SBTTL	cmdclr - Subroutine to clear command line

;Subroutine to clear command line
;	CALL	cmdclr

cmdclr::PUSHL	EDI
	MOVL	EDI, cmdline#		;Setup pointer
	MOVL	ECX, swidth#		;Get count
	MOVB	AH, cmdattrb#		;Get attributes
2$:	MOVB	AL, #' '		;Get character
	MOVL	EBX, EAX
	SHLL	EAX, #16t
	MOVW	AX, BX
	PUSHL	DS
	POPL	ES
	SHRL	ECX, #1
	CLD
	RSTOSL	[EDI]			;Store in screen RAM
	POPL	EDI
	RET				;Finished
.PAGE
	.SBTTL	setsts - Subroutine to setup the status line display

;Subroutine to setup the status line display for a window
;	CALL	setsts

setsts::MOVL	EDI, w_stsline[ESI]	;First fill the line with background
	MOVL	ECX, w_width[ESI]	;  character
	PUSHL	DS
	POPL	ES
	MOVB	AL, #ASTSC
	MOVB	AH, islattrb#
	CLD
	RSTOSW	[EDI]
	MOVL	EDI, w_fdb[ESI]
	MOVL	EBX, w_stsline[ESI]	;Point to status line
	MOVL	EAX, ESI
	SUBL	EAX, #wdb0#-{'0'*w_SIZE}
	CLRL	EDX
	IDIVL	litw_SIZE#
	MOVB	[EBX], AL		;Store window number
	CMPB	f_modified[EDI], #0	;Has file been modified?
	JE	1$			;No
	MOVB	2[EBX], #'M'		;Yes - indicate that
1$:	MOVL	EBX, w_stsfilpos[ESI]	;Get place to put file name
	CMPL	w_width[ESI], #80t
	JB	2$
	MOVB	-2[EBX], #' '		;Store space in screen RAM
2$:	MOVL	EDX, w_fdb[ESI]		;Get offset of FDB
	ADDL	EDX, #f_filename	;Get offset of the file name
	CALL	dspstr			;Put file name on the status line
	CMPL	w_width[ESI], #80t
	JB	4$
	MOVB	[EBX], #' '		;Store space in screen RAM


4$:	MOVL	EBX, w_stslinpos[ESI]	;Get place to put number of lines
	ORL	EBX, EBX
	JE	8$
	CMPL	w_width[ESI], #80t
	JB	6$
	MOVB	-2[EBX], #' '		;Store space in screen RAM
6$:	PUSHL	ESI
	CALL	dspcurline
	ADDL	ESP, #4
	MOVB	[EBX], #'/'
	ADDL	EBX, #2
	PUSHL	EBX
	PUSHL	ECX
	PUSHL	f_numlin[EDI]
	CALL	dspnum			;Display it
	ADDL	ESP, #12t
	CMPL	w_width[ESI], #80t
	JB	8$
	MOVB	[EBX], #' '		;Store space in screen RAM
8$:	MOVL	EBX, w_stschrpos[ESI]	;Place to put number of characters
	ORL	EBX, EBX
	JE	12$
	CMPL	w_width[ESI], #80t
	JB	10$
	MOVB	-2[EBX], #' '		;Store space in screen RAM
10$:	PUSHL	EBX
	PUSHL	#8t
	PUSHL	f_numchr[EDI]
	CALL	dspnum			;Display it
	ADDL	ESP, #12t
	CMPL	w_width[ESI], #80t
	JB	12$
	MOVB	[EBX], #' '		;Store space in screen RAM
12$:	MOVL	EBX, w_stshcppos[ESI]	;Get place to display cursor position
	ORL	EBX, EBX
	JE	16$
	CMPL	w_width[ESI], #80t
	JB	14$
	MOVB	-2[EBX], #' '
14$:	MOVL	EAX, #0		;;;;;;;;;
	CALL	dsphcp2
	CMPL	w_width[ESI], #80t
	JB	16$
	MOVB	[EBX], #' '		;Store space in screen RAM
16$:	MOVB	DH, islattrb#
	MOVB	DL, #0B3
	CALL	border			;Setup border for inactive state
	MOVL	EDI, w_fdb[ESI]
	RET
.PAGE
	.SBTTL	dsphcp - Subroutine to display horizontal cursor position

;Subroutine to display horizontal cursor position
;	c[EAX] = Horizontal cursor position
;	CALL	dsphcp

dsphcp::MOVL	ESI, cw#
	MOVL	EBX, w_stshcppos[ESI]
	ORL	EBX, EBX
	JE	ret005
dsphcp2:INCL	EAX
	PUSHL	EBX
	PUSHL	#3t
	PUSHL	EAX
	CALL	dspnum
	ADDL	ESP, #12t
	RET

	.SBTTL	dspnum - Subroutine to display decimal number

;Subroutine to display decimal number in 5 place field
;	void dspnum(
;		long value,	// Value to display
;		int  minlen,	// Minimum field length
;		long offset)	// Offset in screen RAM at which to display
;				//   value

arg_value=!4t
arg_minlen=!8t
arg_offset=!12t

dspnum::MOVL	EAX, arg_value[ESP]
	MOVB	CL, arg_minlen[ESP]
	MOVL	EBX, arg_offset[ESP]
	CMPL	EBX, #scrnbufr
	JB	ret005
	PUSHL	DS
	POPL	ES
	MOVB	CH, #0			;Clear counter
4$:	CLRL	EDX
	DIVL	lit10#
	PUSHL	EDX			;Save remainder on stack
	INCB	CH			;Count it
	ORL	EAX, EAX		;Is result 0 now?
	JNE	4$			;No - go on
	SUBB	CL, CH			;Yes - calculate number of leading
					;  spaces needed
	JLE	8$			;If none needed
	PUSHL	ECX
6$:	MOVB	[EBX], #' '		;Store space in screen RAM
	ADDL	EBX, #2			;Bump pointer
	DECB	CL			;Need more?
	JNE	6$			;Yes - continue
	POPL	ECX
8$:	POPL	EAX			;Get digit value
	ADDB	AL, #'0'		;Change to ASCII character
	MOVB	[EBX], AL		;Store in screen RAM
	ADDL	EBX, #2			;Bump pointer
	DECB	CH			;More on stack?
	JNE	8$			;Yes
ret005:	RET				;No - finished
.PAGE
	.SBTTL	dsprsp - Subroutine to display string on the response line

;Subroutine to display string of characters terminated by null on the response
;   line
;	c{EDX} = Offset of string
;	CALL	dsprsp

dsprsp::CALL	rspclr			;Clear the line
	MOVL	EBX, rspline		;Point to start of response line
					;Fall into dspstr

	.SBTTL	dspstr - Subroutine to display string

;Subroutine to display string of characters terminated by null
;	c{EBX} = Offset in screen RAM for start of string
;	c{EDX} = Offset of string
;	CALL	dspstr

dspstr::CMPL	EBX, #scrnbufr		;Really want to do output?
	JB	ret005			;No - forget it
4$:	MOVB	AL, [EDX]		;Get character
	ORB	AL, AL			;End of string?
	JE	ret005			;Return if end
	INCL	EDX			;Bump pointer
	MOVB	[EBX], AL		;Store in screen RAM
	INCL	EBX			;Bump pointer
	INCL	EBX
	JMP	4$			;Continue

	.SBTTL	cmdques - Subroutine to display question and get answer

;Subroutine to display question and get answer - the question is displayed on
;  the command line
;	c{EDX} = Offset of string to display
;	CALL	cmdques
;	Z:set = Answer was Y or y
;	Z:clr = Answer was anything except Y or y

cmdques::
	CALL	cmdclr			;Clear the command line
	MOVL	EBX, cmdline#		;Display question on the command line
	CALL	dspstr
	ADDL	EBX, #-scrnbufr		;Calculate cursor position
	SHRL	EBX, #1
	CALL	cursorst2		;Put cursor in right place
	CALL	getkb#			;Get character from keyboard
	MOVZBL	EAX, AL
	CALL	makupr#			;Make sure upper case
	CMPB	AL, #'Y'		;Did he say Y?
	RET
.PAGE
	.SBTTL	cmdcuron - Subroutine to put the command cursor on the screen

;Subroutine to put the command or idle window cursor on the screen
;	C(AL) = Attribute byte to use
;	CALL	cmdcuron

cmdcuron::
	PUSHL	EAX
	CALL	curchk
	ADDL	EAX, EAX
	MOVL	w_usrcur[ESI], EAX
	POPL	EBX
	MOVB	scrnbufr+1[EAX], BL	;Set to inverse video and blink
	RET

	.SBTTL	cmdcuroff - Subroutine to remove command cursor from screen

;Subroutine to remove the command cursor from the screen
;	CALL cmdcuroff

cmdcuroff::
	MOVL	EBX, w_usrcur[ESI]	;Get offset of character under cursor
	MOVB	AL, w_txtattrb[ESI]	;Get normal text attribute value
	MOVB	scrnbufr+1[EBX], AL	;Restore it
	RET				;Thats all
.PAGE
	.SBTTL	curchk - Subroutine to check horizontal window position

;Subroutine to check horizontal position, shift window if necessary and
;  calculate cursor position in window
;	CALL	curchk
;	c{EAX} = Position for cursor

;THIS SUBROUTINE IS CALLABLE FROM C CODE

curchk::PUSHL	ESI
	MOVL	ESI, cw#
	MOVB	CH, w_cursorinb[ESI]	;Get position in line buffer
	CLRL	EDX			;Initialize position
	ORB	CH, CH
	JE	8$			;If at start of line buffer
	MOVL	EBX, w_curlinbuf[ESI]	;Point to line buffer
2$:	MOVB	AL, [EBX]		;Get character
	INCL	EBX			;Bump pointer
	CMPB	AL, #HT			;Horizontal tab?
	JE	4$			;Yes
	INCL	EDX			;Bump position
	JMP	6$

;Here with horizontal tab character

4$:	INCL	EDX			;No - advance position
	TESTB	DL, tabmask#		;At next tab stop?
	JNE	4$			;No - continue
6$:	DECB	CH			;Yes - at right place in line buffer?
	JNE	2$			;No - continue scan

;Here with cursor position in virtual line - now ensure it will be on the
;  screen
;	c{EDX} = Cursor position in line

8$:	MOVL	w_cursorinv[ESI], EDX	;Store position in virtual line
	CMPL	ESI, #wdb0#		;In command mode?
	JE	10$			;Yes
	PUSHL	EDX			;No
	MOVL	EAX, EDX		;Get in right register
	CALL	dsphcp			;Display the position
	POPL	EDX
10$:	MOVL	EAX, w_left[ESI]	;See if too far left
	CMPL	EDX, EAX
	JAE	12$			;Not too far left - see if to far
	MOVL	EAX, EDX		;  right
	JMP	14$			;Continue

;Here if not too far left - see if too far right

12$:	ADDL	EAX, w_width[ESI]
	CMPL	EDX, EAX
	JB	16$			;If screen OK where it is
	MOVL	EAX, EDX
	SUBL	EAX, w_width[ESI]	;Too far right - calculate new position
	ADDL	EAX, #8			;Round up
14$:	ANDB	AL, #0xF8		;Round modulo 8 to minimize screen
					;  shifting when scanning a line
	CMPL	EAX, w_left[ESI]	;Is this really a new position?
	JE	16$			;No - false alarm!
	MOVL	w_left[ESI], EAX	;Yes - update screen position
	PUSHL	EDX			;Save cursor position
	CALL	updwinfrc		;Update entire window
	POPL	EDX			;Restore position
16$:	MOVL	EBX, EDX		;Get in right register
	SUBL	EBX, w_left[ESI]	;Adjust for window position
	ADDL	EBX, w_hpos[ESI]
	MOVL	EAX, w_vpos[ESI]	;Calculate character offset in window
	ADDL	EAX, w_curlin[ESI]
	SUBL	EAX, w_toplin[ESI]
	IMULL	EAX, swidth#
	ADDL	EAX, EBX
	POPL	ESI
	RET				;And return
.PAGE
	.SBTTL	shiftu - Subroutine to shift window up

;Subroutine to shift window up (moves cursor down if necessary)
;	c{EBX} = Number of lines to shift window
;	CALL	shiftu

shiftu::MOVL	EAX, w_curlin[ESI]	;Calculate line in window
	MOVL	EDX, w_toplin[ESI]
	SUBL	EAX, EDX
	ADDL	EAX, EBX		;Plus amount to shift
	CMPL	EAX, w_scrollb[ESI]	;Too much?
	JAE	2$			;Yes
	SUBL	EDX, EBX		;No - reduce top line
	JNC	scrl08			;If not already at top of file
	NEGL	EBX
	JMP	11$

2$:	MOVL	EAX, w_curlin[ESI]
	SUBL	EAX, EBX
	JNC	4$
	CLRL	EAX
	MOVL	w_curlin[ESI], EAX
	JMP	6$

4$:	MOVL	w_curlin[ESI], EAX
	CMPB	w_toplin[ESI], #0	;Is display at top of file now?
	JE	6$			;Yes - just leave it here
	MOVL	EAX, f_numlin[EDI]	;Too close to end of file?
	SUBL	EAX, w_curlin[ESI]
	ADDL	EAX, w_scrollb[ESI]
	CMPL	EAX, w_height[ESI]
	JA	shiftu			;No
6$:	CALL	scroll			;Yes - just move 1 line
	JMP	chkbind

	.SBTTL	shiftd - Subroutine to shift window down

;Subroutine to shift window up (moves cursor down if necessary)
;	c{EBX} = Number of lines to shift window
;	CALL	shiftdn

shiftd::MOVL	EAX, w_curlin[ESI]	;Calculate line in window
	MOVL	EDX, w_toplin[ESI]
	SUBL	EAX, EDX
	SUBL	EAX, EBX		;Minus amount to shift
	JC	14$			;If too much
	CMPL	EAX, w_scrollt[ESI]	;Too high?
	JB	14$			;Yes
	ADDL	EDX, EBX		;No - move screen without changing
					;  current line
	MOVL	EAX, f_numlin[EDI]	;See if to close to end of file
	SUBL	EAX, w_height[ESI]
	INCL	EAX
	CMPL	EDX, EAX
	JBE	scrl08
11$:	MOVL	ECX, EBX		;At bottom - all we can do is move
	JMP	movvrt#			;  the current line down

;Here if need to change current line

14$:	MOVL	EAX, EBX
	ADDL	EAX, w_curlin[ESI]
	CMPL	EAX, f_numlin[EDI]
	JB	16$
	MOVL	EBX, f_numlin[EDI]
	MOVL	w_curlin[ESI], EBX
	JMP	6$

16$:	MOVL	w_curlin[ESI], EAX
	MOVL	EAX, f_numlin[EDI]	;Is display at bottom of file now?
	SUBL	EAX, w_toplin[ESI]
	INCL	EAX
	CMPL	EAX, w_height[ESI]
	JE	6$
	MOVL	EAX, w_curlin[ESI]
	CMPL	EAX, w_scrollt[ESI]	;Too close to beginning of file?
	JA	shiftd			;No
	MOVL	EBX, EAX		;Yes - just move 1 line
	JMP	6$
.PAGE
	.SBTTL	scroll - Subroutine to process window scrolling

;Subroutine to determine if we need to move the window to keep the current
;  line in the middle range of the window
;	CALL	scroll

scroll::MOVL	ESI, cw#
	MOVL	EDI, w_fdb[ESI]
	MOVL	EBX, f_numlin[EDI]	;Get distance from bottom of window to
	INCL	EBX			;  end of file
	SUBL	EBX, w_height[ESI]
	JNC	2$			;If file is smaller than the window
	CLRL	EDX
	JMP	scrl08

2$:	MOVL	EDX, w_curlin[ESI]	;Calculate maximum allowable value
	SUBL	EDX, w_scrollt[ESI]	;  for toplin
	JNC	4$			;Before beginning now?
	CLRL	EDX			;Yes - put top at beginning
4$:	CMPL	EDX, EBX		;Will the value we just found put the
					;  window past the EOF?
	JB	6$			;No - use it
	MOVL	EDX, EBX		;Yes - make it as high as we can!

;Here with maximum allowable value for toplin
;	c{EDX} = Maximum allowable value for toplin
;  Now see if the current value of toplin is too high

6$:	CMPL	EDX, w_toplin[ESI]	;Get current top of window
	JB	scrl08			;Currently too high - go set up new
					;  value for toplin

;Here to see if current value of toplin is too low

	MOVL	EDX, w_curlin[ESI]	;Calculate minimum top of window
	INCL	EDX			;  line number
	SUBL	EDX, w_scrollb[ESI]
	JNS	8$			;Don't let it be before beginning of
	CLRL	EDX			;  file!
8$:	CMPL	EDX, EBX		;Will the value we just found put the
					;  window past the EOF?
	JB	10$			;No - use it
	MOVL	EDX, EBX		;Yes - make it as high as we can!

;Here with c{EDX} = Minimum allowable value for toplin

10$:	CMPL	w_toplin[ESI], EDX	;Is the current value of toplin too
					;  small?
	JNC	18$			;No - don't change toplin!

;Here with c{EDX} = New value for toplin

scrl08:	MOVL	ECX, EDX		;Get value in right register
	MOVL	EDX, w_toplin[ESI]	;Get previous value
	MOVL	w_toplin[ESI], ECX	;Store new value
	SUBL	ECX, EDX		;Calculate difference
	JE	18$			;If no change
	JNC	14$			;If advancing
	MOVL	ECX, w_toplin[ESI]	;Backing up - must start at beginning
	LEAL	EBX, f_filbfr[EDI]	;Point to first line in file buffer
	JMP	16$

;Here if need to advance top of window toward EOF

14$:	MOVL	EBX, w_toppnt[ESI]	;Point to current top of window line
16$:	CALL	advance#		;Advance pointer down the file
	MOVL	w_toppnt[ESI], EBX	;Store new pointer

;Here if do not need to move window or with window moved and display updated
	
18$:	MOVL	EBX, w_curlin[ESI]	;Calculate distance between current
	SUBL	EBX, w_toplin[ESI]	;  line and top of window line
	MOVL	ECX, EBX		;Save it for advance
	MOVL	EBX, w_toppnt[ESI]	;Point to top of window
	CALL	advance#		;Advance pointer to current line
	MOVL	w_curpnt[ESI], EBX	;Update pointer to current line
	CALL	getline#		;Update line buffer from file buffer
	PUSHL	ESI
	CALL	dspcurline		;Diplay number of current line
	ADDL	ESP, #4
	RET
.PAGE
;Subroutine to determine the most reasonable place to put the cursor in the new
;  line - if the previous position would place it beyond the end of the new
;  line, we place it at the end; if it would place it in the middle of a
;  horizontal tab, we place it on the tab character
;	CALL	chkbind

chkbind::
	CMPL	w_cursorbind[ESI], #-1	;Should we do this now?
	JE	ret009			;No - finished
	MOVZBL	ECX, w_curlincnt[ESI]	;Yes - get line length
	ORL	ECX, ECX
	JNE	18$
	INCL	ECX
18$:	CLRL	EDX			;Clear position
	MOVL	EBX, w_curlinbuf[ESI]	;Point to the line buffer
20$:	DECL	ECX			;More in this line?
	JE	30$			;No
	CMPL	EDX, w_cursorbind[ESI]	;Yes - past desired cursor position?
	JNC	28$			;Yes
	CMPB	[EBX], #09h		;No - tab character?
	JNE	24$			;No
22$:	INCL	EDX			;Yes - bump position
	TESTB	DL, tabmask#		;At tab stop now?
	JNE	22$			;No - continue until we are
	JMP	26$			;Yes

;Here if not tab character

24$:	INCL	EDX			;Bump position
26$:	INCL	EBX			;Bump pointer
	JMP	20$			;Continue

;Here when at or past previous cursor position

28$:	JE	30$			;Past previous position?
	DECL	EBX			;Yes - back up one!
30$:	SUBL	EBX, w_curlinbuf[ESI]	;Calculate new cursor position
	MOVB	w_cursorinb[ESI], BL	;And store it
	CLC				;Clear C
ret009:	RET				;Finished!
.PAGE
	.SBTTL	fixwindows - Subroutine to fix up window values

;Subroutrine to fix up window values when the file buffer is changed
;	c{ECX} = Number of lines added or deleted (+ if added, - if deleted)
;	c{EDX} = First line added or deleted

$$$=!0
FRM fix_line  , 4t
FRM fix_num   , 4t
FRM fix_curpnt, 4t
FRM fix_curlin, 4t
fix_SIZE=!$$$

fixwindow::
	ENTER fix_SIZE, 0

	CMPL	cw#, #wdb0#
	JE	20$

	MOVL	fix_line[EBP], EDX
	MOVL	fix_num[EBP], ECX
	MOVL	EAX, w_curpnt[ESI]
	MOVL	fix_curpnt[EBP], EAX
	MOVL	EAX, w_curlin[ESI]
	MOVL	fix_curlin[EBP], EAX
4$:	MOVL	ESI, w_next[ESI]
	CMPL	ESI, curwin#
	JE	20$
	MOVL	EAX, fix_line[EBP]	;Is the top of the screen above where we
	CMPL	w_toplin[ESI], EAX	;  added or deleted?
	JBE	8$			;No
	MOVL	ECX, fix_num[EBP]	;Yes
	JREGZ	ECX, 14$
	ADDL	w_toplin[ESI], ECX	;Adjust the current line number
	CMPL	w_toplin[ESI], EAX	;Is it less than where the change was?
	JAE	6$			;No
	MOVL	w_toplin[ESI], EAX	;Yes - don't make it less
6$:	MOVL	EAX, f_numlin[EDI]	;Is it beyond the end of file?
	CMPL	w_toplin[ESI], EAX
	JBE	8$			;No
	MOVL	w_toplin[ESI], EAX	;Yes - put it and the end
8$:	MOVL	EAX, fix_line[EBP]	;Is the current line above where we
	CMPL	w_curlin[ESI], EAX	;  added or deleted?
	JBE	4$			;No
	MOVL	ECX, fix_num[EBP]	;Yes
	ADDL	w_curlin[ESI], ECX	;Adjust the current line number
	CMPL	w_curlin[ESI], EAX	;Is it less than where the change was?
	JAE	10$			;No
	MOVL	w_curlin[ESI], EAX	;Yes - don't make it less

;qqqqqqqqqqqqqqqq

10$:	MOVL	EAX, f_numlin[EDI]	;Is it beyond the end of file?
	CMPL	w_curlin[ESI], EAX
	JBE	12$			;No
	MOVL	w_curlin[ESI], EAX	;Yes - put it and the end

;qqqqqqqqqqqqqqqq

12$:	PUSHL	ESI
	CALL	dspcurline
	ADDL	ESP, #4
14$:	MOVL	ECX, w_toplin[ESI]

	SUBL	ECX, fix_curlin[EBP]
	MOVL	EBX, fix_curpnt[EBP]
	CALL	advance#
	MOVL	w_toppnt[ESI], EBX

	MOVL	ECX, w_curlin[ESI]
	SUBL	ECX, w_toplin[ESI]
	CALL	advance#
	MOVL	w_curpnt[ESI], EBX
	JMP	4$

20$:	LEAVE
	RET
