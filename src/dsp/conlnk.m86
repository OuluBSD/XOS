	.TITLE	conlnk - Common console display routines for XOS

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

;This link driver acts as a terminal device for TRMCLS and connects to the
;  console display device driver (usually VGAADEV) and to the  keyboard device
;  class driver (KBDCLS) which acts as a link driver connecting to one or more
;  physical keyboard drivers. Only a one console display device (and thus only
;  one driver) can be used. Currently the only supported console display driver
;  is VGAADRV although it is possible to implement alternamte drivers. In
;  previous XOS versions EGA and monochrome display drivers have been supported
;  but these are now obsolete and are no longer supported.

	.PROC	80486
	.INCLUD	xosinc:\xmac\xos.par
	.INCLUD	xosinc:\xmac\xosx.par
	.INCLUD	xosinc:\xmac\xoserr.par
	.INCLUD	xosinc:\xmac\xostrm.par
	.INCLUD	xosinc:\xmac\xosxtrm.par
	.INCLUD	xosinc:\xmac\xosxkbd.par
	.INCLUD	xosinc:\xmac\xosdos.par
	.INCLUD	xosinc:\xmac\pcat.par
	.INCLUD	xosinc:\xmac\xoslke.par
	.INCLUD	xosinc:\xmac\xosxlke.par

	.SBTTL	condctbl - Console driver device characteristics table

MAJV   =!1t
MINV   =!0t
EDITNUM=!2t

;1.0.1  4-Dec-94
;	Fixed problem in conDosSetup, stack was messed up if display already
;	set up for DOS use.
;1.0.2	8-Oct-00
;	Add code to set the MSS$NODEALOC bit when creating an msect which
;	maps a display.

	LKEHEAD	CONLNK, MAJV, MINV, EDITNUM, LKETYPE_LINK

	.EXPORT	xosconAttrib
	.EXPORT	xosconChkBiosMd
	.EXPORT	xosconClrPgChng
	.EXPORT	xosconDosChk
	.EXPORT	xosconDosSet
	.EXPORT	xosconDosUpd
	.EXPORT	xosconDosUpdCP
	.EXPORT	xosconDosUse
	.EXPORT	xosconDspNrm
	.EXPORT	xosconGetBiosMd
	.EXPORT	xosconConnectKeyboard
	.EXPORT	xosconRemoveKeyboard
	.EXPORT	xosconMakeTdb
	.EXPORT	xosconMapPhys
	.EXPORT	xosconOpen1
	.EXPORT	xosconOutBlk
	.EXPORT	xosconOutChr
	.EXPORT	xosconResume
	.EXPORT	xosconScanMs
	.EXPORT	xosconToKeyboard
	.EXPORT	xosconUnmap
	.EXPORT	xosconUpdPgList

;Console device characteristiics table

condctbl:
 CHARBGN  1, sysIoCharValues##
 CHARENT  CLASS   , TEXT,  ,  8, knlDcMsgClass##    , knlDcGetClass##   , knlDcSetClass##   , 0
 CHARENT  TYPE    , TEXT,  ,  4, knlDcMsgType##     , knlDcGet4Byte##   , 0                 , dcb_typename
 CHARENT  OPENCNT , DECV,  ,  4, knlDcMsgOpenCnt##  , knlDcGet4Byte##   , 0                 , dcb_opencnt
 CHARENT  DISPTYPE, STR ,  , 64, msgdisptype        , getdisptext       , setdisptext       , dhdb_dispname
 CHARENT  DISPDESC, STR ,  , 64, msgdispdesc        , getdisptext       , setdisptext       , dhdb_dispdesc
 CHARENT  DISPVER , STR ,  , 64, msgdispver         , getdisptext       , setdisptext       , dhdb_dispver
 CHARENT  DISPVEN , STR ,  , 64, msgdispven         , getdisptext       , setdisptext       , dhdb_dispven
 CHARENT  DISPREV , STR ,  , 64, msgdisprev         , getdisptext       , setdisptext       , dhdb_disprev
 CHARENT  DISPBUFR, DECV,  ,  4, msgdispbufr        , getdispbufr       , 0                 , dhdb_npages
 CHARENT  PCIVEN  , HEXV,  ,  4, xospciMsgVen##     , xosconGet2BDhdb   , xosconSet2BDhdb   , dhdb_pciven
 CHARENT  PCIDEV  , HEXV,  ,  4, xospciMsgDev##     , xosconGet2BDhdb   , xosconSet2BDhdb   , dhdb_pcidev
 CHARENT  PCISSVEN, HEXV,  ,  4, xospciMsgSSVen##   , xosconGet2BDhdb   , xosconSet2BDhdb   , dhdb_pcissven
 CHARENT  PCISSDEV, HEXV,  ,  4, xospciMsgSSDev##   , xosconGet2BDhdb   , xosconSet2BDhdb   , dhdb_pcissdev
 CHARENT  VERTFREQ, DECV,  ,  4, msgvertfreq        , getvertfreq       , setvertfreq       , 0
 CHARENT  NUMSCN  , DECV,  ,  4, msgnumscn          , xosconGet4BDhdb   , 0                 , dhdb_num
 CHARENT  SCSVTIME, DECV,  ,  2, msgscsvtime        , getscsvtime       , setscsvtime       , 0
 CHARENT  SCSVTYPE, TEXT,  ,  8, msgscsvtype        , getscsvtype       , setscsvtype       , 0
 CHARENT  KBLIST  , STR ,  , 64, msgkblist          , getkblist         , 0                 , 0
 CHARENT  BELLFREQ, DECV,  ,  2, knlTrmMsgBFreq##   , knlTrmGet2Byte##  , knlTrmSet2Byte##  , tdb_spkfreq
 CHARENT  BELLLEN , DECV,  ,  2, knlTrmMsgBLen##    , knlTrmGet2Byte##  , knlTrmSet2Byte##  , tdb_spklen
 CHARENT  IOUTFLOW, TEXT,  ,  8, knlTrmMsgIOFlow##  , knlTrmGetOFlow##  , setflow           , tdb_iflow
 CHARENT  OUTFLOW , TEXT,  ,  8, knlTrmMsgOFlow##   , knlTrmGetOFlow##  , setflow           , tdb_flow
 CHARENT  SESSION , TEXT,  ,  4, knlTrmMsgSession## , knlTrmGetSession##, knlTrmSetSession##, 0
 CHARENT  MSGDST  , STR ,  , 16, knlTrmMsgMsgDst##  , knlTrmGetText##   , knlTrmSetText##   , tdb_msgdst
 CHARENT  PROGRAM , STR ,  , 16, knlTrmMsgProgram## , knlTrmGetText##   , knlTrmSetText##   , tdb_program
 CHARENT  ACCESS  , TEXT,  ,  4, knlDcMsgAccess##   , knlTrmGet4Byte##  , knlTrmSetAccess## , tdb_access
 CHARENT  PASSWORD, STR ,  , 12, knlTrmMsgPWrd##    , knlTrmGetText##   , knlTrmSetText##   , tdb_password
 CHARENT  IOPORTS , HEXV, H, 40, msgioports         , getioports        , 0                 , 0

; CHARENT  INRBS   , DECV, ,  2, knlTrmMsgInRBS##   , knlTrmGet4Byte##  , 0                 , tdb_irsize
; CHARENT  INRBSL  , DECV, ,  2, knlTrmMsgInRBSL##  , knlTrmGet4Byte##  , knlTrmSet4Byte##  , tdb_irbsl
; CHARENT  INRBPL  , DECV, ,  2, knlTrmMsgInRBPL##  , knlTrmGet4Byte##  , knlTrmSet4Byte##  , tdb_irbpl
; CHARENT  INRBHELD, DECV, ,  4, knlTrmMsgInRBHeld##, knlTrmGet4Byte##  , knlTrmSet4Byte##  , tdb_irheld
; CHARENT  INRBLOST, DECV, ,  4, knlTrmMsgInRBLost##, knlTrmGet4Byte##  , knlTrmSet4Byte##  , tdb_irlost

 CHARENT  INLBS   , DECV,  ,  2, knlTrmMsgInLBS##   , knlTrmGet4Byte##  , 0                 , tdb_ibsize
 CHARENT  CHAROUT , DECV,  ,  4, knlTrmMsgCharOut## , knlTrmGet4Byte##  , knlTrmSet4Byte##  , tdb_charout
 CHARENT  CHARIN  , DECV,  ,  4, knlTrmMsgCharIn##  , knlTrmGet4Byte##  , knlTrmSet4Byte##  , tdb_charin

;CHARENT  KBCHAR  , DECV, ,  4, knlTrmMsgKbChar##  , knlTrmGet4Byte##  , knlTrmSet4Byte##  , tdb_kbchar
;CHARENT  KBTCHAR , DECV, ,  4, knlTrmMsgKbTChar## , xosconGet4BDhdb   , xosconSet4BDhdb   , dhdb_kbtchar

 CHAREND

msgmouse:   CHARINFO  {Associated mouse device}
msgdisptype:CHARINFO  {Display adapter type}
msgdispdesc:CHARINFO  {Display adapter description}
msgdispver: CHARINFO  {Display adapter version}
msgdispven: CHARINFO  {Display adapter ventor}
msgdisprev: CHARINFO  {Display adapger revision}
msgdispbufr:CHARINFO  {Display buffer size (KB)}
msgnumscn:  CHARINFO  {Number of virtual screens}
msgscsvtime:CHARINFO  {Screen saver time (sec)}
msgscsvtype:CHARINFO  {Screen saver type}
msgkblist:  CHARINFO  {Keyboard unit list}
msgvertfreq:CHARINFO  {Graphics mode vert freq}
msgioports: CHARINFO  {VGA IO ports}

;The terminal function dispatch table is located in the lower level driver
;  for each console device.
.PAGE
	ONCE

	MOVL	EBX, lkei_pctop-4[ESP]
	MOVL	[EBX], #codetop
	CLRL	EAX
	RET	lkei_ADJ

	CODE
.PAGE
	.SBTTL	xosconConnectKeyboard - Connect console keyboard device

;Subroutine to connect a console keyboard device
;	long xosconConnectKeyboard
;	    DHDB *dhdb,		// Address of DHDB for this console
;	    DCB  *dcb);		// Address of DCB for keyboard device

ckb_dhdb=!8t
ckb_dcb =!4t

xosconConnectKeyboard::
	MOVL	EBX, ckb_dhdb[ESP] ;Link the keyboard DCB to the console's
	MOVL	EDX, ckb_dcb[ESP]  ;  list of keyboard DCBs
	LEAL	EAX, dhdb_kbdtbl[EBX]
	MOVL	ECX, #MAX_KBD
4$:	CMPL	[EAX], #0		;Is this slot empty?
	JE	8$			;Probably
6$:	ADDL	EAX, #4			;No
	LOOP	ECX, 4$
	MOVL	EAX, #ER_TMDVC
	JMP	12$

;Here with what is probably an empty slot

8$:	SLOCK	dhdb_kbdslck[EBX]
	CMPL	[EAX], #0		;Still empty?
	JE	10$			;Yes
	SRELS	dhdb_kbdslck[EBX]	;No - keep looking
	JMP	6$

10$:	MOVL	[EAX], EDX		;Grab the slot
	SRELS	dhdb_kbdslck[EBX]
	MOVL	dcb_kbddhdb[EDX], EBX
12$:	CLRL	EAX
	RET	8t			;Finished
.PAGE
;Function to disconnect a console keyboard device
;	long xosconRemoveKeyboard
;	    DCB *dcb);		// Address of DCB for keyboard device

rkb_dcb=!8t

xosconRemoveKeyboard::
	PUSHL	EDI
	MOVL	EDI, rkb_dcb[ESP]
	MOVL	EDX, dcb_kbddhdb[EDI]

;Find the keyboard in the list for the console

	ADDL	EDX, #dhdb_kbdtbl
	MOVL	ECX, #MAX_KBD

4$:	CMPL	[EDX], EDI		;This one
	JE	6$			;Yes
	ADDL	EDX, #4			;No - advance to next entry
	LOOP	ECX, 4$			;Continue if more to check
	MOVL	EAX, #ER_NTINS		;If not installed
	JMP	10$

;Here with the table entry for our keyboard

6$:	CLRL	EAX
	MOVL	[EDX], EAX		;Clear the table entry
	MOVL	dcb_kbddhdb[EDI], EAX
10$:	POPL	EDI
	RET	4
.PAGE
	.SBTTL	xosconMakeTdb - Subroutine to make console TDB

;Subroutine to make console TDB - must be called with the exec memory resource
;	c{ECX} = Size of the TDB
;	c(DH)  = Screen number
;	c{EDI} = Offset of DHDB
;	CALL	xosconMakeTdb
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal

xosconMakeTdb:
	CMPB	DH, #0
	JE	2$.S
	CMPB	DH, #VDSPMAX		;Is the screen number valid?
2$:	JAE	knlBadParmV##		;No - fail!
	MOVZBL	EBX, DH			;Is the screen defined now?
	CMPL	dhdb_tdbtbl-4[EDI+EBX*4], #0
	JNE	2$.S			;Yes - fail
	PUSHL	EDI			;No
	MOVB	DL, dhdb_unit[EDI]	;Get unit number
	MOVL	EBX, dhdb_typename[EDI]	;Get console driver type name
	MOVL	EAX, #{IRSIZE<16t}+IBSIZE
	CALL	knlTrmMakeTdb##		;Make a TDB
	POPL	EDI
	JC	10$			;If error
	MOVB	tdb_ifdsp[ESI], #0	;Indicate terminal does not do queued
					;  output
	MOVL	tdb_mdb[ESI], #0	;No associated mouse device
	MOVB	tdb_stsmisc[ESI], #TSM$MAPPED ;Indicate mapped terminal
	MOVL	EAX, dhdb_bioreg[EDI]	;Store base IO register
	MOVL	tdb_bioreg[ESI], EAX
	MOVL	EAX, dhdb_disptype[EDI] ;Store display type
	MOVL	tdb_disptype[ESI], EAX      ;Store offset of device
	MOVL	tdb_devchar[ESI], #condctbl ;  characteristics table
	MOVW	tdb_tattrval[ESI], #0707h ;Set initial text attribute values
	MOVW	tdb_battrval[ESI], #0707h
	MOVW	tdb_spkfreq[ESI], #893t ;Set initial bell tone frequency
	MOVW	tdb_spklen[ESI], #300t	;Set initial bell tone duration
	MOVL	tdb_escdsp[ESI], #xosconDspNrm ;Set initial ESC mode dispatch
	MOVL	tdb_response[ESI], #02000000h ;Initialize primary DA response

	MOVL	tdb_dhdb[ESI], EDI
	MOVZBL	EDX, tdb_snum[ESI]	      ;Store offset of the TDB in the
	MOVL	dhdb_tdbtbl-4[EDI+EDX*4], ESI ;  DHDB
	INCL	dhdb_num[EDI]		;Bump number of virtual screens
	MOVL	EAX, conltdb
	MOVL	conltdb, ESI		;Link into our list of TDBs
	TESTL	EAX, EAX
	JE	8$.S
	MOVL	tdb_nexts[EAX], ESI
	JMP	10$.S

8$:	MOVL	conftdb, ESI

	PUSHL	#conoas			;Setup our once-a-second routine
	CALL	sysSchSetUpOAS##
	CLC
10$:	RET
.PAGE
;Here to set 2 byte characteristic value in the DHDB

xosconSet2BDhdb:
	MOVL	ESI, dcb_trtdb[EDI]
	ADDL	EBX, tdb_dhdb[ESI]	;Get offset of the item
	MOVW	[EBX], AX
	CLC
	RET

;Here to set 4 byte characteristic value in the DHDB

xosconSet4BDhdb:
	MOVL	ESI, dcb_trtdb[EDI]
	ADDL	EBX, tdb_dhdb[ESI]	;Get offset of the item
	MOVL	[EBX], EAX
	CLC
	RET

;Here to set a DHDB text strint

setdisptext:
	MOVL	ESI, dcb_trtdb[EDI]
	ADDL	EDX, tdb_dhdb[ESI]
	JMP	knlSetSysStr##

;Here to set the value of the INFLOW or IINFLOW characteristic

setflow:MOVL	ESI, dcb_trtdb[EDI]
	PUSHL	EBX
	MOVL	ECX, #knlTRMIFLOWTBLDSZ## ;Process value
	MOVL	EBX, #knlTrmIFlowTblD##
	CALL	knlGetDcVal2##
	POPL	EBX
	JC	2$			;If error
	SHLB	AL, #4
	ANDB	[ESI+EBX], #0Fh
	ORB	[ESI+EBX], AL		;Store new value
2$:	RET
.PAGE
	.SBTTL	setscsvtime - Set value of SCSVTIME characteristic

;Here to set the value of the SCSVTIME characteristic

setscsvtime:
	MOVL	ESI, dcb_trtdb[EDI]
	MOVL	EDX, tdb_dhdb[ESI]	;Get offset of the DHDB
	MOVL	dhdb_scsvtime[EDX], EAX ;Store new value
	MOVL	dhdb_scsvcnt[EDX], EAX	;Also reset the counter
4$:	RET				;Finished

	.SBTTL	setscsvtype - Set value of SCSVTYPE characteristic

;Here to set the value of the SCSVTYPE characteristic

setscsvtype:
	MOVL	ESI, dcb_trtdb[EDI]
	MOVL	EBX, #scsvval
	MOVL	ECX, #SCSVVALSZ
	CALL	knlGetDcVal2##
	JC	6$
	MOVL	EDX, tdb_dhdb[ESI]	;Get offset of the DHDB
	MOVB	dhdb_scsvtype[EDX], AL	;Store new value
6$:	RET

	.MOD	4
scsvval:.LONG	'K'   , 0 , 1
	.LONG	'KEY' , 0 , 1
	.LONG	'F'   , 0 , 0
	.LONG	'FULL', 0 , 0
SCSVVALSZ=!{$-scsvval}/12t

;Here to set the value of the VERTFREQ characteristic

setvertfreq:
	MOVL	ESI, dcb_trtdb[EDI]
	MOVL	EBX, tdb_ddisp[ESI]
	JMPIL	tfx_setgvf[EBX]
.PAGE
;Here to get 2 byte characteristic value from the DHDB

xosconGet2BDhdb:
	MOVL	ESI, dcb_trtdb[EDI]
	ADDL	EBX, tdb_dhdb[ESI]	;Get offset of the item
	MOVZWL	EAX, [EBX]		;Get value
	CLC
	RET

;Here to get 4 byte characteristic value from the DHDB

xosconGet4BDhdb:
	MOVL	ESI, dcb_trtdb[EDI]
	ADDL	EBX, tdb_dhdb[ESI]	;Get offset of the item
	MOVL	EAX, [EBX]		;Get value
	CLC
	RET

;Here to get the value of the a DHDB text string characteristic

getdisptext:
	MOVL	ESI, dcb_trtdb[EDI]
	ADDL	EDX, tdb_dhdb[ESI]
	JMP	knlGetSysStr##

;Here to get the value of the DISPBUFR characteristic

getdispbufr:
	MOVL	ESI, dcb_trtdb[EDI]
	MOVL	EAX, tdb_gbfrsize[ESI]
	SHRL	EAX, #10t
	CLC
	RET
.PAGE
;Here to get the value of the SCSVTIME characteristic

getscsvtime:
	MOVL	ESI, dcb_trtdb[EDI]
	MOVL	EDX, tdb_dhdb[ESI]	;Get offset of the DHDB
	MOVL	EAX, dhdb_scsvtime[EDX] ;Get value
	CLRL	EDX
	RET

	.SBTTL	getscsvtype - Get value of SCSVTYPE characteristic

;Here to get the value of the SCSVTYPE characteristic

getscsvtype:
	MOVL	ESI, dcb_trtdb[EDI]
	MOVL	EDX, tdb_dhdb[ESI]	;Get offset of the DHDB
	MOVL	EAX, #'FULL'		;Assume FULL
	CMPB	dhdb_scsvtype[EDX], #0	;Right?
	JE	8$			;Yes
	MOVL	EAX, #'KEY'		;No
8$:	CLRL	EDX
	RET
.PAGE
;Here to get the value of the VERTFREQ characteristic

getvertfreq:
	MOVL	ESI, dcb_trtdb[EDI]
	MOVL	EBX, tdb_ddisp[ESI]
	JMPIL	tfx_getgvf[EBX]

	.SBTTL	getvertfreq - Get value of KBLIST characteristic

;Here to get the value of the KBLIST characteristic
;	c{EBX} = Address of user's string buffer
;	c{ECX} = Length of the buffer
;	CALL	getkblist
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{ECX} = Length of string stored in buffer

$$$=!0
FRM gkbl_pnt, 4
FRM gkbl_cnt, 4
gkbl_SIZE=!$$$

getkblist:
	ENTER	gkbl_SIZE
	MOVL	ESI, dcb_trtdb[EDI]
	MOVL	EAX, tdb_dhdb[ESI]
	DECL	ECX
	PUSHL	EDI
	PUSHL	EBX
	ADDL	EAX, #dhdb_kbdtbl
	MOVL	gkbl_pnt[EBP], EAX
	MOVL	gkbl_cnt[EBP], #MAX_KBD
	MOVL	EAX, #0x100		;Set AH as a flag that nothing done
2$:	MOVL	EDI, gkbl_pnt[EBP]
	ADDL	gkbl_pnt[EBP], #4
	MOVL	EDI, [EDI]
	TESTL	EDI, EDI
	JE	8$
	LEAL	EDX, dcb_name[EDI]
4$:	MOVZBL	EAX, [EDX]
	CMPB	AL, #0
	JE	6$
	DECL	ECX
	JS	16$
	IFFAULT	20$
	MOVB	[EBX], AL
	INCL	EDX
	INCL	EBX
	JMP	4$

6$:	SUBL	ECX, #2
	JS	16$
	MOVW	[EBX], #':,'
	ADDL	EBX, #2
8$:	DECL	gkbl_cnt[EBP]
	JNE	2$
	CMPB	AH, #0			;Did we store anything?
	JNE	10$			;No
	DECL	EBX			;Yes - remove the last comma
10$:	MOVB	[EBX], #0
	POPL	EAX
	MOVL	ECX, EBX
	SUBL	ECX, EAX
	CLRL	EAX
12$:	POPL	EDI
14$:	LEAVE
	RET

16$:	MOVL	EAX, #ER_CHARS
18$:	POPL	EBX
	STC
	JMP	12$	

	FAULTHDR
20$:	MOVL	EAX, #ER_ADRER
	JMP	18$
.PAGE
;Here to get the value of the IOPORTS characteristic
;	c{EBX} = Address of user's data area
;	CALL	getkblist
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{ECX} = Number of bytes stored

getioports:
	MOVL	ESI, dcb_trtdb[EDI]
	MOVL	EBX, tdb_ddisp[ESI]
	MOVL	EAX, tfx_iortbl[EBX]
	MOVL	ECX, [EAX]
	ADDL	EAX, #4
	CLC
	RET
.PAGE
;Subroutine to do mode checking for svcTrmDspMode routines
;	c{EAX} = Function bits
;	c{EBX} = Address of user data block
;	CALL	xosconChkBiosMd
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Function bits
;	  c{EBX} = Address of user data block
;	  c{EDX} = Address of data block containing values to use

xosconChkBiosMd::
	BTL	EAX, #DM%BIOSMODE	;Want to use a BIOS mode value?
	JC	4$.S			;Yes
	CMPB	AL, #DM_SETBASE		;No - special base value call?
	JAE	conbasemd.S		;Yes - go handle that
	BTL	EAX, #DM%USEDATA	;No - did he provide some data?
	JNC	2$.S			;No
	PUSHL	ES			;Yes - just copy his data block address
	POPL	FS
	MOVL	EDX, EBX
	CLC
	RET				;Thats all

;Here if no data was provided - point to a dummy data block containing all 0s

2$:	MOVL	EDX, #dummydata
	PUSHL	DS
	POPL	FS
	CLC
	RET

;Here if BIOS mode value was specified

4$:	MOVZBL	EAX, AL			;Clear all other bits
	BTZL	EAX, #7			;Want to clear the display
	JNC	6$.S			;Yes
	BTSL	EAX, #DM%NOCLEAR	;No
6$:	CMPB	AL, #7Fh		;Just want value returned?
	JNE	8$.S			;No
	MOVL	EAX, #DM$BIOSMODE	;Yes
	JMP	2$.S

;Here if really wants to set BIOS mode

8$:	CMPB	AL, #03h		;Valid mode?
	JE	10$.S
	CMPB	AL, #02h
	JNE	knlBadValue##		;No - fail
10$:	MOVB	AL, #DM_TEXT
	MOVL	EDX, #biosmode3		;Get address of data block for mode
	PUSHL	DS
	POPL	FS
	RET				;Finished

	DATA

	.MOD	4
biosmode3:
	.LONG	DM$BIOSMODE|DM_TEXT, 80t, 25t, 0, 0 ;Mode 3

dummydata:
	.BLKB	dm_SIZE

	CODE
.PAGE
;Here to set or use the base mode values

conbasemd:
	JA	4$.S			;If want to use base mode values
	MOVL	EAX, tdb_columns[ESI]	;Set base mode values from current
	MOVW	tdb_bcolumns[ESI], AX	;  mode values
	MOVB	AL, tdb_rows[ESI]
	MOVB	tdb_brows[ESI], AL
	MOVB	AL, tdb_mode[ESI]
	MOVB	tdb_bmode[ESI], AL
	MOVB	AL, tdb_dsppage[ESI]
	MOVB	tdb_bdsppage[ESI], AL
	MOVW	AX, tdb_curmode[ESI]
	MOVW	tdb_bcurmode[ESI], AX
2$:	CLRL	EAX
	RET

;Here to use base mode values - If the base mode values are different from
;  the current values, the mode is set to match the base values, otherwise
;  no change is made to the mode.  The screen colors are always reset to the
;  base values.

4$:	CALL	escatoff		;Reset the colors
	MOVB	AL, tdb_bmode[ESI]
	CMPB	tdb_mode[ESI], AL
	JNE	8$.S
	MOVZWL	EAX, tdb_bcolumns[ESI]
	CMPL	EAX, tdb_columns[ESI]
	JNE	8$.S
	MOVB	AL, tdb_brows[ESI]
	CMPB	AL, tdb_rows[ESI]
	JE	2$.S
8$:	MOVL	EDX, #modebfr		;Different - set up argument data
	PUSHL	DS
	POPL	FS
	MOVZWL	EAX, tdb_bcolumns[ESI]
	MOVL	dm_columns[EDX], EAX
	MOVZBL	EAX, tdb_brows[ESI]
	MOVL	dm_rows[EDX], EAX
	CLRL	EAX
	MOVL	dm_horiz[EDX], EAX
	MOVL	dm_vert[EDX], EAX
	MOVB	AL, tdb_bdsppage[ESI]
	MOVB	dm_actpage[EDX], AL
	MOVZBL	EAX, tdb_bmode[ESI]
	BTSL	EAX, #DM%USEDATA
	RET

	DATA

	.MOD	4
modebfr:.BLKB	dm_SIZE

	CODE
.PAGE
	.SBTTL	xosconGetBiosMd - Subroutine to get BIOS display mode value

;Subroutine to get BIOS display mode value for current XOS display mode
;	CALL	xosconGetBiosMd
;	c{EAX} = BIOS display mode

xosconGetBiosMd::
	MOVB	AL, #03h		;Always say 80 column color!
	CLC
ret004:	RET
.PAGE
;Function to call a keyboard function for all attached keyboards
;	void xosconToKeyboard(
;	    DHDB *dhdb,
;	    long  func,
;	    long  data);

tkb_dhdb=!20t
tkb_func=!16t
tkb_data=!12t

xosconToKeyboard::
	PUSHL	ESI
	PUSHL	EBX
	MOVL	EBX, tkb_dhdb[ESP]
	MOVL	ESI, #MAX_KBD
	ADDL	EBX, #dhdb_kbdtbl
4$:	MOVL	EDX, [EBX]
	TESTL	EDX, EDX
	JE	6$
	MOVL	EAX, dcb_kbddisp[EDX]
	PUSHL	EDX
	ADDL	EAX, tkb_func+4[ESP]
	PUSHL	tkb_data+4[ESP]
	CALLI	[EAX]
6$:	ADDL	EBX, #4
	DECL	ESI
	JNE	4$
	POPL	EBX
	POPL	ESI
	RET	12t
.PAGE
;Function called when terminal is opened the first time

xosconOpen1::
	MOVL	EAX, #DM_TEXT
	TESTL	knlTda+tdaCmd##, #XO$PHYS|XO$RAW ;Physical IO?
	JNE	4$			;Yes - don't initialize the display mode
	MOVL	EBX, tdb_ddisp[ESI]	;No
	CALLI	tfx_dspmode[EBX]
	MOVL	EAX, #DM_SETBASE	;Make this the base mode
	MOVL	EBX, tdb_ddisp[ESI]
	CALLI	tfx_dspmode[EBX]
4$:	MOVL	EBX, tdb_ddisp[ESI]
	CALLI	tfx_opena[EBX]
	MOVL	EBX, tdb_dhdb[ESI]
	TESTL	EBX, EBX
	JE	ret004
	PUSHL	EBX
	PUSHL	#kfx_open
	PUSHL	#0
	CALL	xosconToKeyboard
	RET
.PAGE
	.SBTTL	xosconDosSet - Function to set up console for real mode

;Function to set up console for real mode - sets up the screen mapping and the
;  data block needed for keyboard interrupts
;	c{EDI} = Offset of controlling terminal DCB
;	c{ESI} = Offset of controlling terminal TDB
;	CALL	xosconDosSet
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Size of currently mapped buffer (0 means not mapped)
;	  c{EDX} = Offset of currently mapped buffer (meaningless if not mapped)


;;;1$:	POPL	ESI
;;;	RET

xosconDosSet::

	CRASH	????

	PUSHL	EDI
;;;;;	CMPB	knlPda+pdaVMode##, #0	;Currently mapped?
;;;;;	JNS	8$			;Yes
;;;;;	MOVB	AL, tdb_mode[ESI]
;;;;;	MOVB	knlPda+pdaVMode##, AL
	PUSHL	EBP
	MOVL	EDX, #0A0000h		;Get virtual address
	MOVL	ECX, #18000h		;Get amount to fill (display is always
					;  at B8000)
	MOVL	EBP, #0FFF8h		;Get segment selector
	PUSHL	ESI
	MOVL	ESI, knlNonExMem##	;Get physical address to use
	MOVL	EDI, #0FFFFh		;Get increment mask for physical address
	MOVB	BL, #PG$WRITE|PG$READ	;Get page bits
;;;;;	CALL	knlMapPhysMem##		;Map physical memory below the display
	POPL	ESI
	JC	4$			;If error
	MOVL	EDX, #0B8000h		;Get virtual address of buffer
	MOVL	ECX, #8t		;Get amount to map
	SHLL	ECX, #12t
	LEAL	EAX, [ECX+EDX]
	PUSHL	EAX
	MOVL	EBP, #0FFF8h		;Get segment selector
	MOVB	BL, #PG$WRITE|PG$READ	;Get page bits
	MOVL	EAX, tdb_ddisp[ESI]
	PUSHL	#2$
	PUSHL	tfx_mapphys[EAX]
	CLRL	EAX
	RET				;This is really a CALLI to the
					;  tfx_mapphys routine
2$:	POPL	EDX
	JC	4$.S			;If error
	MOVL	ECX, #0C0000h		;Calculate amount left above buffer
	SUBL	ECX, EDX
	JLE	6$.S			;If nothing left
	PUSHL	ESI			;Map space above buffer
	MOVZWL	ESI, DX
	ORL	ESI, knlNonExMem##	;Get physical address to use
	MOVL	EDI, #0FFFFh		;Get increment mask for physical address
	MOVL	EBP, #0FFF8h		;Get segment selector
	MOVB	BL, #PG$WRITE|PG$READ	;Get page bits
;;;;;	CALL	knlMapPhysMem##
	POPL	ESI
	JNC	6$

	JMP	6$		;#############

4$:	POPL	EBP
;;;;;	MOVB	knlPda+pdaVMode##, #0xFF ;Indicate not mapped
	POPL	EDI
	RET

;Here with screen mapping setup

6$:	POPL	EBP
8$:	POPL	EDI
	MOVW	bda_vdsp6845, #P_EGACCRTINDX ;Store display adaptor port number

;NEED TO FINISH WHAT FOLLOWS!!!!

	CALL	xosconGetBiosMd		;Get the BIOS mode value
	MOVB	bda_vvidmode, AL

	MOVB	DL, #01h		;EGA or VGA color mode

;;;; NEED TO GET CORRECT NUMBER OF FLOPPIES HERE!!!

10$:	MOVL	EAX, #2			;Get number of floppies
	TESTL	EAX, EAX		;Do we have any at all?
	JE	14$			;No - go on
	INCL	EDX			;Yes - set bit 0
	CMPL	EAX, #4			;More than 4 floppies?
	JB	12$
	MOVB	AL, #4			;Yes - just say 4
12$:	DECL	EAX
	SHLB	AL, #6t
	ORB	DL, AL
14$:	MOVL	EAX, #1			;Get number of serial ports
	CMPL	EAX, #7			;More than 7?
	JB	16$			;No
	MOVB	AL, #7			;Yes - just say 7
16$:	ADDB	AL, AL
	MOVB	DH, AL
	MOVL	EAX, #1			;Get number of parallel ports
	CMPL	EAX, #3			;More than 3?
	JB	18$			;No
	MOVB	AL, #3			;Yes - just say 3
18$:	SHLB	AL, #6t
	ORB	DH, AL			;Store equipment configuration byte
	MOVW	bda_vconfig, DX
	MOVL	EAX, tdb_columns[ESI]	;Get screen width
	MOVW	bda_vvidwidth, AX
	MOVZBL	EBX, tdb_rows[ESI]	;Get screen height
	IMULL	EAX, EBX		;Calculate buffer size
	ADDL	EAX, EAX
	ADDL	EAX, #0FFh
	MOVB	AL, #0			;Round up
	MOVW	bda_vvidblen, AX	;Store it
	DECL	EBX			;Also store rows - 1
	MOVB	bda_vrows, BL
	MOVB	AL, tdb_charch[ESI]	;Get character cell height
	MOVB	bda_vpoints, AL
	MOVB	bda_vvidinfo, #62h ;TEMP!!!!!
	MOVB	bda_vegainfo, #16h ;TEMP!!!!!
	MOVL	EBX, #bda_vcnfgdata	;??????????
	MOVW	[EBX], #8
	MOVL	EAX, knlMachType##
	MOVL	2[EBX], EAX
	CLRL	EAX
	MOVL	6[EBX], EAX

xosconDosUpd::				;Enter here to only update page 0 data

	CRASH	????

	MOVL	EAX, tdb_keysts0[ESI]	;Get the keyboard bits
	MOVL	EDX, EAX		;Rearrange the bits to match what DOS
	ANDB	DH, #0xF0		;  programs expect in locations 40:17
	ANDB	DL, #1
	MOVB	BL, AL
	SHLB	BL, #1
	ANDB	BL, #0x0C
	ORB	DL, BL
	SHRB	AL, #3
	ANDB	AL, #0x0E
	ORB	DL, AL
	SHRL	EAX, #4
	ORB	DL, AL
	MOVW	bda_vkeysts0, DX	;Store value in page 0
	MOVZWL	EAX, tdb_curmode[ESI] ;Get cursor mode value
	ANDB	AH, #0x3F
	MOVW	bda_vcurmode, AX ;Store cursor mode values
	MOVL	EAX, tdb_curpos+0[ESI] ;Store cursor positions on page 0
	MOVL	bda_vcurpos+0, EAX
	MOVL	EAX, tdb_curpos+4[ESI]
	MOVL	bda_vcurpos+4, EAX
	MOVL	EAX, tdb_curpos+8[ESI]
	MOVL	bda_vcurpos+8, EAX
	MOVL	EAX, tdb_curpos+12t[ESI]
	MOVL	bda_vcurpos+12t, EAX
	MOVB	AL, tdb_dsppage[ESI]	;Also store active display page
	MOVB	bda_vdsppage, AL
;;;;;;	MOVZBL	EAX, knlPda+pdaVMode##	;Get mapped mode
	TESTB	AL, AL
	JS	notmapped		;If not mapped
	MOVL	EDX, #0xA0000		;Get address
	MOVL	EAX, #0x20000		;Get size
	RET

;Here if nothing is mapped

notmapped::
	CLRL	EAX			;Return 0 as mapped size
	CLRL	EDX			;And 0 as offset
	RET
.PAGE
	.SBTTL	xosconDosUse - Function tfx_rmset - use terminal data from real mode page 0 values

;Function tf_rmset - use terminal data from real mode page 0 values - this
;  function is called whenever a context FROM the process using the terminal
;  is made to copy the user's real mode page 0 values to the systems data
;  - this is necessary in case the user has modified the terminal data in
;  page 0
;	c{ESI} = Offset of TDB
;	c[ES]  = Selector for PDA
;	CALL	xosconDosUse

xosconDosUse::

;NEED CODE HERE TO GET THE KEYBOARD SHIFT STATE BITS

;NEED CODE HERE TO GET THE CURSOR SIZE

	MOVL	EAX, bda_vcurpos+0	;Set cursor positions
	MOVL	tdb_curpos+0[ESI], EAX
	MOVL	EAX, bda_vcurpos+4
	MOVL	tdb_curpos+4[ESI], EAX
	MOVL	EAX, bda_vcurpos+8
	MOVL	tdb_curpos+8[ESI], EAX
	MOVL	EAX, bda_vcurpos+12t
	MOVL	tdb_curpos+12t[ESI], EAX
	MOVB	AL, bda_vdsppage	;Set active display page
	MOVB	tdb_dsppage[ESI], AL
	RET
.PAGE
;Function to output block
;	CALL	xosconOutBlk
;	c{EAX} = 0

xosconOutBlk::
	PUSHL	ESI
	MOVL	ESI, knlTda+tdaAdb##
	CALL	xosconDosChk		;Is this terminal for a DOS process?
	JE	1$			;No
	MOVZBL	EDX, tdb_dsppage[ESI]	;Yes - update cursor pos
	MOVW	AX, bda_vcurpos[EDX*2]	;  from virtual page 0
	MOVW	tdb_curpos[ESI+EDX*2], AX
1$:	MOVL	EBX, knlTda+tdaBuffer1##
2$:	IFFAULT	20$
	MOVB	AL, [EBX]		;Get character
	CMPL	tdb_escdsp[ESI], #xosconDspNrm ;Processing ESC sequence?
	JNE	4$			;Yes - don't hold or junk output
	TESTB	tdb_stsout[ESI], #TSO$JUNK|TSO$HOLDS|TSO$HOLDP
					;No - junking or holding output?
	JNE	14$			;Yes
	PUSHL	EBX			;No
	CMPB	AL, #CR			;Is this a return character?
	JNE	6$			;No
	MOVL	EBX, tdb_ddisp[ESI]	;Yes - update cursor on screen
	CALLI	tfx_dspcur[EBX]
	MOVL	EAX, #CR
	JMP	6$

4$:	PUSHL	EBX
6$:	CALL	xosconDspChr		;Display character
	POPL	EBX
	INCL	EBX
	CMPB	knlSchedReq##, #0	;Is it time to schedule?
	JNE	16$			;Yes
	DECL	knlTda+tdaCount##
	JNE	2$			;No - loop if more if not done
8$:	ORB	knlTda+tdaStatus##+1, #QSTS$DONE>8
10$:	PUSHL	EBX			;Save final buffer offset
	MOVL	EBX, tdb_ddisp[ESI]	;Update cursor on screen
	CALLI	tfx_dspcur[EBX]
	POPL	EAX			;Restore final buffer offset
	SUBL	EAX, knlTda+tdaBuffer1## ;Calculate amount output
	ADDL	knlTda+tdaAmount##, EAX
	CLRL	EAX
	POPL	ESI
	RET				;Finished

;Here if junking or holding output (get here at fork level)

14$:	TESTB	tdb_stsout[ESI], #TSO$HOLDS|TSO$HOLDP ;Are we holding output?
	JNE	10$			;Yes - return without setting QSTS$DONE
	ADDL	EBX, knlTda+tdaBuffer1## ;Junking output - just advance pointer
	JMP	8$			;Finished

;Here if need to stop console output so can schedule

16$:	DECL	knlTda+tdaCount##	;Are we finished now?
	JE	8$			;Yes - just finish up normally
	ORB	knlTda+tdaStatus##+1, #QSTS$REDO>8 ;No - request immediate re-do
	JMP	10$

;Here if address is out of bounds

	FAULTHDR
20$:	MOVL	knlTda+tdaError##, #ER_ADRER
	JMP	8$
.PAGE
	.SBTTL	xosconOutChr - Function to output single character

;Function to output single character
;	c(AL)  = Character to output
;	c{ESI} = Offset of console TDB
;	CALL	xosconOutChr
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Number of characters output this time (always 1)

xosconOutChr::
	CALL	xosconDspChr		;Display the character
	CLRL	EAX			;Get return value (always 1)
	INCL	EAX
	MOVL	EBX, tdb_ddisp[ESI]	;Update cursor on screen
	JMPIL	tfx_dspcur[EBX]		;And return
.PAGE
	.SBTTL	conDspChr - Subroutine to display single character

;Subroutine to display single character
;	c(AL)  = Character
;	c{ESI} = Offset of TDB for console
;	CALL	conDspChr

xosconDspChr::

;Here with possible wrap status handled

4$:	CMPB	AL, #ESC		;Is this ESC?
	JE	12$			;Yes - go handle that
8$:	JMPIL	tdb_escdsp[ESI]		;No - dispatch on current ESC state

;Here if this character is ESC

12$:	MOVL	tdb_escdsp[ESI], #escchr1 ;Set dispatch for next time
	MOVB	tdb_escpnt[ESI], #0	;Point to first argument
	MOVL	tdb_escarg[ESI], #0	;Clear all arguments
	ANDB	tdb_stsansi[ESI], #~TSA$ESCMOD
14$:	RET				;Thats all

;Here with first character after ESC

escchr1:MOVL	EDX, EDI
	MOVL	EDI, #esc1tbl
	PUSHL	DS
	POPL	ES
	MOVL	ECX, #ESC1TSZ
	CLD
	RNSCASB	[EDI]			;Search for character
	XCHGL	EDX, EDI
	JNE	16$			;If not found
	SUBL	EDX, #esc1tbl+1		;Found
	JMPIL	esc1dsp[EDX*4]		;Dispatch on character

16$:	CMPB	AL, #'@'		;Noise character?
	JB	14$			;Yes - ignore it
	JMP	escdone			;No - finished here

	.MACRO	" ECC
	EC	{[}, esccsi	;CSI
	EC	{=}, esckpam	;Set to application keypad mode
	EC	{>}, esckpnm	;Set to numeric keypad mode
	EC	{7}, escsave	;Save display state
	EC	{8}, escrstr	;Restore display state
	EC	{#}, esclinatr	;Set DEC line attributes
	EC	{M}, escrevindx	;Reverse index
	.ENDM

	.MACRO	" EC  ltr, address
	.BYTE	'ltr'
	.ENDM

	DATA

esc1tbl:ECC
ESC1TSZ=!$-esc1tbl

	.MACRO	" EC  ltr, address
	.LONG	address
	.ENDM

esc1dsp:ECC

	CODE
.PAGE
;Here if character following ESC is [ - this is the CSI sequence

esccsi:	MOVL	tdb_escdsp[ESI], #escchr2 ;Advance state
ret006:	RET				;Finished

;Here if character following ESC is = - this sets the keypad to application
;  mode

esckpam:ORB	tdb_stsansi[ESI], #TSA$KPAMOD
	JMP	escdone

;Here if character following ESC is > - this sets the keypad to numeric
;  mode

esckpnm:ANDB	tdb_stsansi[ESI], #~TSA$KPAMOD
	JMP	escdone

;Here if character following ESC is 7 - this is a state save request

escsave:MOVW	AX, tdb_tattrval[ESI] ;Save current attribute values
	MOVW	tdb_sattrval[ESI], AX
	MOVZBL	EBX, tdb_dsppage[ESI] ;Get current page number
	MOVW	AX, tdb_curpos[ESI+EBX*2] ;Save cursor position
;qqqqqqqq
	MOVW	tdb_scurpos[ESI], AX
	JMP	escdone

;Here if character following ESC is 8 - this is a state restore request

escrstr:MOVZWL	EAX, tdb_sattrval[ESI]	;Get saved attribute values
	TESTL	EAX, EAX		;Were any saved?
	JE	10$.S			;No - do nothing!
	MOVW	tdb_tattrval[ESI], AX	;Yes
	MOVZBL	EBX, tdb_dsppage[ESI]	;Get current page number
	MOVW	AX, tdb_scurpos[ESI]	;Restore cursor position
;qqqqqqqq
	MOVW	tdb_curpos[ESI+EBX*2], AX
10$:	JMP	escdone

;Here if character following ESC is # - this is the DEC set line attributes
;  request - we cannot handle DEC line attributes but we do quietly ignore
;  the ESC-#-5 command which is the set line attributes to normal command

esclinatr:
	MOVL	tdb_escdsp[ESI], #esclachr ;Advance state
	RET
.PAGE
;Here if character following ESC is M - this is a reverse index function.  Its
;  basically a backwards line-feed, including scrolling the screen if already
;  at the top.

;NOTE: MAY NOT INTERACT WELL WITH WRAPPED LINES!

escrevindx:
	MOVL	tdb_escdsp[ESI], #xosconDspNrm ;Reset ESC state dispatch to
					       ;  normal
	MOVZBL	EBX, tdb_dsppage[ESI]	;Get current page number

;Here if not past end of current line

	MOVB	AL, tdb_curpos+1[ESI+EBX*2] ;On first line now?
	INCL	EAX
	CMPB	AL, tdb_scntop[ESI]
	JBE	6$			;Yes
4$:	DECB	tdb_curpos+1[ESI+EBX*2] ;No - just move up a line
	ANDB	tdb_stsinp[ESI], #~TSI$WRAPPED ;Clear possible wrapped state
	RET

;Here if now on first line of scrolling region (or above)

6$:	JNE	8$			;If above scrolling region
	MOVB	CL, #0			;Scroll scrolling region down 1 line
	MOVB	CH, tdb_scntop[ESI]
	DECB	CH
	MOVB	DL, tdb_columns[ESI]
	DECB	DL
	MOVB	DH, tdb_scnbtm[ESI]
	DECB	DH
	MOVB	BH, #1
	MOVB	AL, #1			;Function = scroll down
conscroll::
	PUSHL	EAX
	MOVL	EAX, tdb_ddisp[ESI]
	MOVL	EAX, tfx_scroll[EAX]
	XCHGL	EAX, [ESP]
	RET

;Here if above scrolling region

8$:	CMPB	AL, #0			;At top of physical screen?
	JB	4$.S			;No - just move up a line
	RET				;Yes - do nothing! (NEED TO SEE IF THIS
					;  IS RIGHT!!!)
.PAGE
;Here with character following ESC-# - This is the DEC set line attributes
;  command - we cannot support DEC line attributes so we just ignore this

esclachr:
	JMP	escdone
.PAGE
;Here with character following ESC-[

escchr2:CMPB	AL, #'?'		;Special prefix?
	JNE	2$			;No
	ORB	tdb_stsansi[ESI], #TSA$ESCMOD ;Yes - remember we have this
	RET				;Thats all

2$:	CMPB	AL, #';'		;Argument separator?
	JE	6$			;Yes
	CMPB	AL, #'0'		;No - digit?
	JB	10$			;No
	CMPB	AL, #'9'		;Maybe
	JA	10$			;No
	ANDB	AL, #0F			;Yes - get value
	PUSHL	EAX
	MOVZBL	EBX, tdb_escpnt[ESI]	;Get argument pointer
	MOVZBL	EAX, tdb_escarg[ESI+EBX] ;Get current argument value
	IMULL	EAX, #10t		;Times 10
	MOVB	tdb_escarg[ESI+EBX], AL
	POPL	EAX
	ADDB	tdb_escarg[ESI+EBX], AL ;Add in value of this digit
4$:	RET				;Thats all

;Here with semi-colon (argument separator)

6$:	CMPB	tdb_escpnt[ESI], #3	;Too many arguments?
	JAE	4$			;Yes - ignore this
	INCB	tdb_escpnt[ESI]	;No - bump to next argument
	RET

;Here with non-numeric character

10$:	CMPB	AL, #'@'		;Noise character?
	JB	4$			;Yes - ignore it
	TESTB	tdb_stsansi[ESI], #TSA$ESCMOD ;No - have modifier?
	JNE	escdone			;Yes - ignore it for now!!!
	MOVL	EDX, EDI		;No
	MOVL	EDI, #escctbl
	PUSHL	DS
	POPL	ES
	MOVL	ECX, #ESCCTSZ
	CLD
	RNSCASB	[EDI]			;Search for character
	XCHGL	EDX, EDI
	JNE	escdone			;If not found
	SUBL	EDX, #escctbl+1		;Found
	MOVZBL	EBX, tdb_dsppage[ESI]	;Get current page number
	JMPIL	esccdsp[EDX*4]		;Dispatch on character

	.MACRO	" ECC
	EC	B, esccurdown	;Cursor down
	EC	C, esccurrght	;Cursor right
	EC	K, esclinclr	;Clear line
	EC	J, escscnclr	;Clear screen
	EC	L, esclinins	;Insert line(s)
	EC	M, esclindel	;Delete line(s)
	EC	P, escchrdel	;Delete character(s)
	EC	@, escchrins	;Insert character(s)
	EC	s, escsave	;Save cursor position and attributes
	EC	A, esccurup	;Cursor up
	EC	D, esccurleft	;Cursor left
	EC	H, esccurpos	;Set cursor position
	EC	f, esccurpos	;Set cursor position
	EC	h, escmodeset	;Mode set
	EC	l, escmodeclr	;Mode clear
	EC	m, escattrib	;Set attributes
	EC	r, escregion	;Set scrolling region
	EC	u, escrstr	;Restore cursor position and attributes
	EC	v, esccurmode	;Set cursor mode
	.ENDM

	.MACRO	" EC  ltr, address
	.BYTE	'ltr'
	.ENDM

	DATA

escctbl:ECC
ESCCTSZ=!$-escctbl

	.MACRO	" EC  ltr, address
	.LONG	address
	.ENDM

esccdsp:ECC

	CODE
.PAGE
;Here with cursor up command

esccurup:
	MOVB	AH, tdb_escarg[ESI]	;Get argument value
	TESTB	AH, AH			;0 value?
	JNE	2$			;No
	INCB	AH			;Yes - make it 1
2$:	CMPB	tdb_curpos+1[ESI+EBX*2], AH ;Trying to go too far?
	JBE	4$			;Yes
	SUBB	tdb_curpos+1[ESI+EBX*2], AH ;No - store new position
	JMP	escdone

4$:	MOVB	tdb_curpos+1[ESI+EBX*2], #0
	JMP	escdone

;Here with cursor down command

esccurdown:
	MOVB	AH, tdb_escarg[ESI]	;Get argument value
	TESTB	AH, AH			;0 value?
	JNE	6$			;No
	INCB	AH			;Yes - make it 1
6$:	MOVB	AL, tdb_rows[ESI]	;Get height of screen
	ADDB	tdb_curpos+1[ESI+EBX*2], AH
	JC	8$
	CMPB	tdb_curpos+1[ESI+EBX*2], AL
	JB	escdone
8$:	DECB	AL
	MOVB	tdb_curpos+1[ESI+EBX*2], AL
	JMP	escdone

;Here with cursor left command

esccurleft:
	MOVB	AH, tdb_escarg[ESI]	;Get argument value
	TESTB	AH, AH			;0 value?
	JNE	10$			;No
	INCB	AH			;Yes - make it 1
10$:	CMPB	tdb_curpos+0[ESI+EBX*2], AH ;Too much?
	JBE	12$
	SUBB	tdb_curpos+0[ESI+EBX*2], AH ;No
	JMP	escdone

12$:	MOVB	tdb_curpos+0[ESI+EBX*2], #0
	JMP	escdone

;Here with cursor right command

esccurrght:
	MOVB	AH, tdb_escarg[ESI]	;Get argument value
	TESTB	AH, AH			;0 value?
	JNE	14$			;No
	INCB	AH			;Yes - make it 1
14$:	MOVB	AL, tdb_columns[ESI]	;Get width of screen
	ADDB	tdb_curpos+0[ESI+EBX*2], AH
	JC	6$
	CMPB	tdb_curpos+0[ESI+EBX*2], AL
	JB	escdone
16$:	DECB	AL
	MOVB	tdb_curpos+0[ESI], AL
escdone:MOVL	tdb_escdsp[ESI], #xosconDspNrm ;Reset ESC state dispatch to
					       ;  normal
	ANDB	tdb_stsinp[ESI], #~TSI$WRAPPED ;Clear possible wrapped state
	RET				;Thats all
.PAGE
;Here with cursor position command

esccurpos:
	MOVB	AL, tdb_escarg+0[ESI]	;Get first argument
	TESTB	AL, AL
	JE	2$
	DECB	AL
2$:	CMPB	AL, tdb_rows[ESI]
	JB	4$
	MOVB	AL, tdb_rows[ESI]
	DECB	AL
4$:	MOVB	tdb_curpos+1[ESI+EBX*2], AL
	MOVB	AL, tdb_escarg+1[ESI]	;Get second argument
	TESTB	AL, AL
	JE	6$
	DECB	AL
6$:	CMPB	AL, tdb_columns[ESI]
	JB	8$
	MOVB	AL, tdb_columns[ESI]
	DECB	AL
8$:	MOVB	tdb_curpos+0[ESI+EBX*2], AL
	JMP	escdone
.PAGE
;Here with insert line command

esclinins:
	MOVB	AL, #1			;Function = scroll down
	JMP	2$

;Here with delete line command

esclindel:
	MOVB	AL, #0			;Function = scroll up
2$:	PUSHL	EBX
	MOVB	tdb_curpos+0[ESI+EBX*2], #0 ;Set cursor to beginning of line
	MOVW	CX, tdb_curpos[ESI+EBX*2] ;Get upper left corner of region
	MOVB	DL, tdb_columns[ESI]	  ;  to scroll
	DECL	EDX			;Get lower right corner
	MOVB	DH, tdb_scnbtm[ESI]
	DECB	DH
	JMP	6$			;Continue

;Here with character delete command

escchrdel:
	MOVB	AL, #3			;Function = scroll left
	JMP	4$

;Here with the character insert command

escchrins:
	MOVB	AL, #2			;Function = scroll right
4$:	PUSHL	EBX
	MOVW	CX, tdb_curpos+0[ESI+EBX*2]
	MOVB	DL, tdb_columns[ESI]
	DECL	EDX
	MOVB	DH, CH
6$:	MOVB	BH, tdb_escarg[ESI]	;Get first argument (number to delete)
	CMPB	BH, #0
	JNE	8$
	MOVB	BH, #1
8$:	CALL	conscroll
	POPL	EBX
	JMP	escdone
.PAGE
;Here with line clear command

esclinclr:
	MOVB	AL, tdb_escarg[ESI]	;Get first argument
	TESTB	AL, AL
	JS	escdone
	DECB	AL			;Clear from cursor to end of line?
	JNS	4$			;No
2$:	MOVW	CX, tdb_curpos[ESI+EBX*2] ;Yes
	MOVB	DL, tdb_columns[ESI]
	DECB	DL
	MOVB	DH, CH
	JMP	esclin2

;Here if function is not clear from cursor to end of line

4$:	JNE	10$			;Clear from beginning of line to
					;  cursor?
	MOVW	DX, tdb_curpos[ESI+EBX*2] ;Yes
	MOVB	CL, #0
	MOVB	CH, DH
esclin2:MOVB	AL, #0
	CALL	conscroll		;Clear the line
	JMP	escdone

;Here if function is clear entire line

10$:	MOVB	tdb_curpos+0[ESI+EBX*2], #0 ;Set cursor to beginning of line
	JMP	2$.S
.PAGE
;Here with screen clear command
;	ESC[0J - Erase from cursor to end of display
;	ESC[1J - Erase from beginning of display to cursor
;	ESC[2J - Erase entire display (home cursor)

escscnclr:
	MOVB	AL, tdb_escarg[ESI]	;Get first argument
	TESTB	AL, AL
	JS	escdone
	DECB	AL			;Erase from cursor to end of display?
	JNS	6$.S			;No
	MOVW	CX, tdb_curpos[ESI+EBX*2] ;Yes - get position
	MOVB	DL, tdb_columns[ESI]
	DECB	DL
	CMPB	CL, DL			;At end of line now?
	JAE	2$.S			;Yes
	MOVB	DH, CH			;No - clear to end of line
	MOVB	AL, #0
	CALL	conscroll
	MOVZBL	EBX, tdb_dsppage[ESI]
2$:	MOVB	CH, tdb_curpos+1[ESI+EBX*2] ;Now clear everything below the
	MOVB	DH, tdb_rows[ESI]	    ;  line
	DECB	DH
	CMPB	CH, DH			;At bottom now?
	JAE	escdone			;Yes - finished
	MOVB	CL, #0			;No
	MOVB	DL, tdb_columns[ESI]
	DECB	DL
	JMP	esclin2.S

;Here if do not want to clear bottom part of screen

6$:	DECB	AL			;Erase from beginning to cursor?
	JNS	12$.S			;No
	MOVW	DX, tdb_curpos[ESI+EBX*2] ;Yes - get position
	CMPB	DL, #0			;At beginning of line now?
	JE	8$.S			;Yes
	MOVB	CL, #0			;No - clear beginning of line
	MOVB	CH, DH
	MOVB	AL, #0
	CALL	conscroll
	MOVZBL	EBX, tdb_dsppage[ESI]
8$:	MOVB	DH, tdb_curpos+1[ESI+EBX*2] ;Clear everything above the line
	CMPB	DH, #0			;At top now?
	JE	escdone			;Yes - finished
	MOVB	DL, tdb_columns[ESI]	;No
	CLRL	ECX
	JMP	esclin2

;Here if do not want to clear top part of screen

12$:	DECB	AL			;Erase entire display?
	JNS	escdone			;No - ignore this
	MOVW	tdb_curpos[ESI+EBX*2], #0 ;Yes - set cursor to home position
	CLRL	ECX
	MOVB	DL, tdb_columns[ESI]
	DECB	DL
	MOVB	DH, tdb_rows[ESI]
	DECB	DH
	JMP	esclin2
.PAGE
;Here with mode set command

escmodeset:
	CLRL	EDX
2$:	MOVZBL	EAX, tdb_escarg[ESI+EDX] ;Get argument value
	CMPL	EAX, #ESCMSMAX		;Legal value?
	JA	4$			;No - ignore it
	CALLI	escmsdsp[EAX*4]		;Yes - dispatch on the argument
4$:	INCL	EDX			;Bump argument pointer
	CMPB	DL, tdb_escpnt[ESI]	;More arguments?
	JBE	2$			;Yes
	JMP	escdone			;No - all finished

	DATA

escmsdsp:
	.LONG	ret006		;      =  0
	.LONG	ret006		; GATM =  1 - Guarded area transfer
	.LONG	ret006		; KAM  =  2 - Keyboard action
	.LONG	ret006		; CRM  =  3 - Control representation
	.LONG	insmodeset	; IRM  =  4 - Insert/replace mode
	.LONG	ret006		;      =  5
	.LONG	ret006		; ERM  =  6 - Erasure
	.LONG	chrwrapset	;      =  7 - Enable character wrap
	.LONG	ret006		;      =  8
	.LONG	ret006		;      =  9
	.LONG	ret006		; HEM  = 10 - Horizontal editing
	.LONG	ret006		;      = 11
	.LONG	ret006		; SRM  = 12 - Send/receive
	.LONG	ret006		;      = 13
	.LONG	ret006		;      = 14
	.LONG	ret006		; MATM = 15 - Multiple area transfer
	.LONG	ret006		; TTM  = 16 - Transmit termination
	.LONG	ret006		; SATM = 17 - Selected area transfer
	.LONG	ret006		;      = 18
	.LONG	ret006		;      = 19
	.LONG	ret006		; LNM  = 20 - Line feed/new line
ESCMSMAX=!{$-escmsdsp}/4-1

	CODE
.PAGE
;Here for the enable insert mode command (<ESC>[4h)

insmodeset:
	ANDB	tdb_stsinp[ESI], #~TSI$OVER
	RET

;Here for the enable character wrap command (<ESC>[7h)

chrwrapset:
	ANDB	tdb_stsout[ESI], #{~TSO$NOWRAP}&0FFh
	RET
.PAGE
;Here with mode clear command

escmodeclr:
	CLRL	EDX
2$:	MOVZBL	EAX, tdb_escarg[ESI+EDX] ;Get argument value
	CMPL	EAX, #ESCMCMAX		;Legal value?
	JA	4$			;No - ignore it
	CALLI	escmcdsp[EAX*4]		;Yes - dispatch on the argument
4$:	INCL	EDX			;Bump argument pointer
	CMPB	DL, tdb_escpnt[ESI]	;More arguments?
	JBE	2$			;Yes
	JMP	escdone			;No - all finished

	DATA

escmcdsp:
	.LONG	ret006		;      =  0
	.LONG	ret006		; GATM =  1 - Guarded area transfer
	.LONG	ret006		; KAM  =  2 - Keyboard action
	.LONG	ret006		; CRM  =  3 - Control representation
	.LONG	insmodeclr	; IRM  =  4 - Insert/replace mode
	.LONG	ret006		;      =  5
	.LONG	ret006		; ERM  =  6 - Erasure
	.LONG	chrwrapclr	;      =  7 - Enable character wrap
	.LONG	ret006		;      =  8
	.LONG	ret006		;      =  9
	.LONG	ret006		; HEM  = 10 - Horizontal editing
	.LONG	ret006		;      = 11
	.LONG	ret006		; SRM  = 12 - Send/receive
	.LONG	ret006		;      = 13
	.LONG	ret006		;      = 14
	.LONG	ret006		; MATM = 15 - Multiple area transfer
	.LONG	ret006		; TTM  = 16 - Transmit termination
	.LONG	ret006		; SATM = 17 - Selected area transfer
	.LONG	ret006		;      = 18
	.LONG	ret006		;      = 19
	.LONG	ret006		; LNM  = 20 - Line feed/new line
ESCMCMAX=!{$-escmcdsp}/4-1

	CODE
.PAGE
;Here for the disable insert mode command (<ESC>[4l)

insmodeclr:
	ORB	tdb_stsinp[ESI], #TSI$OVER
	RET

;Here for the disable character wrap command (<ESC>[7l)

chrwrapclr:
	ORB	tdb_stsout+1[ESI], #TSO$NOWRAP>8
	RET
.PAGE
;Here with set scrolling region command (<ESC>[t;br)

escregion:
	MOVL	EAX, tdb_escarg+0[ESI]	;Get argument values
	CMPB	AL, #0			;First argument given?
	JNE	2$			;Yes
	MOVB	AL, #1			;No - assume first line
2$:	CMPB	AH, #0			;Second argument given?
	JE	4$			;No
	CMPB	AH, tdb_rows[ESI]	;Yes - is in within range?
	JBE	6$			;Yes
4$:	MOVB	AH, tdb_rows[ESI]	;No - set to bottom of screen
6$:	MOVW	tdb_scntop[ESI], AX	;Store top and bottom values
	MOVZBL	EBX, tdb_dsppage[ESI]	;Get current page number
	MOVW	tdb_curpos[ESI+EBX*2], #0 ;Reset cursor to home position
	JMP	escdone			;Thats all
.PAGE
;Here with set cursor mode command

esccurmode:
	CLRL	EDX
2$:	MOVZBL	EAX, tdb_escarg[ESI+EDX] ;Get argument value
	CMPL	EAX, #ESCCMMAX		;Legal value?
	JA	4$			;No - ignore it
	CALLI	esccmdsp[EAX*4]		;Yes - dispatch on the argument
4$:	INCL	EDX			;Bump argument pointer
	CMPB	DL, tdb_escpnt[ESI]	;More arguments?
	JBE	2$			;Yes
	JMP	escdone			;No - all finished

	DATA

esccmdsp:
	.LONG	concurvis	; 0 - Make cursor visible
	.LONG	concurinv	; 1 - Make cursor invisible
	.LONG	esccurund	; 2 - Change to underline cursor
	.LONG	esccurblk	; 3 - Change to block cursor
	.LONG	ret006		; 4 - Make cursor non-blinking
	.LONG	ret006		; 5 - Make cursor blinking
ESCCMMAX=!{$-esccmdsp}/4-1

	CODE
.PAGE
;Here for the make cursor invisible command (<ESC>[0v)

concurinv:
	MOVZWL	ECX, tdb_curmode[ESI]
	ORB	CH, #0x20
	JMP	8$

;Here for the make cursor visible command (<ESC>[1v)

concurvis:
	MOVZWL	ECX, tdb_curmode[ESI]
	ANDB	CH, #~0x20
	JMP	8$

;Here for the change to underline cursor command (<ESC>[2v)

esccurund:
	MOVB	CH, tdb_curmode+1[ESI]
	ANDB	CH, #0x20
	ORB	CH, #0x06
	JMP	6$

;Here for the change to block cursor command (<ESC>[3v)

esccurblk:
	MOVB	CH, tdb_curmode+1[ESI]
	ANDB	CH, #0x20
6$:	MOVB	CL, #0x07
8$:	PUSHL	EDX
	MOVL	EAX, tdb_ddisp[ESI]
	CALLI	tfx_curtype[EAX]	;Go set cursor type
	POPL	EDX
	RET
.PAGE
;Here with set attributes command

escattrib::
	CLRL	EDX
2$:	MOVZBL	EAX, tdb_escarg[ESI+EDX] ;Get argument value
	CMPL	EAX, #ESCATMAX		;Legal value?
	JA	4$			;No - ignore it
	CALLI	escatdsp[EAX*4]		;Yes - dispatch on the argument
4$:	INCL	EDX			;Bump argument pointer
	CMPB	DL, tdb_escpnt[ESI]	;More arguments?
	JBE	2$			;Yes
	JMP	escdone			;No - all finished

	DATA

escatdsp:
	.LONG	escatoff	; 0 - All attributes off
	.LONG	escatbold	; 1 - Set bold on
	.LONG	escatnorm	; 2 - Set bold off
	.LONG	ret006		; 3 - Illegal
	.LONG	escatulon	; 4 - Underline on
	.LONG	escatblinkon	; 5 - Blink on
	.LONG	ret006		; 6 - Illegal
	.LONG	escatrevon	; 7 - Reverse video on
	.LONG	escatcon	; 8 - Concealed
	.LONG	ret006		; 9 - Illegal
	.LONG	ret006		;10 - Illegal
	.LONG	ret006		;11 - Illegal
	.LONG	ret006		;12 - Illegal
	.LONG	ret006		;13 - Illegal
	.LONG	ret006		;14 - Illegal
	.LONG	ret006		;15 - Illegal
	.LONG	ret006		;16 - Illegal
	.LONG	ret006		;17 - Illegal
	.LONG	ret006		;18 - Illegal
	.LONG	ret006		;19 - Illegal
	.LONG	ret006		;20 - Illegal
	.LONG	ret006		;21 - Illegal
	.LONG	escatnorm	;22 - Set bold off
	.LONG	ret006		;23 - Illegal
	.LONG	escatuloff	;24 - Underline off
	.LONG	escatblinkoff	;25 - Blink off
	.LONG	ret006		;26 - Illegal
	.LONG	escatrevoff	;27 - Reverse video off
	.LONG	ret006		;28 - Illegal
	.LONG	ret006		;29 - Illegal
	.LONG	escatfblack	;30 - Set foreground to black
	.LONG	escatfred	;31 - Set foreground to red
	.LONG	escatfgreen	;32 - Set foreground to green
	.LONG	escatfyellow	;33 - Set foreground to yellow
	.LONG	escatfblue	;34 - Set foreground to blue
	.LONG	escatfmagenta	;35 - Set foreground to magenta
	.LONG	escatfcyan	;36 - Set foreground to cyan
	.LONG	escatfwhite	;37 - Set foreground to white
	.LONG	ret006		;38 - Illegal
	.LONG	ret006		;39 - Illegal
	.LONG	escatbblack	;40 - Set background to black
	.LONG	escatbred	;41 - Set background to red
	.LONG	escatbgreen	;42 - Set background to green
	.LONG	escatbyellow	;43 - Set background to yellow
	.LONG	escatbblue	;44 - Set background to blue
	.LONG	escatbmagenta	;45 - Set background to magenta
	.LONG	escatbcyan	;46 - Set background to cyan
	.LONG	escatbwhite	;47 - Set background to white
ESCATMAX=!{$-escatdsp}/4-1

	CODE
.PAGE
;Here for ESC[0m - All attributes off

escatoff:
	MOVW	AX, tdb_battrval[ESI]
	MOVW	tdb_tattrval[ESI], AX
	RET

;Here for ESC[1m - Set bold on

escatbold:
	ORB	tdb_tattrval[ESI], #08h	;Set bold bit
	ORB	tdb_tattrfil[ESI], #08h
	RET

;Here for ESC[2m - Set bold off

escatnorm:
	ANDB	tdb_tattrval[ESI], #0F7h ;Clear bold bit
	ANDB	tdb_tattrfil[ESI], #0F7h
	RET

;Here for ESC[4m - Set underline on

escatulon:
	NOP
	RET

;Here for ESC[24m - Set underline off

escatuloff:
	NOP
	RET

;Here for ESC[5m - Set blink on

escatblinkon:
	ORB	tdb_tattrval[ESI], #80h ;Set blink bit
	ORB	tdb_tattrfil[ESI], #80h
	RET

;Here for ESC[25m - Set blink off

escatblinkoff:
	ANDB	tdb_tattrval[ESI], #7Fh	;Clear blink bit
	ANDB	tdb_tattrfil[ESI], #7Fh
	RET

;Here for ESC[7m - Set reverse video

escatrevon:
	MOVB	AL, tdb_battrval[ESI]
	MOVB	AH, tdb_tattrval[ESI]
	ANDB	AH, #88h
	ANDB	AL, #77h
	RORB	AL, #4t
	ORB	AL, AH
	MOVB	tdb_tattrval[ESI], AL
;;;;;;	MOVB	AL, tdb_battrfil[ESI]
;;;;;;	MOVB	AH, AL
;;;;;;	ANDB	AH, #88h
;;;;;;	ANDB	AL, #77h
;;;;;;	RORB	AL, #4t
;;;;;;	ORB	AL, AH
;;;;;;	MOVB	tdb_tattrfil[ESI], AL
	RET

;Here for ESC[27m - Clear reverse video

escatrevoff:
	MOVW	AX, tdb_battrval[ESI]
	ANDW	AX, #7777h
	ANDW	tdb_tattrval[ESI], #8888h
	ORW	tdb_tattrval[ESI], AX
	RET

;Here for ESC[8m - Set concealed text

escatcon:
	MOVB	AL, tdb_battrval[ESI]	;Yes - set both foreground and background
	MOVB	AH, AL			;  to the background color
	ANDB	AL, #0F8h
	SHRB	AH, #4t
	ANDB	AH, #07h
	ORB	AL, AH
	MOVB	tdb_tattrval[ESI], AL
6$:	RET

;Here for ESC[30m - Set foreground to black

escatfblack:
	MOVB	AL, #0
	JMP	8$.S

;Here for ESC[31m - Set foreground to red

escatfred:
	MOVB	AL, #4
	JMP	8$.S

;Here for ESC[32m - Set foreground to green

escatfgreen:
	MOVB	AL, #2
	JMP	8$.S

;Here for ESC[33m - Set foreground to yellow (really brown!)

escatfyellow:
	MOVB	AL, #6
	JMP	8$.S

;Here for ESC[34m - Set foreground to blue

escatfblue:
	MOVB	AL, #1
	JMP	8$.S

;Here for ESC[35m - Set foreground to magenta

escatfmagenta:
	MOVB	AL, #5
	JMP	8$.S

;Here for ESC[36m - Set foreground to cyan

escatfcyan:
	MOVB	AL, #3
	JMP	8$.S

;Here for ESC[37m - Set foreground to while

escatfwhite:
	MOVB	AL, #7
8$:	ANDB	tdb_tattrval[ESI], #0F8h ;Clear all but bold bit
	ORB	tdb_tattrval[ESI], AL	;Merge in new color value
	ANDB	tdb_tattrfil[ESI], #0F8h
	ORB	tdb_tattrfil[ESI], AL
	RET

;Here for ESC[40m - Set background to black

escatbblack:
	MOVB	AL, #00h
	JMP	10$.S

;Here for ESC[41m - Set background to red

escatbred:
	MOVB	AL, #40h
	JMP	10$.S

;Here for ESC[42m - Set background to green

escatbgreen:
	MOVB	AL, #20h
	JMP	10$.S

;Here for ESC[43m - Set background to yellow (really brown!)

escatbyellow:
	MOVB	AL, #60h
	JMP	10$.S

;Here for ESC[44m - Set background to blue

escatbblue:
	MOVB	AL, #10h
	JMP	10$.S

;Here for ESC[45m - Set background to magenta

escatbmagenta:
	MOVB	AL, #50h
	JMP	10$.S

;Here for ESC[46m - Set background to cyan

escatbcyan:
	MOVB	AL, #30h
	JMP	10$.S

;Here for ESC[47m - Set background to white

escatbwhite:
	MOVB	AL, #70h
10$:	ANDB	tdb_tattrval[ESI], #8Fh	;Clear all but bold bit
	ORB	tdb_tattrval[ESI], AL	;Merge in new color value
	ANDB	tdb_tattrfil[ESI], #8Fh	;Store as fill value also
	ORB	tdb_tattrfil[ESI], AL
	RET
.PAGE
;Here if not in an escape sequence

xosconDspNrm::
	MOVZBL	EBX, tdb_dsppage[ESI]	;Get current page number
	CMPB	AL, #' '		;Printing character?
	JNC	onscrn			;Yes
	MOVZBL	EAX, AL			;No - dispatch on the control character
	JMPIL	ctldsp[EAX*4]

	DATA

ctldsp:	.LONG	ret004		; 00    NUL
	.LONG	onscrn		; 01 ^A SOH
	.LONG	onscrn		; 02 ^B STX
	.LONG	onscrn		; 03 ^C ETX
	.LONG	onscrn		; 04 ^D EOT
	.LONG	onscrn		; 05 ^E ENQ
	.LONG	onscrn		; 06 ^F ACK
	.LONG	ctlbel		; 07 ^G BEL
	.LONG	ctlbs		; 08 ^H BS
	.LONG	ctlht		; 09 ^I HT
	.LONG	downln		; 0A ^J LF
	.LONG	onscrn		; 0B ^K VT
	.LONG	onscrn		; 0C ^L FF
	.LONG	ctlcr		; 0D ^M CR
	.LONG	onscrn		; 0E ^N SO
	.LONG	onscrn		; 0F ^O SI
	.LONG	onscrn		; 10 ^P DLE
	.LONG	onscrn		; 11 ^Q DC1
	.LONG	onscrn		; 12 ^R DC2
	.LONG	onscrn		; 13 ^S DC3
	.LONG	onscrn		; 14 ^T DC4
	.LONG	onscrn		; 15 ^U NAK
	.LONG	onscrn		; 16 ^V SYN
	.LONG	onscrn		; 17 ^W ETB
	.LONG	onscrn		; 18 ^X CAN
	.LONG	onscrn		; 19 ^Y EM
	.LONG	onscrn		; 1A ^Z SUB
	.LONG	onscrn		; 1B ^[ ESC
	.LONG	onscrn		; 1C ^\ FS
	.LONG	onscrn		; 1D ^] GS
	.LONG	onscrn		; 1E ^^ RS
	.LONG	onscrn		; 1F ^_ US

	CODE

;Here if bell character (BEL)

ctlbel:	MOVL	EAX, tdb_dhdb[ESI]
	TESTL	EAX, EAX
	JE	4$
	PUSHL	EAX
	PUSHL	#kfx_beep
	MOVZWL	EAX, tdb_spkfreq[ESI]	;Get frequency
	SHLL	EAX, #16t
	MOVW	AX, tdb_spklen[ESI]	;Get duration
	PUSHL	EAX
	CALL	xosconToKeyboard
4$:	RET				;Finished

;Here if carriage return character (CR)

ctlcr:	MOVB	tdb_curpos+0[ESI+EBX*2], #0 ;Reset position
	TESTB	tdb_stsinp[ESI], #TSI$WRAPPED ;Did we just wrap?
	JE	6$			;No
	DECB	tdb_curpos+1[ESI+EBX*2]	;Yes - back up one line
	ANDB	tdb_stsinp[ESI], #~TSI$WRAPPED ;Not wrapped now
6$:	RET

;Here if backspace character (BS)

ctlbs:	CMPB	tdb_curpos+0[ESI+EBX*2], #0 ;At beginning of line?
	JE	8$			;Yes
	DECB	tdb_curpos+0[ESI+EBX*2] ;No - reduce position
	JMP	12$			;Thats all

8$:	CMPB	tdb_curpos+1[ESI+EBX*2], #0
	JE	10$
	DECB	tdb_curpos+1[ESI+EBX*2]
10$:	MOVB	AL, tdb_columns[ESI]
	DECB	AL
	MOVB	tdb_curpos+0[ESI+EBX*2], AL
12$:	ANDB	tdb_stsinp[ESI], #~TSI$WRAPPED ;Clear possible wrapped state
	RET

;Here if horizontal tab character (HT)

ctlht:	MOVB	AL, #' '		;Output space
	CALL	onscrn
	TESTB	tdb_curpos+0[ESI+EBX*2], #7 ;At tab stop yet?
	JNE	ctlht			;No - continue
	RET				;Yes - finished
.PAGE
;Here to place character on the screen

onscrn:	REQUIREMAIN
	ANDB	tdb_stsinp[ESI], #~TSI$WRAPPED ;Clear possible wrapped state
	TESTB	tdb_stsdsp[ESI], #TSD$ACTDSP ;Is this the active display?
	JE	4$			;No
	MOVL	EDX, tdb_dhdb[ESI]	;Yes
	CMPB	dhdb_scsvtype[EDX], #0	;Should this reset the screen saver?
	JNE	4$			;No - go on
	MOVL	ECX, dhdb_scsvtime[EDX] ;Yes
	JREGZ	ECX, 4$			;If not enabled
	CMPL	dhdb_scsvcnt[EDX], #0	;Enabled - has it run out?
	MOVL	dhdb_scsvcnt[EDX], ECX
	JNE	4$			;No - just reset the counter
	PUSHL	EAX			;Yes - enable the screen
	PUSHL	EBX
	MOVL	ECX, tdb_ddisp[ESI]
	CALLI	tfx_enable[ECX]
	POPL	EBX
	POPL	EAX
4$:	MOVB	AH, tdb_tattrval[ESI]	;Get attribute byte
	MOVW	DX, tdb_curpos[ESI+EBX*2] ;Get position
	CALLI	tdb_dspchr[ESI]		;Put character on screen
	MOVB	DL, tdb_columns[ESI]	;Too far right now?
	DECL	EDX
	CMPB	DL, tdb_curpos+0[ESI+EBX*2]
	JBE	12$			;Yes
	INCB	tdb_curpos+0[ESI+EBX*2] ;No - bump the position
	RET

;Here if to far right

12$:	TESTB	tdb_stsout+1[ESI], #TSO$NOWRAP>8 ;Yes - want line wrap?
	JNE	14$			;No
	MOVB	tdb_curpos+0[ESI+EBX*2], #0 ;Yes - reset position in line
	PUSHL	EAX			;Save character
	PUSHL	EBX
	CALL	downln2			;Move down to next line
	POPL	EBX
	POPL	EAX			;Restore character
	ORB	tdb_stsinp[ESI], #TSI$WRAPPED ;Indicate wrapped
14$:	RET
.PAGE
;Here on LF to move down one line

downln:	BTL	tdb_omode[ESI], #TOM%ICRBLF ;Need to "insert" CR first?
	JNC	downln2			;No
	MOVB	tdb_curpos+0[ESI+EBX*2], #0 ;Yes
	TESTB	tdb_stsinp[ESI], #TSI$WRAPPED ;Did we just wrap?
	JE	downln2			;No
	ANDB	tdb_stsinp[ESI], #~TSI$WRAPPED ;Clear the wrapped state
	RET

downln2:MOVB	AL, tdb_curpos+1[ESI+EBX*2] ;On last line now?
	INCB	AL
	CMPB	AL, tdb_scnbtm[ESI]
	JAE	4$			;Yes
2$:	MOVB	tdb_curpos+1[ESI+EBX*2], AL ;No - just move down a line
	RET

;Here if now on last line of scrolling region (or below)

4$:	JNE	6$			;If below scrolling region
	PUSHL	EBX
	MOVB	CL, #0			;Scroll scrolling region up 1 line
	MOVB	CH, tdb_scntop[ESI]
	DECB	CH
	MOVB	DL, tdb_columns[ESI]
	DECB	DL
	MOVB	DH, tdb_scnbtm[ESI]
	DECB	DH
	MOVB	BH, #1
	MOVB	AL, #0			;Function = scroll up
	CALL	conscroll
	POPL	EBX
	RET

;Here if below scrolling region

6$:	CMPB	AL, tdb_rows[ESI]	;At bottom of physical screen?
	JB	2$			;No - just move down a line
	RET				;Yes - do nothing! (NEED TO SEE IF THIS
					;  IS RIGHT!!!)
.PAGE
;Function to resume output

xosconResume::
	CLRL	EAX	;;;; SOON !!!!
	RET
.PAGE
	.SBTTL	xosconAttrib - Subroutine to get or set display attributes

;Subroutine to get or set display attributes
;	c(AL)  = Function value:
;		   Bit 7 set to change current values
;		   Bit 6 set to return current values
;		   Bits 0-5 specify set of values:
;		     1 - Base values
;		     2 - Illegal
;		     3 - Current values
;	c{ESI} = Offset of TDB
;	c{EDI} = Address of data block
;	CALL	xosconAttrib
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = 0

;Format of the data block:
;	long foreground; 	// Foreground color
;	long background;	// Background color
;	long forgndfill;	// Foreground fill color
;	long backgndfill;	// Background fill color

xosconAttrib::
	MOVZBL	EBX, AL			;Get function
	ANDL	EBX, #3Fh
	CMPB	BL, #3t
	JA	2$
	JMPIL	attrdsp[EBX*4]		;Dispatch on the function

;Here if illegal function value

2$:	MOVL	EAX, #ER_FUNC
	STC
	RET

	DATA

attrdsp:.LONG	2$		; 0 = Illegal
	.LONG	settbase	; 1 = Set base values
	.LONG	2$		; 2 = Illegal
	.LONG	settcur		; 3 = Set current values

	CODE

;Here to get or set the base text attribute values

settbase:
	LEAL	EDX, tdb_battrval[ESI]
	JMP	4$

;Here to get or set the current text attribute values

settcur:LEAL	EDX, tdb_tattrval[ESI]
4$:	TESTB	AL, #0x80		;Want to change values?
	JE	12$			;No
	IFFAULT	knlRtnAdrEr##		;Yes
	MOVL	ECX, [EDI]		;Get foreground value
	TESTL	ECX, ECX
	JS	6$
	ANDB	CL, #0Fh		;Only 4 bits
	ANDB	[EDX], #0xF0
	ORB	[EDX], CL
	IFFAULT	knlRtnAdrEr##
6$:	MOVL	ECX, 4[EDI]		;Get background value
	TESTL	ECX, ECX
	JS	8$
	SHLB	CL, #4t
	ANDB	CL, #0xF0
	ANDB	[EDX], #0x0F
	ORB	[EDX], CL
	IFFAULT	knlRtnAdrEr##
8$:	MOVL	ECX, 8t[EDI]		;Get foreground fill value
	TESTL	ECX, ECX
	JS	10$
	ANDB	CL, #0x0F		;Only 4 bits
	ANDB	1[EDX], #0xF0
	ORB	1[EDX], CL
	IFFAULT	knlRtnAdrEr##
10$:	MOVL	ECX, 12t[EDI]		;Get background fill value
	TESTL	ECX, ECX
	JS	12$
	SHLB	CL, #4
	ANDB	CL, #0xF0
	ANDB	1[EDX], #0x0F
	ORB	1[EDX], CL
12$:	TESTB	AL, #0x40		;Want values returned?
	JE	14$			;No
	MOVZBL	EAX, [EDX]		;Yes - get color values
	MOVL	ECX, EAX
	ANDB	AL, #0x0F		;Get foreground value
	IFFAULT	knlRtnAdrEr##
	STOSL	[EDI]
	MOVL	EAX, ECX
	SHRL	EAX, #4t
	IFFAULT	knlRtnAdrEr##
	STOSL	[EDI]
	MOVB	AL, 1[EDX]		;Get attribute fill value
	MOVL	ECX, EAX
	ANDB	AL, #0x0F		;Get foreground fill value
	IFFAULT	knlRtnAdrEr##
	STOSL	[EDI]
	MOVL	EAX, ECX
	SHRL	EAX, #4t
	IFFAULT	knlRtnAdrEr##
	STOSL	[EDI]
14$:	CLRL	EAX
	RET
.PAGE
	.SBTTL	xosconDosUpdCP - Subroutine to update cursor position for real mode

;Subroutine to update cursor position from the DOS real mode page 0 values
;	c{EBX} = Page number
;	c{ESI} = Offset of TDB
;	CALL	xosconDosUpdCP
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c[GS]  = Selector for PDA for process
;	  c{EDX} = Previous cursor positon
;	  Z:set  = No DOS environment
;	  Z:clr  = Have DOS environment

xosconDosUpdCP::
	CMPL	EBX, #8t		;Valid page number?
	JAE	10$			;No
	MOVZWL	EDX, tdb_curpos[ESI+EBX*2] ;Yes - get current cursor position
	CALL	xosconDosChk		;Is this terminal for a DOS process?
	JE	8$			;No
	MOVW	AX, bda_vcurpos[EBX*2]	;Yes - get position
	CMPB	AL, tdb_columns[ESI]	;Check horizontal position
	JB	4$			;If OK
	MOVB	AL, tdb_columns[ESI]	;Too big - fix it
	DECL	EAX
4$:	CMPB	AH, tdb_rows[ESI]	;Check vertical position
	JB	6$			;If OK
	MOVB	AH, tdb_rows[ESI]	;Too big - fix it
	DECB	AH
6$:	MOVW	tdb_curpos[ESI+EBX*2], AX ;Store new position
	TESTL	ESP, ESP		;Make sure Z is clear
8$:	RET

;Here if have illegal page number

10$:	MOVL	EAX, #ER_VALUE
	STC
	RET
.PAGE
	.SBTTL	xosconDosChk - Subroutine to check for DOS process

;Subroutine to check for DOS process whose page 0 should be updated when
;  terminal parameters are changed, i.e., the current process if it is a DOS
;  process and this is its controlling terminal
;	CALL	xosconDosChk
;	Z:set = No DOS environment
;	Z:clr = Have DOS environment

xosconDosChk::
	TESTB	knlPda+pdaStatus1##, #P1$V86MEM ;Do we have V86 mode memory?
	JE	ret010			;No - return with Z set

	CRASH	????

	PUSHL	EAX
	MOVZWL	EAX, pdaHndlTbl##	;Yes - get pointer to device table
	MOVL	EAX, DH_STDTRM*32t[EAX] ;Get offset of DCB for
	CMPL	EAX, #0x1000		   ;  controlling terminal
	JB	4$
	TESTL	EAX, #0xF0000000
	JNE	4$
	CMPL	tdb_dcb[ESI], EAX	;Is it this terminal
	JNE	6$			;No
	INCL	EAX			;Yes - clear Z
4$:	POPL	EAX
ret010:	RET

;Here if this is not the controlling terminal for the current process

6$:	CLRL	EAX			;Set Z
	POPL	EAX
	RET
.PAGE
	.SBTTL	conmapphys - Subroutine to physically map console screen

;Function to physically map console screen - THIS FUNCTION USES THE C CALLING
;  SEQUENCE.
;	c(BL)  = Page bits
;	c{ECX} = Amount to map
;	c{EAX} = Offset in buffer
;	c{EDX} = Virtual address
;	C{ESI} = Offset of TDB
;	CALL	conmapphys
;	C:set = Error
;	  c{EAX} = Error code
;	C:clr = Normal
;	  c{EAX} = Size of display buffer

;	long xosconMapPhys(
;	    TDB *tdb,		// Address of TDB for the console
;	    long pbits,		// Page bits
;	    char *base,		// Base address for msect to create
;	    long  offset,	// Offset in display buffer (bit 31 set to map
;				//   memory mapped graphics mode registers)
;	    long  size);	// Amount to map

cmp_size  =!20t
cmp_offset=!16t
cmp_base  =!12t
cmp_pbits =!8
cmp_tdb   =!4

xosconMapPhys::
	MOVL	EDX, cmp_tdb[ESP]
	ANDL	cmp_base[ESP], #0xFFFFF000 ;Round down to page boundry
	ANDL	cmp_offset[ESP], #0xFFFFF000
	ADDL	cmp_size[ESP], #0xFFF	;Round up to whole pages
	ANDL	cmp_size[ESP], #0xFFFFF000
	JE	cmpnone
	MOVL	ECX, cmp_size[ESP]
	CMPB	tdb_mode[EDX], #DM_TEXT ;Text mode?
	JNE	cmpgraphics		;No
	MOVL	EBX, tdb_dhdb[EDX]	;Yes
	MOVL	EDX, #0x8000
	SUBL	EDX, cmp_offset[ESP]
	JLE	cmpnone
	CMPL	EDX, cmp_size[ESP]	;Too big?
	JA	4$			;No
	MOVL	ECX, EDX		;Yes - just map what is there
4$:	MOVL	cmp_size[ESP], ECX
	MOVL	EAX, cmp_offset[ESP]
	ADDL	EAX, dhdb_ptaddr[EBX]	;Get physical address of area to map
	PUSHL	#0
	MOVL	EDX, ESP
	PUSHL	cmp_base+4[ESP]		;Virtual address
	PUSHL	#PG$READ|PG$WRITE
	PUSHL	ECX			;Size (bytes)
	PUSHL	EAX			;Physical address
	PUSHL	#0xFFFFFFFF		;Increment mask
	PUSHL	EDX
	CALL	sysMemMapPhys##
	POPL	EDX
	TESTL	EAX, EAX
	JS	cmpdn
	MOVB	mdb_devtype[EDX], #1
	ORB	mdb_sts[EDX], #MSS$NODEALOC ;Indicate not to deallocate
	MOVL	mdb_remove[EDX], #xosconUnmap ;Store offset of subroutine to
					      ;  call when msect is given up
	ORB	mdb_sts[EDX], #MSS$FIXED ;Indicate now fixed size
	MOVL	mdb_devpnt[EDX], ESI	;Link TDB to the MDB
	TOFORK
	MOVL	EAX, tdb_mdb[ESI]	;Link the MDB into the list of MDBs
	MOVL	tdb_mdb[ESI], EDX	;  which map this display
	MOVL	mdb_devnext[EDX], EAX
	MOVL	ECX, mdb_size[EDX]	;Get number of pages
	MOVL	EBX, tdb_vtaddr[ESI]	;Yes - get address of exec mapping
					;  for buffer for this display
	SHRL	EBX, #10t		;Change to page table index
	MOVL	EDX, mdb_base[EDX]	;Get base address of msect
	SHRL	EDX, #10t		;Change to page table index
10$:	MOVL	EAX, knlPgTable##[EBX]	;Copy page table entries from the exec
	ORL	EAX, #0x64
	MOVL	knlPgTable##[EDX], EAX	;  mapping to the msect we just set up
	ADDL	EBX, #4			;  (We must do this in case this screen
	ADDL	EDX, #4			;  has been virtualized - this will
	LOOP	ECX, 10$		;  also handle the case of the screen
12$:	FROMFORK			;  being blocked)
	MOVL	EAX, cmp_size[ESP]	;Get actual amount mapped
cmpdn:	RET

cmpnone:CLRL	EAX
	RET
.PAGE
;Here if not in text mode - This is much easier since we never virtualize or
;  block a graphics mode buffer. This simply maps the requested memory, either
;  the console buffer or the console registers

cmpgraphics:
	MOVL	EAX, cmp_offset[ESP]
	BTZL	EAX, #31t		;Want to map the register window?
	JNC	4$			;No
	MOVL	EBX, tdb_gregsize[EDX]	;Yes
	SUBL	EBX, EAX
	JLE	cmpnone
	CMPL	ECX, EBX		;Too big?
	JBE	2$			;No
	MOVL	ECX, EBX		;Yes
2$:	ADDL	EAX, tdb_gregaddr[EDX]	;Get physical address of register block
	JMP	10$

;Here if mapping the display buffer

4$:	MOVL	EBX, tdb_gbfrsize[EDX]
	SUBL	EBX, EAX
	JLE	cmpnone
	CMPL	ECX, EBX		;Too big?
	JBE	6$			;No
	MOVL	ECX, EBX		;Yes
6$:	ADDL	EAX, tdb_gbfraddr[EDX]	;Get physical address of buffer
10$:	PUSHL	cmp_base[ESP]		;Virtual address
	PUSHL	#PG$READ|PG$WRITE	;Page bits
	PUSHL	ECX			;Size (bytes)
	PUSHL	EAX			;Physical address
	PUSHL	#0xFFFFFFFF		;Increment mask
	PUSHL	#0			;Address for MDB address
	CALL	sysMemMapPhys
	JMP	cmpdn
.PAGE
	.SBTTL	xosconUnmap - Subroutine called when console screen is unmapped

;Subroutine called when msect mapped to text mode console screen is given
;  up - this subroutine is called by the routine which removes msects by
;  dispatching through the mdb_remove item in the MDB
;	c{EDI} = Offset of MDB
;	CALL	xosconUnmap
;	C:clr always
;  Preserves all registers

xosconUnmap::
	PUSHAL				;Save all registers
	PUSHL	ES
	PUSHL	FS
	PUSHL	GS
	MOVL	ESI, mdb_devpnt[EDI]	;Get offset of TDB
	CMPB	tdb_mode[ESI], #DM_TEXT ;Text mode?
	JNE	2$.S			;No
	PUSHL	EDI			;Yes
	MOVL	EDX, EDI		;Get MDB offset where we need it
	CALL	updmsect		;Update page list for the display for
	POPL	EDI			;  this msect
2$:	LEAL	EBX, tdb_mdb-mdb_devnext[ESI] ;Scan through our list of mapped
					      ;  MDBs and find this one
4$:	CMPL	mdb_devnext[EBX], #0 ;Is there another MDB?
	JE	8$.S			;No!
	CMPL	mdb_devnext[EBX], EDI	;Yes - is this it?
	JE	6$.S			;Yes
	MOVL	EBX, mdb_devnext[EBX]	;No - advance to next
	JMP	4$.S			;Continue

;Here with MDB
;	c{EBX} = Offset of previous MDB in list for device

6$:	MOVL	EAX, mdb_devnext[EDI]	;Remove this MDB from the list
	MOVL	mdb_devnext[EBX], EAX
	MOVW	mdb_pda[EDI], #0
	POPL	GS			;Restore registers
	POPL	FS
	POPL	ES
	POPAL
	RET

;Here if cannot find this MDB in the list of MDBs for the terminal

8$:	CRASH	BDML			;[BaD MDB List]
.PAGE
;Subroutine to scan all msects which map a console screen
;	c{EBX} = Data for subroutine pointed to by ECX
;	c{ECX} = Address of subroutine to execute for each msect
;	c{EDI} = Data for subroutine pointed to by ECX
;	c{ESI} = Address of TDB
;	CALL	xosconScanMs

;The subroutine pointed to by ECX must preserve EDX, but may change any other
;  registers that can normally be changed by subroutines

xosconScanMs::
	MOVL	EDX, tdb_mdb[ESI]	;Get first MDB
	TESTL	EDX, EDX		;Mapped at all?
	JE	6$			;No - nothing to do here!
	MOVL	EAX, CR3		;Yes - get current map address
	PUSHL	EAX			;Save it
	PUSHL	ECX			;Save offset of subroutine to call
4$:	MOVL	ECX, mdb_pda[EDX]	;Get address of PDA for msect
	MOVL	EAX, pdaCR3##[ECX]	;Map to its address space
	MOVL	CR3, EAX
	CALLI	[ESP]			;Block or unblock this msect
	MOVL	EDX, mdb_devnext[EDX]	;Get next MDB which has terminal mapped
	TESTL	EDX, EDX
	JNE	4$			;Continue if have another
	POPL	EAX			;Discard subroutine offset
	POPL	EAX			;Finished - restore mapping
	MOVL	CR3, EAX
6$:	RET
.PAGE
	.SBTTL	xosconClrPgChng - Subroutine to clear all page modified bites

;Subroutine to clear all page modified (dirty) bits for the display memory
;	c{ESI} = Offset of TDB for terminal
;	CALL	xosconClrPgChng

xosconClrPgChng::
	CMPB	knlCrashed##, #0	;Has the system crashed?
	JNE	10$			;Yes - do nothing here!
	CMPB	tdb_mode[ESI], #DM_TEXT ;No - in text mode?
	JNE	10$			;No - for now, do nothing!
					;Yes - get linear address of the exec
	MOVL	EAX, tdb_vtaddr[ESI]	;   mapping of the screen
	SHRL	EAX, #12t		;Change to page map index
	MOVL	ECX, #16t		;Get number of exec mapped pages
2$:	ANDB	knlPgTable#[EAX*4], #~0x40 ;Clear the dirty bit
	INCL	EAX			;Bump page table offset
	LOOP	ECX, 2$
	MOVL	ECX, #conclrpgchngmsc	;Update bits from any other msects
	JMP	xosconScanMs		;  which are mapped

;Subroutine to clear page modified (dirty) bits for single msect
;	c{EDX} = Offset of MDB for msect
;	c{ESI} = Offset of TDB for terminal
;	CALL	conclrpgchngmsc

conclrpgchngmsc:
	MOVL	EAX, mdb_base[EDX]	;Get base address of msect
	MOVL	ECX, mdb_size[EDX]	;Get size of msect
	SHRL	EAX, #12t		;Get index into page map
6$:	ANDB	knlPgTable##[EAX*4], #~0x40 ;Clear the dirty bit
	INCL	EAX			;Bump page table offset
	LOOP	ECX, 6$
10$:	RET
.PAGE
	.SBTTL	xosconUpdPgList - Subroutine to update page list entries

;Subroutine to update page list entries for the display memory - Bit 31 and 
;  28 are set in the entires for all modified pages to indicate that the pages
;  have been changed.  The hardware modified bit is also cleared for all pages.
;	c{ESI} = Offset of TDB for terminal
;	CALL	xosconUpdPgList

xosconUpdPgList::
	CMPB	knlCrashed##, #0	;Has the system crashed?
	JNE	10$.S			;Yes - do nothing here!
	CMPB	tdb_mode[ESI], #DM_TEXT ;No - in text mode?
	JNE	10$.S			;No - for now, do nothing!
					;Yes - get linear address of the exec
	MOVL	EBX, tdb_vtaddr[ESI]	;   mapping of the screen
	MOVL	ECX, #16t		;Get number of exec mapped pages
	CALL	updloop			;Scan the map and update the page list
	MOVL	ECX, #updmsect		;Update bits from any other msects
	JMP	xosconScanMs		;  which are mapped

;Subroutine to update page list entries for single msect
;	c{EDX} = Offset of MDB for msect
;	c{ESI} = Offset of TDB for terminal
;	CALL	conupdpglistmsc

updmsect:
	MOVL	EBX, mdb_base[EDX]	;Get base address of msect
	MOVL	ECX, mdb_size[EDX]	;Get size of msect
updloop:SHRL	EBX, #12t		;Get index into page map
	CLRL	EAX
6$:	TESTB	knlPgTable##[EBX*4], #0x40 ;Has this page been changed?
	JE	8$.S			;No
	ANDB	knlPgTable##[EBX*4], #~0x40	;Yes - clear the modified bit
	ORB	tdb_pglist+3[ESI+EAX*4], #{PL$MODIFIED|PL$INCMOD}>24t
8$:	INCL	EAX			;Bump page number
	INCL	EBX			;Bump page table offset
	LOOP	ECX, 6$
10$:	RET
.PAGE
	.SBTTL	conoas - Console once-a-second routine

conoas:	MOVL	EDI, #knlConDhdb##	;Point to the DHDB
2$:	CMPL	dhdb_scsvcnt[EDI], #0	;Is the screen saver enabled?
	JE	4$.S			;No
	DECL	dhdb_scsvcnt[EDI]	;Yes - time to disable the screen?
	JNE	4$.S			;No
	ORB	dhdb_keysts[EDI], #KS$VOFF ;Yes - indicate that
	MOVL	ESI, dhdb_curtdb[EDI]	;Get offset of TDB for current screen
	MOVL	EAX, tdb_ddisp[ESI]	;Disable the screen
	CALLI	tfx_disable[EAX]
4$:	MOVL	EDI, dhdb_next[EDI]	;Get next DHDB
	TESTL	EDI, EDI
	JNE	2$.S			;Go on if have another
	RET				;Finished
.PAGE
	.SBTTL	Data

	DATA

lit10:      .LONG  10t
conftdb:    .LONG  0		;Offset of first console TDB
conltdb:    .LONG  0		;Offset of last console TDB
nonestr:    .ASCII "None"
nullstr:    .BYTE  0

	LKEEND
