	.TITLE	region

;++++
; This software is in the public domain.  It may be freely copied and used
; for whatever purpose you see fit, including commerical uses.  Anyone
; modifying this software may claim ownership of the modifications, but not
; the complete derived code.  It would be appreciated if the authors were
; told what this software is being used for, but this is not a requirement.

;   THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR
;   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
;   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
;   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
;   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
;   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
;   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;----

	.PROC	80386
	.INCLUD	XOSINC:/xmac/xos.par
	.INCLUD	XOSINC:/xmac/xostrm.par
	.INCLUD	XOSINC:/xmac/xosrun.par
	.INCLUD	gecko.par

	CODE

;Define RDB offsets

rdb_id    =!0		;ID ('RGN*')
rdb_user  =!4
rdb_type  =!6		;Region type
rdb_size  =!8		;Total size of RDB (bytes)
rdb_usecnt=!12t		;Use count (number of users - 1)
rdb_ycount=!16t		;Number of Y index table entries
rdb_left  =!20t		;Left side X position
rdb_right =!24t		;Right side X position
rdb_top   =!28t		;Top Y position
rdb_bottom=!32t		;Bottom Y position
rdb_ytable=!36t		;Start of the Y index table


RGNCCOLOR=!0x8000	;Color for filling complex region
RGNSCOLOR=!0x0400	;Color for filling simple region
BKGCOLOR =!0x4208	;Color for background

showregion::
	CMPB	gphmode#, #0		;Graphic mode now?
	JNE	4$			;Yes
	MOVL	EBX, #rgngphmsg		;No - can't do this
	JMP	outstrca#

;Here if graphic mode

4$:	CALL	getfld#			;Get address
	JC	6$			;If error
	CALL	chkend#			;Must be last thing on line
	JNC	10$			;If OK
6$:	RET

;Here with address of region to display

10$:	MOVL	EBX, value#
	CALL	getmlong#
	JC	hvaerr#
	CMPL	EAX, #'RGN#'
	JNE	rgnid
	MOVL	EBX, value#
	ADDL	EBX, #rdb_type
	CALL	getmbyte#
	JC	hvaerr#
	CMPB	AL, #1			;Simple region?
	JE	rgnsimple		;Yes
	JB	rgnnull			;No - null region
	JNE	rgncomplex		;If complex region
rgnbad:	MOVL	EBX, #rgnbadmsg
	JMP	outstrca#

rgnid:	MOVL	EBX, #rgnidmsg
	JMP	outstrca#
.PAGE
;Here if have a null region

rgnnull:MOVL	EBX, #rgnnulmsg
	JMP	outstrca#

;Here if have a simple region

rgnsimple:
	PUSHL	EDX
	CALL	rgnclear		;Clear the screen
	POPL	EDX
	MOVL	EBX, #rdb_top
	CALL	rgngetlong
	TESTL	EAX, EAX
	JNS	2$
	CLRL	EAX
2$:	CMPL	EAX, dispdata#+dm_vert
	JL	4$
	MOVL	EAX, dispdata#+dm_vert
	DECL	EAX
4$:	MOVL	rgntop, EAX
	MOVL	EBX, #rdb_bottom
	CALL	rgngetlong
	TESTL	EAX, EAX
	JNS	6$
	CLRL	EAX
6$:	CMPL	EAX, dispdata#+dm_vert
	JL	8$
	MOVL	EAX, dispdata#+dm_vert
	DECL	EAX
8$:	MOVL	rgnbottom, EAX
	MOVL	EBX, #rdb_left
	CALL	rgngetlong
	TESTL	EAX, EAX
	JNS	10$
	CLRL	EAX
10$:	CMPL	EAX, dispdata#+dm_horiz
	JL	12$
	MOVL	EAX, dispdata#+dm_horiz
	DECL	EAX
12$:	MOVL	rgnleft, EAX
	MOVL	EBX, #rdb_right
	CALL	rgngetlong
	TESTL	EAX, EAX
	JNS	14$
	CLRL	EAX
14$:	CMPL	EAX, dispdata#+dm_horiz
	JL	16$
	MOVL	EAX, dispdata#+dm_horiz
	DECL	EAX
16$:	MOVL	rgnright, EAX

;Make sure this is a valid region

	MOVL	EAX, rgntop
	CMPL	EAX, rgnbottom
	JG	18$
	MOVL	EAX, rgnleft
	CMPL	EAX, rgnright
18$:	JG	rgninv

;Here with valid simple region we can safely display

	MOVL	EDI, rgntop		;Calculate starting position
	IMULL	EDI, dispdata#+dm_horiz
	ADDL	EDI, rgnleft
	ADDL	EDI, EDI
	ADDL	EDI, #gphscnbufr#
	ADDL	EDI, dispdata#+dm_pagesize
	MOVL	EAX, #RGNSCOLOR+{RGNSCOLOR<16t} ;Get color value in both
	MOVL	EDX, rgnbottom			;  halves of EAX
	SUBL	EDX, rgntop		;Get height
	INCL	EDX
	MOVL	EBX, rgnright		;Get width
	SUBL	EBX, rgnleft
	INCL	EBX
	PUSHL	EBP
	MOVL	EBP, dispdata#+dm_horiz
	ADDL	EBP, EBP
	SHRL	EBX, #1t
	JC	22$			;If odd value

;Here if width is even

20$:	MOVL	ECX, EBX
	MOVL	ESI, EDI
	RSTOSL	[EDI]
	MOVL	EDI, ESI
	ADDL	EDI, EBP
	DECL	EDX
	JNE	20$
	JMP	24$

;Here if width is odd

22$:	MOVL	ECX, EBX
	MOVL	ESI, EDI
	RSTOSL	[EDI]
	STOSW	[EDI]
	MOVL	EDI, ESI
	ADDL	EDI, EBP
	DECL	EDX
	JNE	22$
24$:	POPL	EBP
rgndone:MOVB	nocursor#, #1
	CALL	inpchx#
	MOVB	nocursor#, #0
rgndn2:	CALL	rgnclear
	JMP	cpygph#

;Here if the region is invalid

rgninv:	CALL	rgndn2
	MOVL	EBX, #rgninvmsg
	JMP	outstrca#
.PAGE
;Here to fill a complex region

rgncomplex:
	CALL	rgnclear		;Clear the screen
	MOVL	EBX, #rdb_ycount	;Get number of lines
	CALL	rgngetlong
	MOVL	rgncnt1, EAX
	MOVL	EBX, #rdb_top		;Calculate start of first line
	CALL	rgngetlong
	MOVL	rgnline, EAX
	IMULL	EAX, dispdata+dm_horiz
	ADDL	EAX, EAX
	MOVL	rgnbegin, EAX
	MOVL	rgnypnt, #rdb_ytable
	MOVL	EBX, #rdb_left		;Calculate maximum number of segments
	CALL	rgngetlong
	MOVL	rgnmaxsegs, EAX
	MOVL	EBX, #rdb_right
	CALL	rgngetlong
	SUBL	EAX, rgnmaxsegs
	INCL	EAX
	SHRL	EAX, #1
	CMPL	EAX, #1
	JA	2$
	MOVL	EAX, #1
2$:	MOVL	rgnmaxsegs, EAX
	CLRL	EAX
	MOVL	rgnlinenum, EAX

4$:	MOVL	EBX, rgnypnt
	ADDL	rgnypnt, #4
	CALL	rgngetlong
	MOVL	rgnsegment, EAX
	TESTL	EAX, EAX		;Null line?
	JE	16$			;Yes
	MOVL	EDX, rgnline		;No - is this line on the screen?
	INCL	rgnline
	TESTL	EDX, EDX
	JS	16$			;No - skip it
	CMPL	EDX, dispdata#+dm_vert	;Maybe - past bottom?
	JGE	rgndone			;Yes - finished

	MOVL	EBX, EAX		;Get number of segments in line
	ADDL	rgnsegment, #4
	CALL	rgngetlong
	TESTL	EAX, EAX
	JE	rgn0cnt
	CMPL	EAX, rgnmaxsegs
	JA	rgn2msg
	MOVL	rgncnt2, EAX
6$:	MOVL	EBX, rgnsegment		;Get beginning of segment
	CALL	rgngetlong
	CMPL	EAX, dispdata#+dm_horiz
	JGE	16$			;If completely to right of screen
	TESTL	EAX, EAX
	JNS	8$
	CLRL	EAX
8$:	MOVL	rgnsegbgn, EAX
	MOVL	EBX, rgnsegment		;Get end of segment
	ADDL	EBX, #4
	CALL	rgngetlong
	CMPL	EAX, dispdata#+dm_horiz
	JL	10$
	MOVL	EAX, dispdata#+dm_horiz
	DECL	EAX
10$:	MOVL	EDI, rgnsegbgn
	SUBL	EAX, EDI		;Get length of segment
	JL	14$			;If null segment
	LEAL	ECX, 1[EAX]
	ADDL	EDI, EDI
	ADDL	EDI, #gphscnbufr#
	ADDL	EDI, dispdata#+dm_pagesize
	ADDL	EDI, rgnbegin
	MOVL	EAX, #RGNCCOLOR+{RGNCCOLOR<16t}
	TESTL	EDI, #0x02
	JE	12$
	STOSW	[EDI]
	DECL	ECX
12$:	MOVL	EBX, ECX
	SHRL	ECX, #1t
	RSTOSL	[EDI]
	TESTB	BL, #0x02
	JE	14$
	STOSW	[EDI]
14$:	ADDL	rgnsegment, #8t
	DECL	rgncnt2			;More segments for this line?
	JNE	6$			;Yes - continue
16$:	MOVL	EAX, dispdata+dm_horiz
	ADDL	EAX, EAX
	ADDL	rgnbegin, EAX
	INCL	rgnlinenum
	DECL	rgncnt1			;No - more lines?
	JNE	4$			;Yes - continue
	JMP	rgndone

;Here if segment count is 0

rgn0cnt:MOVL	EBX, #rgn0cnmsg
	JMP	20$

;Here if segment count is too large

rgn2msg:MOVL	EBX, #rgn2msmsg

20$:	MOVL	ECX, #linebuf#
22$:	MOVB	AL, CS:[EBX]
	CMPB	AL, #0
	JE	24$
	MOVB	[ECX], AL
	INCL	EBX
	INCL	ECX
	JMP	22$

24$:	MOVL	EAX, rgnlinenum
	CALL	rgnputval
	MOVW	[ECX], #TXT
	MOVL	EBX, #linebuf#
	CALL	outstrca#
	JMP	rgndn2

rgnputval:
	CLRL	EDX
	IDIVL	lit10#
	PUSHL	EDX
	TESTL	EAX, EAX
	JE	26$
	CALL	rgnputval
26$:	POPL	EAX
	ADDL	EAX, #'0'
	MOVB	[ECX], AL
	INCL	ECX
	RET
.PAGE
;Subroutine to clear display before displaying region

rgnclear::
	MOVL	EDI, #gphscnbufr#
	ADDL	EDI, dispdata#+dm_pagesize
	MOVL	ECX, dispdata#+dm_vert	;Fill entire screen with the
	IMULL	ECX, dispdata#+dm_horiz	;  background color
	SHRL	ECX, #1
	MOVL	EAX, #BKGCOLOR+{BKGCOLOR<16t}
	RSTOSL	[EDI]
	CLRL	EDX
	MOVL	EAX, dispdata#+dm_vert
	SUBL	EAX, #2
	MOVL	ECX, #100t
	DIVL	ECX
	MOVL	EDX, EAX
	CLRL	EAX			;Draw the horizontal grid lines
	INCL	EAX
	MOVL	ESI, dispdata#+dm_horiz
	IMULL	ESI, #99t*2
	MOVL	EDI, #gphscnbufr#
	ADDL	EDI, dispdata#+dm_pagesize
4$:	MOVL	ECX, dispdata#+dm_horiz
	SHRL	ECX, #1
	RSTOSL	[EDI]
	ADDL	EDI, ESI
	DECL	EDX
	JNS	4$
	MOVL	EDX, dispdata#+dm_horiz	;Draw the vertical grid lines
	ADDL	EDX, EDX
	MOVL	ECX, dispdata#+dm_vert
	MOVL	EDI, #gphscnbufr#
	ADDL	EDI, dispdata#+dm_pagesize
10$:	CLRL	EAX
12$:	MOVL	[EDI+EAX], #0
	ADDL	EAX, #100t*2
	CMPL	EAX, EDX
	JB	12$
	ADDL	EDI, dispdata#+dm_horiz
	ADDL	EDI, dispdata#+dm_horiz
	LOOP	ECX, 10$
	RET
.PAGE
;Subroutine to get long from the RDB
;	c{EBX} = Offset of value in RDB
;	CALL	rgngetlong
;	c{EAX} = Value
;  DOES NOT RETURN IF ERROR!

rgngetlong:
	ADDL	EBX, value
	CALL	getmlong#
	JC	4$			;If error
	RET

;Here if error reading region data

4$:	POPL	EAX			;Discard our return address
	CALL	rgndn2			;Restore the Gecko screen
	JMP	hvaerr			;And fail
.PAGE
rgngphmsg:.ASCIZ {ERR,LF,CLR}"? Command requires graphics mode"{TXT}
rgnnulmsg:.ASCIZ {LF,CLR}"Region is null"
rgnidmsg: .ASCIZ {ERR,LF,CLR}"? Region ID is wrong"{TXT}
rgnbadmsg:.ASCIZ {ERR,LF,CLR}"? Region type is illegal"{TXT}
rgninvmsg:.ASCIZ {ERR,LF,CLR}"? Region is invalid"{TXT}
rgndonmsg:.ASCIZ {LF,CLR}"Region is done"
rgn0cnmsg:.ASCIZ {ERR,LF,CLR}"? Region has 0 segment count for line "
rgn2msmsg:.ASCIZ {ERR,LF,CLR}"? Region has too many segments in line "

	DATA

rgntop:	.LONG	0
rgnbottom:
	.LONG	0
rgnleft:.LONG	0
rgnright:

rgncnt1:.LONG	0
rgncnt2:.LONG	0
rgnbegin:
	.LONG	0
rgnline:.LONG	0
rgnsegbgn:
	.LONG	0
rgnsegment:
	.LONG	0
rgnypnt:.LONG	0
	.LONG	0

rgnmaxsegs:
	.LONG	0
rgnlinenum:
	.LONG	0
